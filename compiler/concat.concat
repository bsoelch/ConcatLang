## concat compiler written in concat

## currently in early development phase

stack   #include
chars   #include
valueIO #include
utf8    #include
core    #import

hashMap #include
hashMap #import

bufferedIO #include
io #import

FilePosition tuple string uint uint end
FilePosition.fileName   #define 0 []   #end
FilePosition.line       #define 1 []   #end
FilePosition.line=      #define 1 [] = #end
FilePosition.posInLine  #define 2 []   #end
FilePosition.posInLine= #define 2 [] = #end
FilePosition.newLine    #define dup dup 1 [] 1 + 1 [] = 1 2 [] = #end
FilePosition.nextChar   #define dup 2 [] 1 + 2 [] = #end
FilePosition.strAppend proc string FilePosition => string :
  FilePosition position =:
  string str =:
  str position FilePosition.fileName :+
  ':' :<< position FilePosition.line      10 true false intToString :+
  ':' :<< position FilePosition.posInLine 10 true false intToString :+ return
end

TokenType enum
  WORD
  KEY_WORD
  PROCEDURE_START
  ENUM_START
  VALUE
  IDENTIFIER
  OPERATOR
end
Token tuple TokenType FilePosition end
Token.type  #define 0 [] #end
Token.pos   #define 1 [] #end
WordToken tuple TokenType FilePosition string end
WordToken.value #define 2 [] #end
##TODO wrap values
ValueToken tuple TokenType FilePosition var end
ValueToken.value #define 2 [] #end

IdentifierType enum
  UNMODIFIED
  WRITE
  DECLARE
  CONST_DECLARE
  ADDRESS_OF
end
IdentifierToken tuple TokenType FilePosition IdentifierType string end
IdentifierToken.idType #define 2 [] #end
IdentifierToken.value  #define 3 [] #end

OperatorType enum
  PLUS MINUS NEGATE INVERT MULTIPLY DIVIDE MOD
  NOT FLIP AND OR XOR  SHIFT_L SHIFT_R
  LT LE EQ REF_EQ REF_NE NE GE GT
end
OperatorToken tuple TokenType FilePosition OperatorType end
OperatorToken.opType #define 2 [] #end

Token.strAppend proc string Token => string :
  Token token =:

  TokenType token Token.type [] +: ": " +:
  token Token.type switch
  TokenType WORD . TokenType KEY_WORD . TokenType PROCEDURE_START . TokenType ENUM_START . case
    token WordToken.value :+
    end-case
  TokenType VALUE . case
    token ValueToken.value typeof stringValue :+ ": " :+ token ValueToken.value  stringValue :+
    end-case
  TokenType IDENTIFIER . case
    IdentifierType token IdentifierToken.idType [] :+ ": " :+ token IdentifierToken.value :+
    end-case
  TokenType OPERATOR . case
    OperatorType token OperatorToken.opType [] :+
    end-case
  end
end

DeclarableType enum
  MACRO
  ENUM
  VARIABLE
  CONSTANT
  PROCEDURE
end
DeclarableType.strAppend proc #_str_# string #_a_# bool #_type_# DeclarableType => string :
   #_type_# switch
   DeclarableType MACRO . case
     #_a_# if "a macro" else "macro" end :+ return
     end-case
   DeclarableType ENUM . case
     #_a_# if "an enum" else "enum" end :+ return
     end-case
   DeclarableType VARIABLE . case
     #_a_# if "a variable" else "variable" end :+ return
     end-case
   DeclarableType CONSTANT . case
     #_a_# if "a constant" else "constant" end :+ return
     end-case
   DeclarableType PROCEDURE . case
     #_a_# if "a procedure" else "procedure" end :+ return
     end-case
   end
end

Declarable tuple #_type_# DeclarableType #_pos_# FilePosition end

Declarable.type #define 0 []   #end
Declarable.pos  #define 1 []   #end
Declarable.pos= #define 1 [] = #end

Macro tuple #_type_# DeclarableType #_pos_# FilePosition #_name_# string #_words_# string list end
Macro.name  #define 2 []   #end
Macro.name= #define 2 [] = #end
Macro.words #define 3 []   #end
newMacro proc FilePosition string => Macro :
  string name =:
  FilePosition mPos =:
  DeclarableType MACRO . mPos name 16 byte list new Macro new return
end

VariableId tuple #_type_# DeclarableType #_pos_# FilePosition end ##TODO variable
CurriedVariable tuple #_type_# DeclarableType #_pos_# FilePosition end ##TODO curried variable
PredeclaredProc tuple #_type_# DeclarableType #_pos_# FilePosition end ##TODO predeclared proc

ContextType enum ROOT_CONTEXT PROC_CONTEXT BLOCK_CONTEXT end

Context tuple #_elements_# HashMap #_varCount_# int #_contextType_# ContextType end
Context.elements    #define 0 [] #end
Context.varCount    #define 1 [] #end
Context.type        #define 2 [] #end
Context.incVarCount #define dup 1 [] 1 + 1 [] = #end

OpenModule tuple #_path_# string list #_declaredAt_# FilePosition #_imports_# string list #_predeclared_# HashMap end
OpenModule.path        #define 0 [] #end
OpenModule.declaredAt  #define 1 [] #end
OpenModule.imports     #define 2 [] #end
OpenModule.predeclared #define 3 [] #end
newOpenModule proc #_path_# string list #_declaredAt_# FilePosition => OpenModule :
  16 string list new string PredeclaredProc 16 newHashMap OpenModule new return
end
OpenModule.strAppend proc string OpenModule => string :
  string str =:
  OpenModule m =:
  0 int i =:
  while i m OpenModule.path length < do
     str m OpenModule.path i [] :+ "'" :+
  end
  str " declared at " :+ m OpenModule.declaredAt FilePosition.strAppend return
end

OpenFile tuple #_global imports _# string list #_global predeclared_# HashMap
    #_openModules_# OpenModule list #_declared_#HashMap list end
OpenFile.globalImports     #define 0 [] #end
OpenFile.globalPredeclared #define 1 [] #end
OpenFile.openModules       #define 2 [] #end
OpenFile.declared          #define 3 [] #end
newOpenFile proc => OpenFile :
  16 string list new
  string PredeclaredProc 16 newHashMap
  16 OpenModule list new
  string Declarable newHashMap OpenFile new return
end

RootContext tuple #_elements_# HashMap #_varCount_# int #_contextType_# ContextType
    #_openFiles_# OpenFile list #_modules_# HashMap end
RootContext.openFiles #define 3 [] #end
RootContext.modules   #define 4 [] #end

BlockContext tuple #_elements_# HashMap #_varCount_# int #_contextType_# ContextType #_parent_# Context end
BlockContext.parent #define 3 [] #end

ProcContext tuple #_elements_# HashMap #_varCount_# int #_contextType_# ContextType #_parent_# Context
   #_curried_# CurriedVariable list end
ProcContext.curried #define 4 [] #end

Context.ensureDeclarable proc #_context_# Context #_name_#string #_type_# DeclarableType #_pos_# FilePosition => :
  FilePosition fPos =:
  DeclarableType dType =:
  string name =:
  Context context =:
  context Context.elements name HashMap.get ?? if
    unwrap Declarable prev =:
    "cannot declare " false dType DeclarableType.strAppend :+ ' ' :<< name :+
    ", the identifier is already used by " :+ true prev Declarable.type DeclarableType.strAppend :+
    " (declared at " prev Declarable.pos FilePosition.strAppend ") at " :+ fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  else drop end
end
Context.checkShadowed proc #_context_# Context #_declared_# Declarable #_name_#string #_pos_# FilePosition => :
  ##TODO check shadowed
  "unimplemented\n" eputs
  1 exit
end
Context.level proc Context => int :
  Context context =:
  context Context.type switch
  ContextType ROOT_CONTEXT . ContextType PROC_CONTEXT . case
    0 return
    end-case
  ContextType BLOCK_CONTEXT . case
    context BlockContext.parent Context.level 1 + return
    end-case
  end
end
Context.getDeclarable proc #_context_# Context #_name_# string => Declarable optional :
    string name =:
    Context context =:
    context Context.type switch
    ContextType ROOT_CONTEXT . case
      context RootContext.currentPaths string list paths =:
      paths length 1 - int i =:
      while i 0 >= do ##go through all modules
        context Context.elements paths i [] clone name :+ HashMap.get ?? if
          return
        else drop end
      end
      context Context.elements name HashMap.get return
      end-case
    ContextType PROC_CONTEXT . ContextType BLOCK_CONTEXT . case
      context Context.elements name HashMap.get ?? if
        #_element_# return
      else drop
        context BlockContext.parent name Context.getDeclarable return
      end
      end-case
    end
end
MODULE_SEPARATOR #define '\'' #end
RootContext.startFile proc RootContext => :
  RootContext.openFiles OpenFile new :<< drop
end
RootContext.file proc RootContext => OpenFile :
  RootContext.openFiles RootContext.openFiles length 1 - [] return
end

RootContext.inCurrentModule proc RootContext  #_name_# string => string :
   string name =:
   #_context_# RootContext.file OpenFile.openModules OpenModule list modules =:
   modules length 0 > if
    "" string path =:
     0 int i =:
     while i modules length < do
        modules i [] OpenModule.path string list paths =:
        0 int j =:
        while j paths length < do
          path paths j [] :+ MODULE_SEPARATOR :<< path =
          j 1 + j =
        end
        i 1 + i =
     end
     path name :+ return
   end
   name return
end
RootContext.startModule proc RootContext #_name_# string #_declaredAt_# FilePosition => :
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context Context.elements context name RootContext.inCurrentModule HashMap.get ?? if
    unwrap Declarable d =:
    "cannot declare module " name :+ ", the identifier is already used by " :+
    true d Declarable.type DeclarableType.strAppend :+
    " (declared at " d Declarable.pos FilePosition.strAppend ")\n" :+
    " at " fPos  FilePosition.strAppend '\n' :<< eputs
    1 exit
  else drop end
  context "" RootContext.inCurrentModule string fullPath =:
  16 string list new string list path =:
  "" string tmp =:
  0 int i =:
  while i name length < do
    fullPath name i [] :<< fullPath =
    tmp name i [] :<< tmp =
    name i [] MODULE_SEPARATOR == if
      context RootContext.modules fullPath clone true HashMap.put drop
      path tmp :<< path =
      "" tmp =
    end
  end
  fullPath MODULE_SEPARATOR :<< fullPath =
  context RootContext.modules fullPath clone true HashMap.put drop
  context RootContext.file OpenFile.openModules path fPos newOpenModule :<< drop
end
RootContext.addImport proc RootContext #_name_# string #_declaredAt_# FilePosition => :
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context RootContext.modules name HashMap.contains if
     name clone "'" :<< name =
     context RootContext.file OpenFile file =:
     file OpenFile.openModules length 0 > if
         file OpenFile.openModules file OpenFile.openModules length 1 - [] OpenModule.imports name :<< drop
     else
         file OpenFile.globalImports name :<< drop
     end
  else context Context.elements name HashMap.get ?? _if
    unwrap
    ##addLater static imports
    drop
    "static imports are currently unimplemented"
    1 exit
  else drop
    ##addLater formatted printing of module paths
    "module " name :+ " does not exist" :+ pos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end
RootContext.endModule proc RootContext FilePosition => :
  FilePosition fPos =:
  RootContext context =:
  context RootContext.file OpenFile file =:
  file OpenFile.openModules length 0 == if
    "Unexpected End of module" fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
  file OpenFile.openModules file OpenFile.openModules length 1 - [] OpenModule removed =:
  file OpenFile.openModules file OpenFile.openModules length 1 - file OpenFile.openModules length [:] clear
  removed OpenModule.predeclared HashMap.size 0 > if
    "Syntax Error: missing variables/procedures" string message =:
    removed OpenModule.predeclared HashMap.itr while HashMapItr.next ?? do
       unwrap MapEntry e =:
       message "\n- " :+ e MapEntry.key :+ " (at " :+ e MapEntry.value Declarable.pos FilePosition.strAppend ')' :<<
    end drop drop
    message fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end
RootContext.endFile proc RootContext FilePosition => :
  FilePosition fPos =:
  RootContext context =:
  context RootContext.openFiles context RootContext.openFiles length 1 - [] OpenFile closed =:
  context RootContext.openFiles context RootContext.openFiles length 1 - context RootContext.openFiles length [:] clear
  closed OpenFile.openModules length 0 > if
    "unclosed modules at end of File:\n" eputs
    closed OpenFile.openModules length 1 - int i =:
    while i 0 >= do
      closed OpenFile.openModules i [] OpenModule removed =:
      removed OpenModule.predeclared HashMap.size 0 > if
        "Syntax Error: missing variables/procedures" string message =:
        removed OpenModule.predeclared HashMap.itr while HashMapItr.next ?? do
           unwrap MapEntry e =:
           message "\n- " :+ e MapEntry.key :+ " (at " :+ e MapEntry.value Declarable.pos FilePosition.strAppend ')' :<<
        end drop drop
        message fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      closed OpenFile.openModules clear
      " - " removed OpenModule.strAppend '\n' :<< eputs
    end
  end
  closed OpenFile.globalPredeclared HashMap.size 0 > if
    "Syntax Error: missing variables/procedures" string message =:
    closed OpenFile.globalPredeclared HashMap.itr while HashMapItr.next ?? do
       unwrap MapEntry e =:
       message "\n- " :+ e MapEntry.key :+ " (at " :+ e MapEntry.value Declarable.pos FilePosition.strAppend ')' :<<
    end drop drop
    message fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end

RootContext.currentPaths proc RootContext => string list :
  #_context_# RootContext.file OpenFile file =:
  file OpenFile.globalImports clone string list paths =:
  16 string new string path =:
  file OpenFile.openModules OpenModule list modules =:
  0 int i =:
  while i modules length < do
    modules i [] OpenModule.path string list mPath =:
    0 int j =:
    while j mPath length < do
      path mPath j [] :+ MODULE_SEPARATOR :<< path =
      j 1 + j =
      paths path clone :<< paths =
    end
    paths  modules i [] OpenModule.imports  paths length 2 - paths length 2 - [:] =
    i 1 + i =
  end
  paths return
end


BlockType enum
  IF_BLOCK
  &&_BLOCK
  ||_BLOCK
  WHILE_BLOCK
  SWITCH_BLOCK
  PROC_BLOCK
  ENUM_BLOCK
  TUPLE_BLOCK
end
CodeBlock tuple #_type_# BlockType #_startPos_# FilePosition #_start_# int end
CodeBlock.type     #define 0 [] #end
CodeBlock.startPos #define 1 [] #end
CodeBlock.start    #define 2 [] #end
NameWithPos tuple string FilePosition end
EnumBlock tuple #_type_# BlockType #_startPos_# FilePosition #_start_# int
  #_name_# string #_elements_# NameWithPos list end
EnumBlock.name     #define 3 [] #end
EnumBlock.elements #define 4 [] #end
newEnumBlock proc #_name_# string #_startPos_# FilePosition #_start_# int => EnumBlock :
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType ENUM_BLOCK . startPos start name 16 NameWithPos list new EnumBlock new return
end
TupleBlock tuple #_type_# BlockType #_startPos_# FilePosition #_start_# int #_name_# string end
TupleBlock.name     #define 3 [] #end
newTupleBlock proc #_name_# string #_startPos_# FilePosition #_start_# int => EnumBlock :
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType TUPLE_BLOCK . startPos start name TupleBlock new return
end

ParserReader tuple BufferedInput FilePosition string FilePosition end
ParserReader.in       #define 0 [] #end
ParserReader.pos      #define 1 [] #end
ParserReader.word     #define 2 [] #end
ParserReader.wordPos  #define 3 [] #end
ParserReader.nextWord proc ParserReader => :
  ParserReader reader =:
  reader ParserReader.word clear
  reader ParserReader.wordPos  reader ParserReader.pos FilePosition.line       FilePosition.line=
  reader ParserReader.wordPos  reader ParserReader.pos FilePosition.posInLine  FilePosition.posInLine=
end
ParserReader.nextByte proc ParserReader => byte optional :
  ParserReader reader =:
  reader ParserReader.in nextByte byte optional next =:
  next ?? if
    unwrap '\n' == if
      reader ParserReader.pos FilePosition.newLine
    else
      reader ParserReader.pos FilePosition.nextChar
    end
  else
    drop
  end
  next return
end

ParseState enum
  STATE_WORD
  STATE_STRING
  STATE_USTRING
  STATE_CHAR
  STATE_UCHAR
  STATE_COMMENT
  STATE_LINE_COMMENT
end

OpenBlocks tuple Macro CodeBlock list end
OpenBlocks.currentMacro  #define 0 []   #end
OpenBlocks.currentMacro= #define 0 [] = #end
OpenBlocks.blocks        #define 1 []   #end

parseWord proc #_word_# string #_next_# string #_pos_# FilePosition #_open_blocks_# OpenBlocks #_tokens_# Token list => :
  Token list tokens =:
  OpenBlocks openBlocks =:
  FilePosition fPos =:
  string       next =:
  string       word =:
  word length 0 > if
    openBlocks OpenBlocks.currentMacro Macro.name length 0 > if
      word switch
      "#end" case
        ##TODO save macro
        openBlocks fPos "" newMacro OpenBlocks.currentMacro=
        end-case
      "#define" "#undef" "#module" "#include" "#import" "proc" "procedure" "enum" "tuple" case
        word " is not allowed in macros " :+ fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
        end-case
      default
        openBlocks OpenBlocks.currentMacro Macro.words word :<< drop
      end
      return
    end
    ##keywords that consume one or more words
    word switch
    ## identifier - modifiers
    "."  case
      tokens length 2 < if
        "not enough arguments for . " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 2 - [] Token prePrev =:
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '.' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      prePrev Token.type TokenType WORD . != if
        "invalid token for '.' modifier: " prePrev Token.strAppend ' ' :<< prePrev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType WORD . fPos prePrev WordToken.value '\'' :<< prev WordToken.value :+ WordToken new tokens length 2 - [] =
      tokens tokens length 1 - tokens length [:] clear
      end-case
    "="  case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos IdentifierType WRITE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "=:" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=:' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos IdentifierType DECLARE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "=$" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=$' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos
        IdentifierType CONST_DECLARE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "@()" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '@()' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos
        IdentifierType ADDRESS_OF . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    ## macro&module key-words
    "#define" case
      tokens length 0 == if
        "missing macro name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for macro name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.currentMacro prev WordToken.value Macro.name=
      openBlocks OpenBlocks.currentMacro prev Token.pos   Declarable.pos=
      end-case
    "#undef" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#module" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#end" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#import" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#include" case
      "unimplemented\n" eputs
      1 exit
      end-case
    ## proc/enum key-words
    "proc" "procedure" case
      tokens length 0 == if
        "missing procedure name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for procedure name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType PROCEDURE_START . fPos prev WordToken.value WordToken new tokens length 1 - [] =
      openBlocks OpenBlocks.blocks BlockType PROC_BLOCK . fPos tokens length CodeBlock new :<< drop
      end-case
    "enum" case
      tokens length 0 == if
        "missing enum name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for enum name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.blocks prev WordToken.value fPos tokens length newEnumBlock :<< drop
      end-case
    "tuple" case
      tokens length 0 == if
        "missing tuple name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for tuple name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.blocks prev WordToken.value fPos tokens length newTupleBlock :<< drop
      end-case
    default
      tokens length 0 > && next "." != end if
        tokens tokens length 1 - [] Token prev =:
        prev Token.type TokenType WORD . == if
          ##TODO resolve identifiers
          tokens TokenType IDENTIFIER . fPos
            IdentifierType UNMODIFIED . prev WordToken.value IdentifierToken new tokens length 1 - [] =
        end
      end
      ## try parsing as integer
      0 int off =:
      ## detect signs
      false bool sgn =:
           word 0 [] '-' ==  if
        true sgn =
        off 1 + off =
      else word 0 [] '+' == _if
        off 1 + off =
      end
      10 int base =:
      ##detect base modifiers
      word length off - 3 > if
             word off off 2 + [:] "0b" ==  if
          2 base =
          off 2 + off =
        else word off off 2 + [:] "0x" == _if
          16 base =
          off 2 + off =
        end
      end
      off word length < && word off [] base valueOfDigit 0 >= end if ##number starts with digit after prefixes
        word word length 1 - [] dup 'u' == || 'U' == end if ##unsigned
          word off word length 1 - [:] base true stringToInt switch
          StringParseError ERR_NONE . case
            sgn if -_ end uint val =:
            tokens TokenType VALUE . fPos val  ValueToken new :<< tokens =
            return
            end-case
          StringParseError ERR_OVERFLOW . case
            "value does not fit in an unsigned int: \"" word :+ "\" " :+
                fPos FilePosition.strAppend '\n' :<< eputs
            1 exit
            end-case
          StringParseError ERR_BASE . StringParseError ERR_EMPTY . StringParseError ERR_ILLEGAL_CHAR . case
            drop
            end-case
          end
        else
          word off word length [:] base false stringToInt switch
          StringParseError ERR_NONE . case
              sgn if -_ end int val =:
              tokens TokenType VALUE . fPos val  ValueToken new :<< tokens =
              return
            end-case
          StringParseError ERR_OVERFLOW . case
            "value does not fit in a signed int: \"" word :+ "\" " :+
                fPos FilePosition.strAppend '\n' :<< eputs
            1 exit
            end-case
          StringParseError ERR_BASE . StringParseError ERR_EMPTY . StringParseError ERR_ILLEGAL_CHAR . case
            drop
            end-case
          end
          word off word length [:] base stringToFloat StringParseError ERR_NONE . == if
            sgn if -_ end float val =:
            tokens TokenType VALUE . fPos val  ValueToken new :<< tokens =
            return
          else
            drop
          end
        end
      end
      ## end integer parsing
      ##constants, operators and remaining keywords
      word switch
      ## detect true and false
      "true" case
        tokens TokenType VALUE . fPos true  ValueToken new :<< tokens =
        end-case
      "false" case
        tokens TokenType VALUE . fPos false ValueToken new :<< tokens =
        end-case
      ## detect primitive type-names
      "bool" case
        tokens TokenType VALUE . fPos bool ValueToken new :<< tokens =
        end-case
      "byte" case
        tokens TokenType VALUE . fPos byte ValueToken new :<< tokens =
        end-case
      "int" case
        tokens TokenType VALUE . fPos int ValueToken new :<< tokens =
        end-case
      "uint" case
        tokens TokenType VALUE . fPos uint ValueToken new :<< tokens =
        end-case
      "codepoint" case
        tokens TokenType VALUE . fPos codepoint ValueToken new :<< tokens =
        end-case
      "type" case
        tokens TokenType VALUE . fPos type ValueToken new :<< tokens =
        end-case
      "var" case
        tokens TokenType VALUE . fPos var ValueToken new :<< tokens =
        end-case
      ## control-flow key-words
      "lambda" "Î»" case
        openBlocks OpenBlocks.blocks BlockType PROC_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "return" "exit" case
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "=>" ":" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in (lambda-)procedures " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType PROC_BLOCK . != if
          word " can only be used in (lambda-)procedures " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        ##TODO update procedure-block
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "while" case
        openBlocks OpenBlocks.blocks BlockType WHILE_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "do" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in while-statement " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType PROC_BLOCK . != && block CodeBlock.type BlockType WHILE_BLOCK . != end if
          word " can only be used in while-statement " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        ##TODO update while-block
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "if" case
        openBlocks OpenBlocks.blocks BlockType IF_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "else" "_if" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in if-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType IF_BLOCK . != if
          word " can only be used in if-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        ##TODO update if-block
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "&&" case
        openBlocks OpenBlocks.blocks BlockType &&_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "||" case
        openBlocks OpenBlocks.blocks BlockType ||_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "switch" case
        openBlocks OpenBlocks.blocks BlockType SWITCH_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "case" "end-case" "default" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in switch-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType SWITCH_BLOCK . != if
          word " can only be used in switch-blocks " :+  fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        ##TODO update switch-block
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "end" case
        openBlocks OpenBlocks.blocks length 0 == if
          "unexpected end-statement " fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - openBlocks OpenBlocks.blocks length [:] clear
        ## TODO close block
        block CodeBlock.type switch
        BlockType IF_BLOCK . case
          "Waring closing if-blocks is currently not implemented\n" eputs
          end-case
        BlockType &&_BLOCK . BlockType ||_BLOCK . case
          "Waring closing &&-/||-blocks is currently not implemented\n" eputs
          end-case
        BlockType WHILE_BLOCK . case
          "Waring closing while-blocks is currently not implemented\n" eputs
          end-case
        BlockType SWITCH_BLOCK . case
          "Waring closing switch-blocks is currently not implemented\n" eputs
          end-case
        BlockType PROC_BLOCK . case
          "Waring closing proc-blocks is currently not implemented\n" eputs
          end-case
        BlockType ENUM_BLOCK . case
          tokens length block CodeBlock.start > if
            "Invalid token in enum: " tokens block CodeBlock.start [] Token.strAppend ' '
              :<< tokens block CodeBlock.start [] Token.pos FilePosition.strAppend '\n' :<< eputs
            1 exit
          end
          ##TODO save enum
          end-case
        BlockType TUPLE_BLOCK . case
          tokens block CodeBlock.start tokens length [:] Token list subList =:
          ##TODO extract tuple signature
          subList clear
          ##TODO save tuple
          end-case
        end
        end-case
      ## operators
      "+" case
        tokens TokenType OPERATOR . fPos OperatorType PLUS . OperatorToken new :<< tokens =
        end-case
      "-" case
        tokens TokenType OPERATOR . fPos OperatorType MINUS . OperatorToken new :<< tokens =
        end-case
      "-_" case
        tokens TokenType OPERATOR . fPos OperatorType NEGATE . OperatorToken new :<< tokens =
        end-case
      "*" case
        tokens TokenType OPERATOR . fPos OperatorType MULTIPLY . OperatorToken new :<< tokens =
        end-case
      "/" case
        tokens TokenType OPERATOR . fPos OperatorType DIVIDE . OperatorToken new :<< tokens =
        end-case
      "%" case
        tokens TokenType OPERATOR . fPos OperatorType MOD . OperatorToken new :<< tokens =
        end-case

      "!" case
        tokens TokenType OPERATOR . fPos OperatorType NOT . OperatorToken new :<< tokens =
        end-case
      "~" case
        tokens TokenType OPERATOR . fPos OperatorType FLIP . OperatorToken new :<< tokens =
        end-case
      "&" case
        tokens TokenType OPERATOR . fPos OperatorType AND . OperatorToken new :<< tokens =
        end-case
      "|" case
        tokens TokenType OPERATOR . fPos OperatorType OR . OperatorToken new :<< tokens =
        end-case
      "xor" case
        tokens TokenType OPERATOR . fPos OperatorType XOR . OperatorToken new :<< tokens =
        end-case

      "<<" case
        tokens TokenType OPERATOR . fPos OperatorType SHIFT_L . OperatorToken new :<< tokens =
        end-case
      ">>" case
        tokens TokenType OPERATOR . fPos OperatorType SHIFT_R . OperatorToken new :<< tokens =
        end-case

      "<" case
        tokens TokenType OPERATOR . fPos OperatorType LT . OperatorToken new :<< tokens =
        end-case
      "<=" case
        tokens TokenType OPERATOR . fPos OperatorType LE . OperatorToken new :<< tokens =
        end-case
      "==" case
        tokens TokenType OPERATOR . fPos OperatorType EQ . OperatorToken new :<< tokens =
        end-case
      "===" case
        tokens TokenType OPERATOR . fPos OperatorType REF_EQ . OperatorToken new :<< tokens =
        end-case
      "=!=" case
        tokens TokenType OPERATOR . fPos OperatorType REF_NE . OperatorToken new :<< tokens =
        end-case
      "!=" case
        tokens TokenType OPERATOR . fPos OperatorType NE . OperatorToken new :<< tokens =
        end-case
      ">=" case
        tokens TokenType OPERATOR . fPos OperatorType GE . OperatorToken new :<< tokens =
        end-case
      ">" case
        tokens TokenType OPERATOR . fPos OperatorType GT . OperatorToken new :<< tokens =
        end-case
      default
        openBlocks OpenBlocks.blocks length 0 >
          && openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock.type BlockType ENUM_BLOCK . == end
          if
          openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] EnumBlock.elements word fPos NameWithPos new :<< drop
        else
          tokens TokenType WORD . fPos word WordToken new :<< tokens =
        end
      end
    end
  end
end

readEscapeChar proc ParserReader => :
  ParserReader reader =:
  reader ParserReader.nextByte ?? if
  unwrap byte next =:
  next switch
  '\\' '\'' '"' case
   reader ParserReader.word next :<< drop
   end-case
  'n' case
   reader ParserReader.word '\n' :<< drop
   end-case
  't' case
   reader ParserReader.word '\t' :<< drop
   end-case
  'r' case
   reader ParserReader.word '\r' :<< drop
   end-case
  'b' case
   reader ParserReader.word '\b' :<< drop
   end-case
  'f' case
   reader ParserReader.word '\f' :<< drop
   end-case
  '0' case
   reader ParserReader.word '\0' :<< drop
   end-case
  'u' 'U' case
   "\\u is currently unimplemented" eputs
   1 exit
   end-case
  default
   "The escape sequence: '\\" next :<< "' is not supported ":+ reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
   1 exit
  end
  else drop
  "unexpected end of file " reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
  1 exit
  end
end

parseFile proc #_fileName_# string => Token list :
  string fileName =:
  16 Token list new Token list tokens =:

  fileName "r" open ?? ! if
    "file \"" fileName "\" not found\n" :+ :+ eputs
    1 exit
  else
    unwrap
  end
  16 createBufferedIn #_input_#
  fileName 1 1 FilePosition new       #_pos_#
  16 byte list new                    #_word_#
  fileName 1 1 FilePosition new       #_wordPos_#
  ParserReader new ParserReader reader =:
  ParseState STATE_WORD . ParseState state =:
  reader ParserReader.pos "" newMacro 16 CodeBlock list new OpenBlocks new OpenBlocks openBlocks =:

  "" string prevWord =:
  fileName 1 1 FilePosition new FilePosition prevPos =:

  while reader ParserReader.nextByte ?? do
    unwrap #_next-char_#
    state switch
      ParseState STATE_WORD . case
        byte next =:
        next ?WhiteSpace if
          reader ParserReader.word clone string nextWord =:
          nextWord length 0 > if
            prevWord length 0 > if
              prevWord nextWord prevPos openBlocks tokens parseWord
            end
            nextWord prevWord =
            reader ParserReader.wordPos clone prevPos =
          end
          reader ParserReader.nextWord
        else
          next switch
          '"' case
              reader ParserReader.word "u" == if
                ParseState STATE_USTRING . state =
                reader ParserReader.word clear
              else reader ParserReader.word length 0 == _if
                ParseState STATE_STRING . state =
              else
                "illegal string-prefix: \"" reader ParserReader.word :+ "\" " :+
                   reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
                1 exit
              end
            end-case
          '\'' case
              reader ParserReader.word "u" == if
                ParseState STATE_UCHAR . state =
                reader ParserReader.word clear
              else reader ParserReader.word length 0 == _if
                ParseState STATE_CHAR . state =
              else
                "illegal char-prefix: \"" reader ParserReader.word :+ "\" " :+
                   reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
                1 exit
              end
            end-case
          '#' case
              reader ParserReader.nextByte ?? if
                unwrap next =
                next '#' == if
                  reader ParserReader.word clone string nextWord =:
                  nextWord length 0 > if
                    prevWord length 0 > if
                      prevWord nextWord prevPos openBlocks tokens parseWord
                    end
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  end
                  reader ParserReader.nextWord
                  ParseState STATE_LINE_COMMENT . state =
                else next '_' == _if
                  reader ParserReader.word clone string nextWord =:
                  nextWord length 0 > if
                    prevWord length 0 > if
                      prevWord nextWord prevPos openBlocks tokens parseWord
                    end
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  end
                  reader ParserReader.nextWord
                  ParseState STATE_COMMENT . state =
                else
                  reader ParserReader.word '#' :<< next :<< drop
                end
              else drop
                reader ParserReader.word '#' :<< drop
              end
            end-case
          default
            reader ParserReader.word next :<< drop
          end
        end
      end-case
      ParseState STATE_STRING . ParseState STATE_USTRING . case
        byte next =:
        next '"' == if
          prevWord length 0 > if
            prevWord "" prevPos openBlocks tokens parseWord
            "" prevWord =
          end
          tokens
            TokenType VALUE . reader ParserReader.wordPos clone
            state ParseState STATE_USTRING . == if
              reader ParserReader.word codepoints
            else
              reader ParserReader.word clone
            end
          ValueToken new :<< tokens =
          reader ParserReader.nextWord
          ParseState STATE_WORD . state =
        else next '\\' == _if
          reader readEscapeChar
        else
          reader ParserReader.word next :<< drop
        end
      end-case
      ParseState STATE_CHAR . ParseState STATE_UCHAR . case
        byte next =:
        next '\'' == if
          prevWord length 0 > if
            prevWord "" prevPos openBlocks tokens parseWord
            "" prevWord =
          end
          tokens
            TokenType VALUE . reader ParserReader.wordPos clone
            state ParseState STATE_UCHAR . == if
              reader ParserReader.word codepoints
              dup length 1 != if
                reader ParserReader.word " is not a valid unicode character " :+
                reader ParserReader.pos FilePosition.strAppend '\n' :<<
                eputs
                1 exit
              end
            else
              reader ParserReader.word clone
              dup length 1 != if
                #_str_# " is not a valid unicode character " :+
                reader ParserReader.pos FilePosition.strAppend '\n' :<<
                eputs
                1 exit
              end
            end
          #_chars_# 0 [] ValueToken new :<< tokens =
          reader ParserReader.nextWord
          ParseState STATE_WORD . state =
        else next '\\' == _if
          reader readEscapeChar
        else
          reader ParserReader.word next :<< drop
        end
      end-case
      ParseState STATE_COMMENT . case
        #_input-char_# '_' == if
          reader ParserReader.nextByte ?? if
            unwrap '#' == if
              ParseState STATE_WORD . state =
            end
          else
            drop
          end
        end
      end-case
      ParseState STATE_LINE_COMMENT . case
        #_input-char_# '\n' == if
          ParseState STATE_WORD . state =
        end
      end-case
    end
  end drop

  state switch
    ParseState STATE_WORD . case
      reader ParserReader.word clone string nextWord =:
      prevWord length 0 > if
        prevWord nextWord prevPos openBlocks tokens parseWord
        "" prevWord =
      end
      nextWord "" reader ParserReader.wordPos clone openBlocks tokens parseWord
      reader ParserReader.nextWord
      end-case
    ParseState STATE_CHAR . ParseState STATE_UCHAR . case
     "unfinished char-literal " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
    ParseState STATE_STRING . ParseState STATE_USTRING . case
     "unfinished string-literal " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
    ParseState STATE_COMMENT . ParseState STATE_LINE_COMMENT . case
     "unfinished comment " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
  end
  tokens return
end

##addLater parseTokens

main proc string list => :
  string list args =:
  args length 2 < if
    "usage: <pathToFile> \n" puts ## "usage: <pathToFile> (-lib <libPath>)"
    0 exit
  end
  args 1 [] string path =:
  path length 0 > && path 0 [] '.' == end if ##local path
    args 0 [] clone path 1 path length [:] :+ path =
  end
  path parseFile Token list tokens =:

  0 int i =:
  while i tokens length < do
    tokens i [] Token token =:
    "" token Token.strAppend " " :+ token Token.pos FilePosition.strAppend '\n' :<< puts
    i 1 + i =
  end
end
