concat.concat :
## concat compiler written in concat
#+
this file is based on an outdated version of the interpreter
the compiler will be updated once the language is stabilized

the current version of the compiler is kept up to date as an example of a complex concat program
+#

## currently in early development phase

stack   #include
chars   #include
valueIO #include
utf8    #include
core    #import

hashMap #include
hashMap #import

bufferedIO #include
io #import


FilePosition tuple{ string uint uint }
FilePosition.fileName   proc( FilePosition => string ){ .0   }
FilePosition.line       proc( FilePosition => uint   ){ .1   }
FilePosition.line=      proc( uint FilePosition =>   ){ .1 = }
FilePosition.posInLine  proc( FilePosition => uint   ){ .2   }
FilePosition.posInLine= proc( uint FilePosition =>   ){ .2 = }
FilePosition.newLine    proc( FilePosition => ){
  dup dup .1 1 + swap .1 = 1 swap .2 =
}
FilePosition.nextChar   proc( FilePosition => ){
  dup .2 1 + swap .2 =
}
<< proc( string FilePosition => string ){
  FilePosition position =:
  string str =:
  str position FilePosition.fileName <<*
  ':' << position FilePosition.line      <<i
  ':' << position FilePosition.posInLine <<i return
}

NameWithPos tuple{ string FilePosition }
NameWithPos.name proc( NameWithPos => string       ){ .0 }
NameWithPos.pos  proc( NameWithPos => FilePosition ){ .1 }

TypeType enum{ PRIMITIVE_TYPE TUPLE_TYPE ENUM_TYPE WRAPPER_TYPE }
Type tuple{ TypeType }
Type.type proc( Type => TypeType ){ .0 }

PrimitiveType tuple{ TypeType type }
PrimitiveType.wrapped proc( PrimitiveType => type ){ .1 }

TupleType tuple{ TypeType #+name+# string #+types+# Type list }
TupleType.name  proc( TupleType => string    ){ .1 }
TupleType.types proc( TupleType => Type list ){ .2 }
newTupleType proc( #+name+# string #+types+# Type list => TupleType ){
  Type list elements =:
  string name =:
  TypeType .TUPLE_TYPE name elements TupleType new return
}

EnumType tuple{ TypeType #+name+# string #+fields+# NameWithPos list }
EnumType.name   proc( EnumType => string           ){ .1 }
EnumType.fields proc( EnumType => NameWithPos list ){ .2 }
newEnumType proc( #+name+# string #+fields+# NameWithPos list => EnumType ){
  NameWithPos list fields =:
  string name =:
  TypeType .ENUM_TYPE name fields EnumType new return
}

WrapperTypeType enum{ LIST OPTIONAL VAR_ARGS }
WrapperType tuple{ TypeType WrapperTypeType Type }
WrapperType.wrapperType proc( WrapperType => WrapperTypeType ){ .1 }
WrapperType.wrapped     proc( WrapperType => Type            ){ .2 }

<< proc( string Type => string ){
  Type t =:
  t Type.type switch{
  PRIMITIVE_TYPE case
    t PrimitiveType.wrapped stringValue <<* return
    end-case
  WRAPPER_TYPE case
    t WrapperType.wrapped <<
    t WrapperType.wrapperType switch{
    LIST     case " list"     <<* return end-case
    OPTIONAL case " optional" <<* return end-case
    VAR_ARGS case " ..."      <<* return end-case
    }
    end-case
  TUPLE_TYPE case
    t TupleType.name <<* '[' <<
    0 int i =:
    while{ i t TupleType.types .length < do
      i 0 > if{ ", " <<* }
      t TupleType.types i [] <<
      i 1 + i =
    }
    ']' <<
    end-case
  ENUM_TYPE case
    t EnumType.name <<* '[' <<
    0 int i =:
    while{ i t EnumType.fields .length < do
      i 0 > if{ ", " <<* }
      t EnumType.fields i [] NameWithPos.name <<*
      i 1 + i =
    }
    ']' <<
    end-case
  }
}

TypeType .PRIMITIVE_TYPE      bool PrimitiveType new Type Type.BOOL      =$
TypeType .PRIMITIVE_TYPE      byte PrimitiveType new Type Type.BYTE      =$
TypeType .PRIMITIVE_TYPE codepoint PrimitiveType new Type Type.CODEPOINT =$
TypeType .PRIMITIVE_TYPE      uint PrimitiveType new Type Type.UINT      =$
TypeType .PRIMITIVE_TYPE       int PrimitiveType new Type Type.INT       =$
TypeType .PRIMITIVE_TYPE     float PrimitiveType new Type Type.FLOAT     =$
TypeType .PRIMITIVE_TYPE      type PrimitiveType new Type Type.TYPE      =$
TypeType .PRIMITIVE_TYPE       var PrimitiveType new Type Type.VAR       =$

TypeType .WRAPPER_TYPE WrapperTypeType .LIST Type.BYTE      WrapperType new Type Type.STRING  =$
TypeType .WRAPPER_TYPE WrapperTypeType .LIST Type.CODEPOINT WrapperType new Type Type.USTRING =$

Value tuple{ Type var }
Value.type proc( Value => Type ){ .0 }
Value.data proc( Value => var  ){ .1 }

<< proc( string Value => string ){
  Value v =:
  v Value.type << ": " <<*
  v Value.type Type.type switch{
  PRIMITIVE_TYPE case
    v Value.type Type.TYPE == if{
      v Value.data Type cast << return
    else
      v Value.data stringValue <<* return
    }
    end-case
  ENUM_TYPE case
   '[' << v Value.data EnumEntry.index stringValue <<* ']' << return
   end-case
  TUPLE_TYPE case
    "tuple-type unimplemented\n" eputs 1 exit
  end-case
  WRAPPER_TYPE case
    v Value.type Type.STRING == ||{ v Value.type Type.USTRING == } if{
      v Value.data stringValue <<* return
    else
      "wrapper-type unimplemented\n" eputs 1 exit
    }
  end-case
  }
}

Type.BOOL true  Value new Value Value.TRUE  =$
Type.BOOL false Value new Value Value.FALSE =$
Value.ofByte      proc( byte       => Value ){ Type.BYTE      swap Value new return }
Value.ofCodepoint proc( codepoint  => Value ){ Type.CODEPOINT swap Value new return }
Value.ofInt       proc( int        => Value ){ Type.INT       swap Value new return }
Value.ofUInt      proc( uint       => Value ){ Type.UINT      swap Value new return }
Value.ofFloat     proc( float      => Value ){ Type.FLOAT     swap Value new return }
Value.ofType      proc( Type       => Value ){ Type.TYPE      swap Value new return }
Value.ofString    proc( string     => Value ){ Type.STRING    swap Value new return }
Value.ofUString   proc( ustring    => Value ){ Type.USTRING   swap Value new return }

BlockType enum{
  IF_BLOCK
  WHILE_BLOCK
  SWITCH_BLOCK
  PROC_BLOCK
  ENUM_BLOCK
  TUPLE_BLOCK
}
CodeBlock tuple{ #+type+# BlockType #+startPos+# FilePosition #+start+# int }
CodeBlock.type     proc( CodeBlock => BlockType    ){ .0 }
CodeBlock.startPos proc( CodeBlock => FilePosition ){ .1 }
CodeBlock.start    proc( CodeBlock => int          ){ .2 }

WhileBlock tuple{ #+type+# BlockType #+startPos+# FilePosition #+start+# int #+forkPos+# int }
WhileBlock.forkPos  proc( WhileBlock => int ){ .3   }
WhileBlock.forkPos= proc( int WhileBlock => ){ .3 = }
newWhileBlock proc( #+startPos+# FilePosition #+start+# int => WhileBlock ){
  int start =:
  FilePosition startPos =:
  BlockType .WHILE_BLOCK startPos start -1 WhileBlock new return
}

IfBlock tuple{  #+type+# BlockType #+startPos+# FilePosition #+start+# int #+prev_if+# int #+else_positions+# uint list }
IfBlock.prevIf         proc( IfBlock => int       ){ .3   }
IfBlock.prevIf=        proc( int IfBlock =>       ){ .3 = }
IfBlock.else_positions proc( IfBlock => uint list ){ .4   }
newIfBlock proc( #+startPos+# FilePosition #+start+# int => IfBlock ){
  int start =:
  FilePosition startPos =:
  BlockType .IF_BLOCK startPos start start 16 int list new IfBlock new return
}

EnumBlock tuple{ #+type+# BlockType #+startPos+# FilePosition #+start+# int
  #+name+# string #+elements+# NameWithPos list }
EnumBlock.name     proc( EnumBlock => string           ){ .3 }
EnumBlock.elements proc( EnumBlock => NameWithPos list ){ .4 }
newEnumBlock proc( #+name+# string #+startPos+# FilePosition #+start+# int => EnumBlock ){
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType .ENUM_BLOCK startPos start name 16 NameWithPos list new EnumBlock new return
}
TupleBlock tuple{ #+type+# BlockType #+startPos+# FilePosition #+start+# int #+name+# string }
TupleBlock.name proc( TupleBlock => string ){ .3 }
newTupleBlock proc( #+name+# string #+startPos+# FilePosition #+start+# int => TupleBlock ){
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType .TUPLE_BLOCK startPos start name TupleBlock new return
}



DeclareableType enum{
  MACRO
  ENUM
  ENUM_ENTRY
  TUPLE
  VARIABLE_ID
  FINAL_VARIABLE
  PREDECLARED_PROCEDURE
  PROCEDURE
}
<<DeclareableType proc( #+str+# string #+a+# bool #+type+# DeclareableType => string ){
   #+type+# switch{
   MACRO case
     #+a+# if{ "a macro" else "macro" } <<* return
     end-case
   ENUM case
     #+a+# if{ "an enum" else "enum" } <<* return
     end-case
   ENUM_ENTRY case
     #+a+# if{ "an enum entry" else "enum entry" } <<* return
     end-case
   TUPLE case
     #+a+# if{ "a tuple" else "tuple" } <<* return
     end-case
   VARIABLE_ID case
     #+a+# if{ "a variable" else "variable" } <<* return
     end-case
   FINAL_VARIABLE case
     #+a+# if{ "a final variable" else "final variable" } <<* return
     end-case
   PREDECLARED_PROCEDURE case
     #+a+# if{ "a predeclared procedure" else "predeclared procedure" } <<* return
     end-case
   PROCEDURE case
     #+a+# if{ "a procedure" else "procedure" } <<* return
     end-case
   }
}

Declareable tuple{ #+type+# DeclareableType #+pos+# FilePosition }
Declareable.type proc( Declareable => DeclareableType ){ .0   }
Declareable.pos  proc( Declareable => FilePosition    ){ .1   }
Declareable.pos= proc( FilePosition Declareable =>    ){ .1 = }

ContextType enum{ ROOT_CONTEXT PROC_CONTEXT BLOCK_CONTEXT }

Context tuple{ #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType }
Context.elements    proc( Context => string Declareable HashMap ){ .0 }
Context.varCount    proc( Context => int                        ){ .1 }
Context.type        proc( Context => ContextType                ){ .2 }
Context.incVarCount proc( Context => ){ dup .1 1 + swap .1 = }

Macro tuple{ #+type+# DeclareableType #+pos+# FilePosition #+name+# string #+words+# NameWithPos list }
Macro.name  proc( Macro => string           ){ .2   }
Macro.name= proc( string Macro  =>          ){ .2 = }
Macro.words proc( Macro => NameWithPos list ){ .3   }
newMacro proc( FilePosition string => Macro ){
  string name =:
  FilePosition mPos =:
  DeclareableType .MACRO mPos name 16 NameWithPos list new Macro new return
}

VariableId tuple{ #+type+# DeclareableType #+pos+# FilePosition #+global+# bool #+level+# int #+varId+# int }
VariableId.global  proc( VariableId => bool ){ .2 }
VariableId.level   proc( VariableId => int  ){ .3 }
VariableId.varId   proc( VariableId => int  ){ .4 }
VariableId.isConst proc( VariableId => bool ){
  Declareable.type DeclareableType .FINAL_VARIABLE ==
}

CurriedVariable tuple{ #+type+# DeclareableType #+pos+# FilePosition } ##TODO curried variable
PredeclaredProc tuple{ #+type+# DeclareableType #+pos+# FilePosition } ##TODO predeclared proc
Procedure tuple{ #+type+# DeclareableType #+pos+# FilePosition } ##TODO proc

Enum tuple{ #+type+# DeclareableType #+pos+# FilePosition #+enum-type+# EnumType }
Enum.enumType proc( Enum => EnumType ){ .2 }
newEnum proc( #+pos+# FilePosition #+name+# string #+fields+# NameWithPos list => Enum ){
  #+fields+# #+name+# newEnumType EnumType enumType =:
  FilePosition fPos =:
  DeclareableType .ENUM fPos enumType Enum new return
}
EnumEntry tuple{ #+type+# DeclareableType #+pos+# FilePosition #+enum-type+# EnumType #+index+# int }
EnumEntry.enumType proc( EnumEntry => EnumType ){ .2 }
EnumEntry.index proc( EnumEntry => int ){ .3 }
newEnumEntry proc( #+enumType+# EnumType #+index+# int => EnumEntry ){
  int index =:
  EnumType enumType =:
  DeclareableType .ENUM_ENTRY enumType EnumType.fields index [] NameWithPos.pos enumType index EnumEntry new return
}

Tuple tuple{ #+type+# DeclareableType #+pos+# FilePosition #+tupleType+# TupleType }
Tuple.tupleType proc( Tuple => TupleType ){ .2 }

<< proc( string VariableId => string ){
  Declareable d =:
  d VariableId.global if{ "global:" else "local:" } <<*
  d VariableId.level <<u ':' <<
  d VariableId.varId <<u
  return
}
<< proc( string Declareable => string ){
  Declareable d =:
  false d Declareable.type <<DeclareableType ": " <<*
  d Declareable.type switch{
  MACRO case
    d Macro.name <<*
    end-case
  ENUM case
    d Enum.enumType <<
    end-case
  ENUM_ENTRY case
    d EnumEntry.enumType EnumType.name <<* '[' <<
    d EnumEntry.index stringValue <<*
    ']' <<
    end-case
  TUPLE case
    d Tuple.tupleType <<
    end-case
  FINAL_VARIABLE VARIABLE_ID case
    d VariableId cast <<
    end-case
  PREDECLARED_PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  }
  " at " <<* d Declareable.pos << return
}

OpenModule tuple{ #+path+# string list #+declaredAt+# FilePosition #+imports+# string list
  #+predeclared+# string PredeclaredProc HashMap }
OpenModule.path        proc( OpenModule => string list                    ){ .0 }
OpenModule.declaredAt  proc( OpenModule => FilePosition                   ){ .1 }
OpenModule.imports     proc( OpenModule => string list                    ){ .2 }
OpenModule.predeclared proc( OpenModule => string PredeclaredProc HashMap ){ .3 }
newOpenModule proc( #+path+# string list #+declaredAt+# FilePosition => OpenModule ){
  16 string list new 16 string PredeclaredProc newHashMap OpenModule new return
}
<< proc( string OpenModule => string ){
  OpenModule m =:
  string str =:
  0 int i =:
  str while{ i m OpenModule.path .length < do
     m OpenModule.path i [] <<* "'" <<*
  }
  " declared at " <<* m OpenModule.declaredAt << return
}

OpenFile tuple{ #+global imports +# string list #+global predeclared+# string PredeclaredProc HashMap
    #+openModules+# OpenModule list }
OpenFile.globalImports     proc( OpenFile => string list                    ){ .0 }
OpenFile.globalPredeclared proc( OpenFile => string PredeclaredProc HashMap ){ .1 }
OpenFile.openModules       proc( OpenFile => OpenModule list                ){ .2 }

newOpenFile proc( => OpenFile ){
  16 string list new
  16 string PredeclaredProc newHashMap
  16 OpenModule list new
  OpenFile new return
}

RootContext tuple{ #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType
    #+openFiles+# OpenFile list #+namespaces+# string bool HashMap }
RootContext.openFiles  proc( RootContext => OpenFile list       ){ .3 }
RootContext.namespaces proc( RootContext => string bool HashMap ){ .4 }
newRootContext proc( => RootContext ){
  16 string Declareable newHashMap
  0
  ContextType .ROOT_CONTEXT
  16 OpenFile list new
  16 string bool newHashMap
  RootContext new return
}

BlockContext tuple{ #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType #+parent+# Context }
BlockContext.parent proc( BlockContext => Context ){ .3 }
newBlockContext proc( #+parent+# Context => BlockContext ){
  Context parent =:
  16 string Declareable newHashMap 0 ContextType .BLOCK_CONTEXT parent BlockContext new return
}

ProcContext tuple{ #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType #+parent+# Context
   #+curried+# CurriedVariable list }
ProcContext.curried proc( ProcContext => CurriedVariable list ){ .4 }

Context.isGlobal proc( Context => bool ){
  Context context =:
  context Context.type switch{
  ROOT_CONTEXT case
    true return
    end-case
  PROC_CONTEXT case
    false return
    end-case
  BLOCK_CONTEXT case
    context BlockContext.parent Context.isGlobal return
    end-case
  }
}
Context.procContext proc( Context => ProcContext optional ){
  Context context =:
  context Context.type switch{
  ROOT_CONTEXT case
    ProcContext empty return
    end-case
  PROC_CONTEXT case
    context ProcContext cast wrap return
    end-case
  BLOCK_CONTEXT case
    context BlockContext.parent Context.procContext return
    end-case
  }
}
Context.level proc( Context => int ){
  Context context =:
  context Context.type switch{
  ROOT_CONTEXT PROC_CONTEXT case
    0 return
    end-case
  BLOCK_CONTEXT case
    context BlockContext.parent Context.level 1 + return
    end-case
  }
}
Context.ensureDeclareable proc( #+context+# Context #+name+#string #+type+# DeclareableType #+pos+# FilePosition
  => #+localName+# string ){
  FilePosition fPos =:
  DeclareableType dType =:
  string name =:
  Context context =:
  context Context.type ContextType .ROOT_CONTEXT == if{ context name RootContext.inCurrentModule else name }  string localName =:
  context Context.elements localName HashMap.get if{
    Declareable prev =:
    ## procedures can overwrite predeclared procedures
    prev Declareable.type DeclareableType .PREDECLARED_PROCEDURE != ||{ prev Declareable.type DeclareableType .PROCEDURE != } if{
      "cannot declare " false dType <<DeclareableType ' ' << name <<*
      ", the identifier is already used by " <<* true prev Declareable.type <<DeclareableType
      " (declared at " prev Declareable.pos << ") at " <<* fPos << '\n' << eputs
      1 exit
    }
  }
  context name Context.getDeclareable if{
    Declareable shadowed =:
    "Warning: " false dType <<DeclareableType " " <<* name <<*
     " declared at " <<* fPos << "\n     shadows existing " <<*
     false shadowed Declareable.type <<DeclareableType " declared at " <<*
     shadowed Declareable.pos << '\n' << eputs
  }
  localName return
}
Context.declareVariable proc( #+context+# Context #+name+# string #+isConst+# bool #+pos+# FilePosition => VariableId ){
    FilePosition fPos =:
    bool isConst =:
    string name =:
    Context context =:
    isConst if{ DeclareableType .FINAL_VARIABLE else DeclareableType .VARIABLE_ID } DeclareableType dType =:
    context name dType fPos Context.ensureDeclareable name =
    dType fPos context Context.isGlobal context Context.level context Context.varCount VariableId new VariableId varId =:
    context Context.incVarCount
    context Context.elements name varId HashMap.put drop
    varId return
}
Context.getDeclareable proc( #+context+# Context #+name+# string => Declareable optional ){
    string name =:
    Context context =:
    context Context.type switch{
    ROOT_CONTEXT case
      context RootContext.currentPaths string list paths =:
      paths .length 1 - int i =:
      while{ i 0 >= do ##go through all namespaces
        context Context.elements paths i [] clone name <<* HashMap.get dup .hasValue if{
          #+element+# Declareable optional cast return
        else drop }
        i 1 - i =
      }
      context Context.elements name HashMap.get return
      end-case
    PROC_CONTEXT BLOCK_CONTEXT case
      context Context.elements name HashMap.get dup .hasValue if{
        #+element+# Declareable optional cast return
      else drop
        context BlockContext.parent name Context.getDeclareable return
      }
      end-case
    }
}
MODULE_SEPARATOR #define '\'' #end
##token that signals the compiler, that there will be no more statements in the current code-section
END_OF_SECTION #define "##" #end
RootContext.startFile proc( RootContext => ){
  RootContext.openFiles newOpenFile << drop
}
RootContext.file proc( RootContext => OpenFile ){
  RootContext context =:
  context RootContext.openFiles context RootContext.openFiles .length 1 - [] return
}

RootContext.inCurrentModule proc( RootContext  #+name+# string => string ){
   string name =:
   #+context+# RootContext.file OpenFile.openModules OpenModule list namespaces =:
   namespaces .length 0 > if{
    "" string path =:
     0 int i =:
     while{ i namespaces .length < do
        namespaces i [] OpenModule.path string list paths =:
        0 int j =:
        while{ j paths .length < do
          path paths j [] <<* MODULE_SEPARATOR << path =
          j 1 + j =
        }
        i 1 + i =
     }
     path name <<* return
   }
   name return
}
RootContext.startModule proc( RootContext #+name+# string #+declaredAt+# FilePosition => ){
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context Context.elements context name RootContext.inCurrentModule HashMap.get if{
    Declareable d =:
    "cannot declare namespace " name <<* ", the identifier is already used by " <<*
    true d Declareable.type <<DeclareableType
    " (declared at " <<* d Declareable.pos << ")\n at " <<*
    fPos  << '\n' << eputs
    1 exit
  }
  context "" RootContext.inCurrentModule string fullPath =:
  16 string list new string list path =:
  "" string tmp =:
  0 int i =:
  while{ i name .length < do
    fullPath name i [] << fullPath =
    name i [] MODULE_SEPARATOR == if{
      context RootContext.namespaces fullPath clone true HashMap.put drop
      path tmp << path =
      "" tmp =
    else
      tmp name i [] << tmp =
    }
    i 1 + i =
  }
  path tmp << path =
  fullPath MODULE_SEPARATOR << fullPath =
  context RootContext.namespaces fullPath clone true HashMap.put drop
  context RootContext.file OpenFile.openModules path fPos newOpenModule << drop
}
RootContext.addImport proc( RootContext #+name+# string #+declaredAt+# FilePosition => ){
  FilePosition fPos =:
  string name0 =:
  name0 clone '\'' << string name =:
  RootContext context =:
  context RootContext.namespaces name HashMap.contains if{
     context RootContext.file OpenFile file =:
     file OpenFile.openModules .length 0 > if{
         file OpenFile.openModules file OpenFile.openModules .length 1 - [] OpenModule.imports name << drop
     else
         file OpenFile.globalImports name << drop
     }
  else context Context.elements name HashMap.get if
    ##addLater static imports
    drop
    "static imports are currently unimplemented"
    1 exit
  else
    context RootContext.namespaces
    "namespace " name0 <<* " does not exist " <<* fPos << '\n' << eputs
    1 exit
  }
}
RootContext.endModule proc( RootContext FilePosition => ){
  FilePosition fPos =:
  RootContext context =:
  context RootContext.file OpenFile file =:
  file OpenFile.openModules .length 0 == if{
    "Unexpected End of namespace " fPos << '\n' << eputs
    1 exit
  }
  file OpenFile.openModules file OpenFile.openModules .length 1 - [] OpenModule removed =:
  file OpenFile.openModules file OpenFile.openModules .length 1 - file OpenFile.openModules .length [:] clear
  removed OpenModule.predeclared HashMap.size 0 > if{
    "Syntax Error: missing variables/procedures" string message =:
    removed OpenModule.predeclared HashMap.itr while{ HashMapItr.next do
       string PredeclaredProc MapEntry e =:
       message "\n- " <<* e MapEntry.key string cast <<* " (at " <<* e MapEntry.value Declareable.pos << ')' << drop
    } drop
    message fPos << '\n' << eputs
    1 exit
  }
}
RootContext.endFile proc( RootContext FilePosition => ){
  FilePosition fPos =:
  RootContext context =:
  context RootContext.openFiles context RootContext.openFiles .length 1 - [] OpenFile closed =:
  context RootContext.openFiles context RootContext.openFiles .length 1 - context RootContext.openFiles .length [:] clear
  closed OpenFile.openModules .length 0 > if{
    "unclosed namespaces at end of File:\n" eputs
    closed OpenFile.openModules .length 1 - int i =:
    while{ i 0 >= do
      closed OpenFile.openModules i [] OpenModule removed =:
      removed OpenModule.predeclared HashMap.size 0 > if{
        "Syntax Error: missing variables/procedures" string message =:
        removed OpenModule.predeclared HashMap.itr while{ HashMapItr.next do
           string PredeclaredProc MapEntry e =:
           message "\n- " <<* e MapEntry.key string cast <<* " (at " <<* e MapEntry.value Declareable.pos << ')' << drop
        } drop
        message fPos << '\n' << eputs
        1 exit
      }
      " - " removed << '\n' << eputs
      i 1 - i =
    }
    closed OpenFile.openModules clear
  }
  closed OpenFile.globalPredeclared HashMap.size 0 > if{
    "Syntax Error: missing variables/procedures" string message =:
    closed OpenFile.globalPredeclared HashMap.itr while{ HashMapItr.next do
       string PredeclaredProc MapEntry e =:
       message "\n- " <<* e MapEntry.key string cast <<* " (at " <<* e MapEntry.value Declareable.pos << ')' << drop
    } drop
    message fPos << '\n' << eputs
    1 exit
  }
}

RootContext.currentPaths proc( RootContext => string list ){
  #+context+# RootContext.file OpenFile file =:
  file OpenFile.globalImports clone string list paths =:
  16 string new string path =:
  file OpenFile.openModules OpenModule list namespaces =:
  0 int i =:
  while{ i namespaces .length < do
    namespaces i [] OpenModule.path string list mPath =:
    0 int j =:
    while{ j mPath .length < do
      path mPath j [] <<* MODULE_SEPARATOR << path =
      j 1 + j =
      paths path clone << paths =
    }
    namespaces i [] OpenModule.imports  paths paths .length 1 - paths .length 1 - [:]=
    i 1 + i =
  }
  paths return
}
RootContext.predeclared proc( RootContext => string Declareable HashMap ){
  #+context+# RootContext.file OpenFile file =:
  file OpenFile.openModules .length 0 > if{
    file OpenFile.openModules file OpenFile.openModules .length 1 - [] OpenModule.predeclared return
  else
    file OpenFile.globalPredeclared return
  }
}

RootContext.declareProcedure proc( #+context+# RootContext #+name+# string #+proc+# Procedure => ){
  Procedure aProc =:
  string name =:
  RootContext context =:
  context name DeclareableType .PROCEDURE aProc Declareable.pos Context.ensureDeclareable name =
  context RootContext.predeclared name HashMap.remove if{
    ##TODO handle predeclared procedure
    drop
  }
  context Context.elements name aProc HashMap.put drop
}
##addLater predeclareProcedure

RootContext.declareMacro proc( #+context+# RootContext #+macro+# Macro => ){
  Macro macro =:
  macro Macro.name string name =:
  RootContext context =:
  context name DeclareableType .MACRO macro Declareable.pos Context.ensureDeclareable name =
  context Context.elements name macro HashMap.put drop
}
RootContext.removeMacro proc( #+context+# RootContext #+name+# string #+pos+# FilePosition => ){
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context Context.elements context name RootContext.inCurrentModule HashMap.remove if{
    Declareable removed =:
    removed Declareable.type DeclareableType .MACRO != if{
      "macro " name <<* " does not exists, or is shadowed by " <<*
      false removed Declareable.type <<DeclareableType
      " (declared at " <<* removed Declareable.pos << ") "
      fPos << '\n' << eputs
      1 exit
    }
  else
    "macro " name <<* " does not exists in the current namespace " <<* fPos << '\n' << eputs
    1 exit
  }
}
RootContext.declareEnum proc( #+context+# RootContext #+source+# EnumBlock => ){
  EnumBlock source =:
  source EnumBlock.name string name =:
  RootContext context =:
  source CodeBlock.startPos name source EnumBlock.elements newEnum Enum anEnum =:
  context name DeclareableType .ENUM anEnum Declareable.pos Context.ensureDeclareable name =
  context Context.elements name anEnum HashMap.put drop
  ##declare enum entries
  0 int i =:
  anEnum Enum.enumType EnumType.fields NameWithPos list fields =:
  while{ i fields .length < do
    source EnumBlock.name clone MODULE_SEPARATOR << fields i [] NameWithPos.name <<* string fieldName =:
    context fieldName DeclareableType .ENUM_ENTRY fields i [] NameWithPos.pos Context.ensureDeclareable fieldName =
    context Context.elements fieldName anEnum Enum.enumType i newEnumEntry HashMap.put drop
    i 1 + i =
  }
}
RootContext.declareTuple proc( #+context+# RootContext #+tuple+# Tuple => ){
  Tuple aTuple =:
  aTuple Tuple.tupleType TupleType.name string name =:
  RootContext context =:
  context name DeclareableType .TUPLE aTuple Declareable.pos Context.ensureDeclareable name =
  context Context.elements name aTuple HashMap.put drop
}
##TODO RootContext.declareNativeProc
##TODO Context.wrapCurried


TokenType enum{
  WORD
  KEY_WORD
  PROCEDURE_START
  ENUM_START
  VALUE
  IDENTIFIER
  VARIABLE
  OPERATOR
  BLOCK_TOKEN
  CONTEXT_OPEN
  CONTEXT_CLOSE
}
Token tuple{ TokenType FilePosition }
Token.type  proc( Token => TokenType    ){ .0 }
Token.pos   proc( Token => FilePosition ){ .1 }

WordToken tuple{ TokenType FilePosition string }
WordToken.value proc( WordToken => string ){ .2 }

ValueToken tuple{ TokenType FilePosition Value }
ValueToken.value proc( ValueToken => Value ){ .2 }

BlockTokenType enum{ IF ELSE _IF END-IF WHILE DO END-WHILE DO-WHILE SWITCH CASE END-CASE DEFAULT END-SWITCH }
BlockToken tuple{ TokenType FilePosition BlockTokenType int }
BlockToken.type    proc( BlockToken => BlockTokenType ){ .2   }
BlockToken.target  proc( BlockToken => int            ){ .3   }
BlockToken.target= proc( int BlockToken =>            ){ .3 = }

ContextToken tuple{ TokenType FilePosition Context }
ContextToken.varCount proc( ContextToken => int ){ .2 Context.varCount }

IdentifierType enum{
  WRITE
  DECLARE
  CONST_DECLARE
  ADDRESS_OF
}
IdentifierToken tuple{ TokenType FilePosition IdentifierType string }
IdentifierToken.idType proc( IdentifierToken => IdentifierType ){ .2 }
IdentifierToken.value  proc( IdentifierToken => string         ){ .3 }

OperatorType enum{
  PLUS MINUS NEGATE INVERT MULTIPLY DIVIDE MOD
  NOT FLIP AND OR XOR  SHIFT_L SHIFT_R
  LT LE EQ REF_EQ REF_NE NE GE GT
}
OperatorToken tuple{ TokenType FilePosition OperatorType }
OperatorToken.opType proc( OperatorToken => OperatorType ){ .2 }

AccessType enum{
  DECLARE_CONST DECLARE_VAR WRITE_VAR READ_VAR
}
VariableToken tuple{ TokenType FilePosition AccessType VariableId }
VariableToken.accessType proc( VariableToken => AccessType ){ .2 }
VariableToken.id         proc( VariableToken => VariableId ){ .3 }


<< proc( string Token => string ){
  Token token =:

  TokenType .fieldNames token Token.type [] *>> ": " *>>
  token Token.type switch{
  WORD KEY_WORD PROCEDURE_START ENUM_START case
    token WordToken.value <<*
    end-case
  VALUE case
    token ValueToken.value <<
    end-case
  BLOCK_TOKEN case
    BlockTokenType .fieldNames token BlockToken.type [] <<* '(' << token BlockToken.target stringValue <<* ')' <<
    end-case
  IDENTIFIER case
    IdentifierType .fieldNames token IdentifierToken.idType [] <<* ": " <<* token IdentifierToken.value <<*
    end-case
  OPERATOR case
    OperatorType .fieldNames token OperatorToken.opType [] <<*
    end-case
  VARIABLE case
    AccessType .fieldNames token VariableToken.accessType [] <<* " " <<*
    token VariableToken.id << " " <<*
    end-case
  CONTEXT_CLOSE case end-case
  CONTEXT_OPEN case
    token ContextToken.varCount stringValue <<*
    end-case
  }
}

ParserReader tuple{ BufferedInput FilePosition string FilePosition }
ParserReader.in       proc( ParserReader => BufferedInput ){ .0 }
ParserReader.pos      proc( ParserReader => FilePosition  ){ .1 }
ParserReader.word     proc( ParserReader => string        ){ .2 }
ParserReader.wordPos  proc( ParserReader => FilePosition  ){ .3 }
ParserReader.nextWord proc( ParserReader => ){
  ParserReader reader =:
  reader ParserReader.word clear
  reader ParserReader.pos FilePosition.line       reader ParserReader.wordPos FilePosition.line=
  reader ParserReader.pos FilePosition.posInLine  reader ParserReader.wordPos FilePosition.posInLine=
}
ParserReader.nextByte proc( ParserReader => byte optional ){
  ParserReader reader =:
  reader ParserReader.in BufferedInput.nextByte byte optional next =:
  next if{
    '\n' == if{
      reader ParserReader.pos FilePosition.newLine
    else
      reader ParserReader.pos FilePosition.nextChar
    }
  }
  next return
}

ParseState enum{
  STATE_WORD
  STATE_STRING
  STATE_USTRING
  STATE_CHAR
  STATE_UCHAR
  STATE_COMMENT
  STATE_LINE_COMMENT
}

OpenBlocks tuple{ Macro CodeBlock list }
OpenBlocks.currentMacro  proc( OpenBlocks => Macro          ){ .0   }
OpenBlocks.currentMacro= proc( Macro OpenBlocks =>          ){ .0 = }
OpenBlocks.blocks        proc( OpenBlocks => CodeBlock list ){ .1   }

Program tuple{ #+tokens+# Token list #+root-context+# Context }
Program.tokens   proc( Program => Token list ){ .0   }
Program.context  proc( Program => Context    ){ .1   }
Program.context= proc( Context Program  =>   ){ .1 = }


parseWord proc( #+word+# string #+next+# string #+pos+# FilePosition #+open_blocks+# OpenBlocks
  #+program+# Program => ){
  Program program =:
  program Program.context Context context =:
  program Program.tokens Token list tokens =:
  OpenBlocks openBlocks =:
  FilePosition fPos =:
  string       next =:
  string       word =:
  word .length 0 > if{
    openBlocks OpenBlocks.currentMacro Macro.name .length 0 > if{
      word switch{
      "#end" case
        context openBlocks OpenBlocks.currentMacro RootContext.declareMacro
        fPos "" newMacro  openBlocks OpenBlocks.currentMacro=
        end-case
      "#define" "#undef" "#namespace" "#include" "#import" "proc" "procedure" "enum" "tuple" case
        word " is not allowed in macros " <<* fPos << '\n' << eputs
        1 exit
        end-case
      default
        openBlocks OpenBlocks.currentMacro Macro.words word fPos NameWithPos new << drop
      }
      return
    }
    ##keywords that consume one or more words
    word switch{
    ## identifier - modifiers
    "."  case
      tokens .length 2 < if{
        "not enough arguments for . " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 2 - [] Token prePrev =:
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for '.' modifier: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      prePrev Token.type TokenType .WORD != if{
        "invalid token for '.' modifier: " prePrev << ' ' << prePrev Token.pos << '\n' << eputs
        1 exit
      }
      TokenType .WORD fPos prePrev WordToken.value '\'' << prev WordToken.value <<* WordToken new  tokens tokens .length 2 - []=
      tokens tokens .length 1 - tokens .length [:] clear
      end-case
    "="  case
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for '=' modifier: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .WRITE prev WordToken.value IdentifierToken new  tokens tokens .length 1 - []=
      end-case
    "=:" case
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for '=:' modifier: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .DECLARE prev WordToken.value IdentifierToken new  tokens tokens .length 1 - []=
      end-case
    "=$" case
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for '=$' modifier: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .CONST_DECLARE prev WordToken.value IdentifierToken new
        tokens tokens .length 1 - []=
      end-case
    "@()" case
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for '@()' modifier: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .ADDRESS_OF prev WordToken.value IdentifierToken new
        tokens tokens .length 1 - []=
      end-case
    ## macro&namespace key-words
    "#define" case
      tokens .length 0 == if{
        "missing macro name " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for macro name: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      prev WordToken.value  openBlocks OpenBlocks.currentMacro Macro.name=
      prev Token.pos        openBlocks OpenBlocks.currentMacro Declareable.pos=
      end-case
    "#undef" case
      openBlocks OpenBlocks.blocks .length 0 > if{
        "macros can only be undefined at root-level " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token preceding #undef: " prev << ' ' << prev Token.pos <<
        " expected macro-name \n" <<* eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken.value fPos RootContext.removeMacro
      end-case
    "#namespace" case
      openBlocks OpenBlocks.blocks .length 0 > if{
        "namespaces can only be declared at root-level " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for namespace name: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken.value fPos RootContext.startModule
      end-case
    "#end" case
      openBlocks OpenBlocks.blocks .length 0 > if{
        "namespaces can only be closed at root-level " fPos << '\n' << eputs
        1 exit
      }
      END_OF_SECTION "" fPos openBlocks program parseWord
      context fPos RootContext.endModule
      end-case
    "#import" case
      openBlocks OpenBlocks.blocks .length 0 > if{
        "imports  are can only allowed at root-level " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "imported namespace name has to be an identifier, got "
           prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken.value fPos RootContext.addImport
      end-case
    "#include" case
      "unimplemented\n" eputs
      1 exit
      end-case
    ## proc/enum key-words
    "proc" "procedure" case
      tokens .length 0 == if{
        "missing procedure name " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for procedure name: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      TokenType .PROCEDURE_START fPos prev WordToken.value WordToken new  tokens tokens .length 1 - []=
      openBlocks OpenBlocks.blocks BlockType .PROC_BLOCK fPos tokens .length CodeBlock new << drop
      end-case
    "enum" case
      tokens .length 0 == if{
        "missing enum name " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for enum name: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      openBlocks OpenBlocks.blocks prev WordToken.value fPos tokens .length newEnumBlock << drop
      end-case
    "tuple" case
      tokens .length 0 == if{
        "missing tuple name " fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev Token.type TokenType .WORD != if{
        "invalid token for tuple name: " prev << ' ' << prev Token.pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      openBlocks OpenBlocks.blocks prev WordToken.value fPos tokens .length newTupleBlock << drop
      end-case
    default
      tokens .length 0 > &&{ next "." != } if{
        tokens tokens .length 1 - [] Token prev =:
        prev Token.type TokenType .IDENTIFIER == if{
          prev IdentifierToken.idType switch{
          DECLARE CONST_DECLARE case
            context
            prev IdentifierToken.value
            prev IdentifierToken.idType IdentifierType .DECLARE !=
            prev Token.pos
            Context.declareVariable VariableId id =:
            prev IdentifierToken.idType IdentifierType .DECLARE != if{
              AccessType .DECLARE_VAR else AccessType .DECLARE_CONST } AccessType aType =:
            TokenType .VARIABLE prev Token.pos aType id VariableToken new
              tokens tokens .length 1 - []=
            end-case
          WRITE case
            context prev IdentifierToken.value Context.getDeclareable if{
              Declareable d =:
              d Declareable.type DeclareableType .VARIABLE_ID != if{
                "" false d Declareable.type <<DeclareableType " " <<* prev IdentifierToken.value <<*
                " (declared at " <<* d Declareable.pos << ") is not a variable" <<*
                fPos << '\n' << eputs
                1 exit
              }
              ##TODO check for curried variables
              ##context.wrapCurried(identifier.name,id,identifier.pos);
              TokenType .VARIABLE prev Token.pos AccessType .WRITE_VAR d VariableToken new
                tokens tokens .length 1 - []=
            else
              "variable " prev IdentifierToken.value <<* " does not exist " <<* fPos << '\n' << eputs
              1 exit
            }
            end-case
          ADDRESS_OF case
            ##TODO address of
            "unimplemented\n" eputs
            1 exit
            end-case
          }
        else  prev Token.type TokenType .WORD == if
          context prev WordToken.value Context.getDeclareable if{
            Declareable d =:
            d Declareable.type switch{
            MACRO case
              tokens tokens .length 1 - tokens .length [:] clear ##remove prev
              0 int i =:
              while{ i d Macro.words .length < do
                d Macro.words i [] NameWithPos s =:
                i 1 + d Macro.words .length < if{ d Macro.words i 1 + [] NameWithPos.name else "##" } string nxt =:
                ##addLater remember position in macro for file-position
                s NameWithPos.name nxt prev Token.pos openBlocks program parseWord
                i 1 + i =
              }
              ## update identifiers at end of macro
              END_OF_SECTION next prev Token.pos openBlocks program parseWord
              end-case
            ENUM case
              TokenType .VALUE fPos d Enum.enumType Value.ofType ValueToken new
                tokens tokens .length 1 - []=
              end-case
            ENUM_ENTRY case
              TokenType .VALUE fPos d EnumEntry.enumType d Value new ValueToken new
                tokens tokens .length 1 - []=
              end-case
            TUPLE case
              TokenType .VALUE fPos d Tuple.tupleType Value.ofType ValueToken new
                tokens tokens .length 1 - []=
              end-case
            FINAL_VARIABLE VARIABLE_ID case
              ##addLater wrap curried variables
              ##id=context.wrapCurried(identifier.name,id,identifier.pos);
              ##addLater pre-evaluate global constants
              TokenType .VARIABLE prev Token.pos AccessType .READ_VAR d VariableToken new
                tokens tokens .length 1 - []=
            end-case
            PREDECLARED_PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            }
          else
            ##TODO resolve missing declarable
          }
        }
      }
      ## try parsing as integer
      0 int off =:
      ## detect signs
      false bool sgn =:
           word 0 [] '-' ==  if{
        true sgn =
        off 1 + off =
      else word 0 [] '+' == if
        off 1 + off =
      }
      10 int base =:
      ##detect base modifiers
      word .length off - 3 > if{
             word off off 2 + [:] "0b" ==  if{
          2 base =
          off 2 + off =
        else word off off 2 + [:] "0x" == if
          16 base =
          off 2 + off =
        }
      }
      off word .length < &&{ word off [] base valueOfDigit 0 >= } if{ ##number starts with digit after prefixes
        word word .length 1 - [] 'u' == ||{ word word .length 1 - [] 'U' == } if{ ##unsigned
          word off word .length 1 - [:] base false stringToInt switch{
          ERR_NONE case
            sgn if{ -_ } uint val =:
            tokens TokenType .VALUE fPos val Value.ofUInt ValueToken new << tokens =
            return
            end-case
          ERR_OVERFLOW case
            "value does not fit in an unsigned int: \"" word <<* "\" " <<*
                fPos << '\n' << eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          }
        else
          word off word .length [:] base true stringToInt switch{
          ERR_NONE case
              sgn if{ -_ } int val =:
              tokens TokenType .VALUE fPos val Value.ofInt ValueToken new << tokens =
              return
            end-case
          ERR_OVERFLOW case
            "value does not fit in a signed int: \"" word <<* "\" " <<*
                fPos << '\n' << eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          }
          word off word .length [:] base stringToFloat StringParseError .ERR_NONE == if{
            sgn if{ -_ } float val =:
            tokens TokenType .VALUE fPos val Value.ofFloat ValueToken new << tokens =
            return
          else
            drop
          }
        }
      }
      ## end integer parsing
      ##constants, operators and remaining keywords
      word switch{
      END_OF_SECTION case
        ##do nothing
        end-case
      ## detect true and false
      "true" case
        tokens TokenType .VALUE fPos Value.TRUE  ValueToken new << tokens =
        end-case
      "false" case
        tokens TokenType .VALUE fPos Value.FALSE ValueToken new << tokens =
        end-case
      ## detect primitive type-names
      "bool" case
        tokens TokenType .VALUE fPos Type.BOOL Value.ofType ValueToken new << tokens =
        end-case
      "byte" case
        tokens TokenType .VALUE fPos Type.BYTE Value.ofType ValueToken new << tokens =
        end-case
      "codepoint" case
        tokens TokenType .VALUE fPos Type.CODEPOINT Value.ofType ValueToken new << tokens =
        end-case
      "int" case
        tokens TokenType .VALUE fPos Type.INT  Value.ofType ValueToken new << tokens =
        end-case
      "uint" case
        tokens TokenType .VALUE fPos Type.UINT Value.ofType ValueToken new << tokens =
        end-case
      "float" case
        tokens TokenType .VALUE fPos Type.FLOAT Value.ofType ValueToken new << tokens =
        end-case
      "type" case
        tokens TokenType .VALUE fPos Type.TYPE Value.ofType ValueToken new << tokens =
        end-case
      "var" case
        tokens TokenType .VALUE fPos Type.VAR Value.ofType ValueToken new << tokens =
        end-case
      ## control-flow key-words
      "lambda" "λ" case
        openBlocks OpenBlocks.blocks BlockType .PROC_BLOCK fPos tokens .length CodeBlock new << drop
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "return" "exit" case
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "=>" ":" case
        openBlocks OpenBlocks.blocks .length 0 == if{
          word " can only be used in (lambda-)procedures " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType .PROC_BLOCK != if{
          word " can only be used in (lambda-)procedures " <<* fPos << '\n' << eputs
          1 exit
        }
        ##TODO update procedure-block
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "while" case
        openBlocks OpenBlocks.blocks  fPos tokens .length newWhileBlock  << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .WHILE 0 BlockToken new << tokens =
        end-case
      "do" case
        openBlocks OpenBlocks.blocks .length 0 == if{
          word " can only be used in while-statement " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType .PROC_BLOCK != &&{ block CodeBlock.type BlockType .WHILE_BLOCK != } if{
          word " can only be used in while-statement " <<* fPos << '\n' << eputs
          1 exit
        }
        block WhileBlock.forkPos -1 != if{
          "duplicate 'do' in while-statement " fPos <<
          "\n previous appearance at " <<* tokens block WhileBlock.forkPos [] Token.pos << '\n' << eputs
          1 exit
        }
        tokens .length block WhileBlock.forkPos=
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .DO -1 BlockToken new << tokens =
        ##open while-context
        context newBlockContext context =
        context program Program.context=
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        end-case
      "if" case
        openBlocks OpenBlocks.blocks  fPos tokens .length newIfBlock  << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .IF 0 BlockToken new << tokens =
        ##open if-context
        context newBlockContext context =
        context program Program.context=
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        end-case
      "else" case
        openBlocks OpenBlocks.blocks .length 0 == if{
          word " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType .IF_BLOCK != if{
          word " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        block IfBlock.prevIf -1 == if{
          "unexpected 'else'-statement, 'else' can only appear after 'if' or '_if' "
            fPos << '\n' << eputs
          1 exit
        }
        ##close if-context
        context BlockContext.parent context =
        context program Program.context=
        tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
        block IfBlock.else_positions .length 0 > if{
          ##close else-context
          tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
        }
        block IfBlock.else_positions tokens .length << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .ELSE -1 BlockToken new << tokens =
        tokens block IfBlock.prevIf [] Token tmp =:
        tmp Token.type TokenType .BLOCK_TOKEN == &&{
          tmp BlockToken.type BlockTokenType .IF == ||{ tmp BlockToken.type BlockTokenType ._IF == } }
          "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
        tokens .length block IfBlock.prevIf - tmp BlockToken.target=
        -1 block IfBlock.prevIf=
        block IfBlock.else_positions .length 1 <= if{
          ##open else-context
          context newBlockContext context =
          context program Program.context=
          tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        }
        end-case
      "_if" case
        openBlocks OpenBlocks.blocks .length 0 == if{
          word " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType .IF_BLOCK != if{
          word " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        block IfBlock.prevIf -1 != if{
          "unexpected '_if'-statement, '_if' can only appear after 'else' "
            fPos << '\n' << eputs
          1 exit
        }
        tokens .length block IfBlock.prevIf=
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType ._IF 0 BlockToken new << tokens =
        ##open if-context
        context newBlockContext context =
        context program Program.context=
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        end-case
      "switch" case
        openBlocks OpenBlocks.blocks BlockType .SWITCH_BLOCK fPos tokens .length CodeBlock new << drop
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "case" "end-case" "default" case
        openBlocks OpenBlocks.blocks .length 0 == if{
          word " can only be used in switch-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType .SWITCH_BLOCK != if{
          word " can only be used in switch-blocks " <<*  fPos << '\n' << eputs
          1 exit
        }
        ##TODO update switch-block
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "end" case
        openBlocks OpenBlocks.blocks .length 0 == if{
          "unexpected end-statement " fPos << '\n' << eputs
          1 exit
        }
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] CodeBlock block =:
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - openBlocks OpenBlocks.blocks .length [:] clear
        block CodeBlock.type switch{
        IF_BLOCK case
          block IfBlock.prevIf -1 != if{
            ##close if-context
            context BlockContext.parent context =
            context program Program.context=
            tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
            tokens block IfBlock.prevIf [] Token tmp =:
            tmp Token.type TokenType .BLOCK_TOKEN == &&{
              tmp BlockToken.type BlockTokenType .IF == ||{ tmp BlockToken.type BlockTokenType ._IF == } }
              "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
            tokens .length block IfBlock.prevIf - tmp BlockToken.target=
            block IfBlock.else_positions .length 0 > if{
              ## close-else context
              tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
            }
          else
            ## close-else context
            tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
          }
          0 int i =:
          while{ i block IfBlock.else_positions .length < do
            tokens block IfBlock.else_positions i [] [] Token tmp =:
            tmp Token.type TokenType .BLOCK_TOKEN == &&{ tmp BlockToken.type BlockTokenType .ELSE == }
            "token at end of if-branch has to be BlockToken:'else'" assert
            tokens .length block IfBlock.else_positions i [] - tmp BlockToken.target=
            i 1 + i =
          }
          block IfBlock.else_positions .length 0 > if{
            ##close-else context
            context BlockContext.parent context =
            context program Program.context=
          }
          tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .END-IF 0 BlockToken new << tokens =
          end-case
        WHILE_BLOCK case
          block WhileBlock.forkPos -1 == if{
            "while block at " block CodeBlock.startPos << " does not contain a 'do' statement " <<*
            fPos << eputs
            1 exit
          }
          ##close context
          context BlockContext.parent context =
          context program Program.context=
          tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
          tokens block WhileBlock.forkPos [] Token tmp =:
          tmp Token.type TokenType .BLOCK_TOKEN == &&{ tmp BlockToken.type BlockTokenType .DO == }
            "token at fork-pos of While has to be BlockToken:'do'" assert
          block WhileBlock.forkPos tokens .length 3 - == if{ ## do context-open context-close end
            tokens tokens .length 2 - tokens .length [:] clear ##remove context open/close
            TokenType .BLOCK_TOKEN fPos BlockTokenType .DO-WHILE block CodeBlock.start tokens .length 1 - - BlockToken new
              tokens block WhileBlock.forkPos []=
          else
            tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .END-WHILE
              block CodeBlock.start tokens .length - BlockToken new << tokens =
            tokens .length block WhileBlock.forkPos - tmp BlockToken.target=
          }
          end-case
        SWITCH_BLOCK case
          ## TODO close switch block
          "Waring closing switch-blocks is currently not implemented\n" eputs
          end-case
        PROC_BLOCK case
          ## TODO close proc block
          "Waring closing proc-blocks is currently not implemented\n" eputs
          end-case
        ENUM_BLOCK case
          tokens .length block CodeBlock.start > if{
            "Invalid token in enum: " tokens block CodeBlock.start [] << ' '
              << tokens block CodeBlock.start [] Token.pos << '\n' << eputs
            1 exit
          }
          context block RootContext.declareEnum
          end-case
        TUPLE_BLOCK case
          tokens block CodeBlock.start tokens .length [:] Token list subList =:
          subList constEvaluate Token list values =:
          subList clear
          values .length Type list new Type list types =:
          0 int i =:
          while{ i values .length < do
            values i [] Token.type TokenType .VALUE != if{
              "tokens of type:" TokenType .fieldNames values i [] Token.type [] <<* " are not allowed in tuple signatures " <<*
              values i [] Token.pos << '\n' << eputs
              1 exit
            else values i [] ValueToken.value Value.type Type.TYPE != if
              "values of type:" values i [] ValueToken.value Value.type << " are not allowed in tuple signatures " <<*
              values i [] Token.pos << '\n' << eputs
              1 exit
            }
             types values i [] ValueToken.value Value.data Type cast << types =
             i 1 + i =
          }
          values clear
          context
          DeclareableType .TUPLE  block CodeBlock.startPos   block TupleBlock.name  types newTupleType   Tuple new
          RootContext.declareTuple
          end-case
        }
        end-case
      ## operators
      "+" case
        tokens TokenType .OPERATOR fPos OperatorType .PLUS OperatorToken new << tokens =
        end-case
      "-" case
        tokens TokenType .OPERATOR fPos OperatorType .MINUS OperatorToken new << tokens =
        end-case
      "-_" case
        tokens TokenType .OPERATOR fPos OperatorType .NEGATE OperatorToken new << tokens =
        end-case
      "*" case
        tokens TokenType .OPERATOR fPos OperatorType .MULTIPLY OperatorToken new << tokens =
        end-case
      "/" case
        tokens TokenType .OPERATOR fPos OperatorType .DIVIDE OperatorToken new << tokens =
        end-case
      "%" case
        tokens TokenType .OPERATOR fPos OperatorType .MOD OperatorToken new << tokens =
        end-case

      "!" case
        tokens TokenType .OPERATOR fPos OperatorType .NOT OperatorToken new << tokens =
        end-case
      "~" case
        tokens TokenType .OPERATOR fPos OperatorType .FLIP OperatorToken new << tokens =
        end-case
      "&" case
        tokens TokenType .OPERATOR fPos OperatorType .AND OperatorToken new << tokens =
        end-case
      "|" case
        tokens TokenType .OPERATOR fPos OperatorType .OR OperatorToken new << tokens =
        end-case
      "xor" case
        tokens TokenType .OPERATOR fPos OperatorType .XOR OperatorToken new << tokens =
        end-case

      "<<" case
        tokens TokenType .OPERATOR fPos OperatorType .SHIFT_L OperatorToken new << tokens =
        end-case
      ">>" case
        tokens TokenType .OPERATOR fPos OperatorType .SHIFT_R OperatorToken new << tokens =
        end-case

      "<" case
        tokens TokenType .OPERATOR fPos OperatorType .LT OperatorToken new << tokens =
        end-case
      "<=" case
        tokens TokenType .OPERATOR fPos OperatorType .LE OperatorToken new << tokens =
        end-case
      "==" case
        tokens TokenType .OPERATOR fPos OperatorType .EQ OperatorToken new << tokens =
        end-case
      "===" case
        tokens TokenType .OPERATOR fPos OperatorType .REF_EQ OperatorToken new << tokens =
        end-case
      "=!=" case
        tokens TokenType .OPERATOR fPos OperatorType .REF_NE OperatorToken new << tokens =
        end-case
      "!=" case
        tokens TokenType .OPERATOR fPos OperatorType .NE OperatorToken new << tokens =
        end-case
      ">=" case
        tokens TokenType .OPERATOR fPos OperatorType .GE OperatorToken new << tokens =
        end-case
      ">" case
        tokens TokenType .OPERATOR fPos OperatorType .GT OperatorToken new << tokens =
        end-case
      default
        openBlocks OpenBlocks.blocks .length 0 >
          &&{ openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] CodeBlock.type BlockType .ENUM_BLOCK == }
          if{
          openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks .length 1 - [] EnumBlock.elements word fPos NameWithPos new << drop
        else
          tokens TokenType .WORD fPos word WordToken new << tokens =
        }
      }
    }
  }
}

readEscapeChar proc( ParserReader => ){
  ParserReader reader =:
  reader ParserReader.nextByte if{
    byte next =:
    next switch{
    '\\' '\'' '"' case
     reader ParserReader.word next << drop
     end-case
    'n' case
     reader ParserReader.word '\n' << drop
     end-case
    't' case
     reader ParserReader.word '\t' << drop
     end-case
    'r' case
     reader ParserReader.word '\r' << drop
     end-case
    'b' case
     reader ParserReader.word '\b' << drop
     end-case
    'f' case
     reader ParserReader.word '\f' << drop
     end-case
    '0' case
     reader ParserReader.word '\0' << drop
     end-case
    'u' 'U' case
     "\\u is currently unimplemented" eputs
     1 exit
     end-case
    default
     "The escape sequence: '\\" next << "' is not supported " <<* reader ParserReader.pos << '\n' << eputs
     1 exit
    }
  else
    "unexpected end of file " reader ParserReader.pos << '\n' << eputs
    1 exit
  }
}

parseFile proc( #+fileName+# string #+program+# Program =>  ){
  Program program =:
  program Program.context Context context =:
  program Program.tokens Token list tokens =:
  string fileName =:
  fileName "r" open if{ #+auto-unwrap+# else
    "file \"" fileName "\" not found\n" <<* <<* eputs
    1 exit
  }
  16 newBufferedInput #+input+#
  fileName 1 1 FilePosition new       #+pos+#
  16 byte list new                    #+word+#
  fileName 1 1 FilePosition new       #+wordPos+#
  ParserReader new ParserReader reader =:
  ## FIXME detect file header
  context RootContext.startFile
  ParseState .STATE_WORD ParseState state =:
  reader ParserReader.pos "" newMacro 16 CodeBlock list new OpenBlocks new OpenBlocks openBlocks =:

  "" string prevWord =:
  fileName 1 1 FilePosition new FilePosition prevPos =:

  while{ reader ParserReader.nextByte do
    #+next-char+#
    state switch{
      STATE_WORD case
        byte next =:
        next ?WhiteSpace if{
          reader ParserReader.word .length 0 > if{
            reader ParserReader.word clone string nextWord =:
            nextWord .length 0 > if{
              prevWord .length 0 > if{
                prevWord nextWord prevPos openBlocks program parseWord
              }
              nextWord prevWord =
              reader ParserReader.wordPos clone prevPos =
            }
          }
          reader ParserReader.nextWord
        else
          next switch{
          '"' case
              reader ParserReader.word "u" == if{
                ParseState .STATE_USTRING state =
                reader ParserReader.word clear
              else reader ParserReader.word .length 0 == if
                ParseState .STATE_STRING state =
              else
                "illegal string-prefix: \"" reader ParserReader.word <<* "\" " <<*
                   reader ParserReader.pos << '\n' << eputs
                1 exit
              }
            end-case
          '\'' case
              reader ParserReader.word "u" == if{
                ParseState .STATE_UCHAR state =
                reader ParserReader.word clear
              else reader ParserReader.word .length 0 == if
                ParseState .STATE_CHAR state =
              else
                "illegal char-prefix: \"" reader ParserReader.word <<* "\" " <<*
                   reader ParserReader.pos << '\n' << eputs
                1 exit
              }
            end-case
          '#' case
              reader ParserReader.nextByte if{
                next =
                next '#' == if{
                  reader ParserReader.word clone string nextWord =:
                  nextWord .length 0 > if{
                    prevWord .length 0 > if{
                      prevWord nextWord prevPos openBlocks program parseWord
                    }
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  }
                  reader ParserReader.nextWord
                  ParseState .STATE_LINE_COMMENT state =
                else next '+' == if
                  reader ParserReader.word clone string nextWord =:
                  nextWord .length 0 > if{
                    prevWord .length 0 > if{
                      prevWord nextWord prevPos openBlocks program parseWord
                    }
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  }
                  reader ParserReader.nextWord
                  ParseState .STATE_COMMENT state =
                else
                  reader ParserReader.word '#' << next << drop
                }
              else
                reader ParserReader.word '#' << drop
              }
            end-case
          default
            reader ParserReader.word next << drop
          }
        }
      end-case
      STATE_STRING STATE_USTRING case
        byte next =:
        next '"' == if{
          prevWord .length 0 > if{
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            "" prevWord =
          }
          tokens
            TokenType .VALUE reader ParserReader.wordPos clone
            state ParseState .STATE_USTRING == if{
              reader ParserReader.word codepoints Value.ofUString
            else
              reader ParserReader.word clone Value.ofString
            }
          ValueToken new << tokens =
          reader ParserReader.nextWord
          ParseState .STATE_WORD state =
        else next '\\' == if
          reader readEscapeChar
        else
          reader ParserReader.word next << drop
        }
      end-case
      STATE_CHAR STATE_UCHAR case
        byte next =:
        next '\'' == if{
          prevWord .length 0 > if{
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            "" prevWord =
          }
          tokens
            TokenType .VALUE reader ParserReader.wordPos clone
            state ParseState .STATE_UCHAR == if{
              reader ParserReader.word codepoints
              dup .length 1 != if{
                reader ParserReader.word " is not a valid unicode character " <<*
                reader ParserReader.pos << '\n' <<
                eputs
                1 exit
              }
              #+chars+# 0 [] Value.ofCodepoint
            else
              reader ParserReader.word clone
              dup .length 1 != if{
                #+str+# " is not a valid unicode character " <<*
                reader ParserReader.pos << '\n' <<
                eputs
                1 exit
              }
              #+chars+# 0 [] Value.ofByte
            }
          ValueToken new << tokens =
          reader ParserReader.nextWord
          ParseState .STATE_WORD state =
        else next '\\' == if
          reader readEscapeChar
        else
          reader ParserReader.word next << drop
        }
      end-case
      STATE_COMMENT case
        #+input-char+# '+' == if{
          reader ParserReader.nextByte if{
            '#' == if{
              ParseState .STATE_WORD state =
            }
          }
        }
      end-case
      STATE_LINE_COMMENT case
        #+input-char+# '\n' == if{
          ParseState .STATE_WORD state =
        }
      end-case
    }
  }

  state switch{
    STATE_WORD case
      reader ParserReader.word clone string nextWord =:
      prevWord .length 0 > if{
        prevWord nextWord prevPos openBlocks program parseWord
        "" prevWord =
      }
      nextWord "" reader ParserReader.wordPos clone openBlocks program parseWord
      END_OF_SECTION "" reader ParserReader.wordPos clone openBlocks program parseWord
      reader ParserReader.nextWord
      end-case
    STATE_CHAR STATE_UCHAR case
     "unfinished char-literal " reader ParserReader.wordPos << '\n' <<
      eputs
      1 exit
      end-case
    STATE_STRING STATE_USTRING case
     "unfinished string-literal " reader ParserReader.wordPos << '\n' <<
      eputs
      1 exit
      end-case
    STATE_COMMENT case
     "unfinished comment " reader ParserReader.wordPos << '\n' <<
      eputs
      1 exit
      end-case
    STATE_LINE_COMMENT case
      ##do nothing
      end-case
  }
  context reader ParserReader.wordPos RootContext.endFile
}

constEvaluate proc( Token list => Token list ){
  Token list tokens =:
  tokens .length Token list new Token list res =:
  0 int i =:
  while{ i tokens .length < do
    tokens i [] Token.type switch{
      VALUE case
        res tokens i [] << res =
        end-case
      OPERATOR case
        tokens i [] OperatorToken.opType switch{
          PLUS
          MINUS
          NEGATE
          INVERT
          MULTIPLY
          DIVIDE
          MOD

          NOT
          FLIP
          AND
          OR
          XOR

          SHIFT_L
          SHIFT_R

          LT
          LE
          EQ
          REF_EQ
          REF_NE
          NE
          GE
          GT case
            "operators of type:" OperatorType .fieldNames tokens i [] OperatorToken.opType [] <<*
            " are currently not supported in constant evaluation " <<*
            tokens i [] Token.pos << '\n' << eputs
            1 exit
            end-case
        }
        end-case
      WORD
      KEY_WORD
      PROCEDURE_START
      ENUM_START
      IDENTIFIER
      VARIABLE
      BLOCK_TOKEN
      CONTEXT_OPEN
      CONTEXT_CLOSE case
        "tokens of type:" TokenType .fieldNames tokens i [] Token.type [] <<*
        " are currently not supported in constant evaluation " <<*
        tokens i [] Token.pos << '\n' << eputs
        1 exit
      end-case
    }
    i 1 + i =
  }
  res return
}

##addLater typeCheckProgram
##addLater compileProgram

main proc( string list => ){
  string list args =:
  args .length 2 < if{
    "usage: <pathToFile> \n" puts ## "usage: <pathToFile> (-lib <libPath>)"
    0 exit
  }
  args 1 [] string path =:
  path .length 0 > &&{ path 0 [] '.' == } if{ ##local path
    args 0 [] clone path 1 path .length [:] <<* path =
  }

  16 Token list new Token list tokens =:
  newRootContext RootContext context =:
  path tokens context Program new parseFile

  0 int i =:
  while{ i tokens .length < do
    tokens i [] Token token =:
    "" token << " " <<* token Token.pos << '\n' << puts
    i 1 + i =
  }
  "\n" puts
  "declared values:\n" puts
  context Context.elements HashMap.itr while{ HashMapItr.next do
      string Declareable MapEntry e =:
      e MapEntry.key print ": " e MapEntry.value << println
   } drop
}
