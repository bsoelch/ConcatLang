concat.concat :
## concat compiler written in concat
#+
this file is based on an outdated version of the interpreter
the compiler will be updated once the language is stabilized

the current version of the compiler is kept up to date as an example of a complex concat program
+#
##TODO update concat.concat

## currently in early development phase

stack   #include
chars   #include
valueIO #include
utf8    #include
core    #import

hashMap #include
hashMap #import

bufferedIO #include
io #import


FilePosition struct{
  string :fileName
  uint   :line      mut
  uint   :posInLine mut
}
FilePosition.newLine    proc( FilePosition => ){
  dup dup .line 1 + swap .line = 1 swap .posInLine =
}
FilePosition.nextChar   proc( FilePosition => ){
  dup .posInLine 1 + swap .posInLine =
}
<< proc( string mut FilePosition => string mut ){
  FilePosition position =:
  #+str+# position .fileName <<*
  ':' << position .line      <<i
  ':' << position .posInLine <<i return
}

NameWithPos struct{
  string       :name
  FilePosition :pos
}

TypeType enum{ PRIMITIVE_TYPE TUPLE_TYPE ENUM_TYPE WRAPPER_TYPE }
Type struct{
  TypeType :typeType
}
PrimitiveType struct{ Type extend
  type :wrapped
}

TupleType struct{ Type extend
  string    :name
  Type list :types
}
newTupleType proc( #+name+# string #+types+# Type list mut? => TupleType ){
  Type list elements =:
  string name =:
  TypeType .TUPLE_TYPE name elements TupleType new return
}

EnumType struct{ Type extend
  string           :name
  NameWithPos list :fields
}
newEnumType proc( #+name+# string #+fields+# NameWithPos list => EnumType ){
  NameWithPos list fields =:
  string name =:
  TypeType .ENUM_TYPE name fields EnumType new return
}

WrapperTypeType enum{ LIST OPTIONAL VAR_ARGS }
WrapperType struct{ Type extend
  WrapperTypeType :wrapperType
  Type            :wrapped
}

<< proc( string mut Type => string mut ){
  Type t =:
  t .typeType switch{
  PRIMITIVE_TYPE case
    t PrimitiveType cast .wrapped stringValue <<* return
    end-case
  WRAPPER_TYPE case
    t WrapperType wt =:
    wt .wrapped <<
    wt .wrapperType switch{
    LIST     case " list"     <<* return end-case
    OPTIONAL case " optional" <<* return end-case
    VAR_ARGS case " ..."      <<* return end-case
    }
    end-case
  TUPLE_TYPE case
    t TupleType tt =:
    tt .name <<* '[' <<
    0 int i mut =:
    while{ i tt .types .length < do
      i 0 > if{ ", " <<* }
      tt .types i [] <<
      i 1 + i =
    }
    ']' <<
    end-case
  ENUM_TYPE case
    t EnumType et =:
    et .name <<* '[' <<
    0 int i mut =:
    while{ i et .fields .length < do
      i 0 > if{ ", " <<* }
      et .fields i [] .name <<*
      i 1 + i =
    }
    ']' <<
    end-case
  }
}

TypeType .PRIMITIVE_TYPE      bool PrimitiveType new Type Type.BOOL      =:
TypeType .PRIMITIVE_TYPE      byte PrimitiveType new Type Type.BYTE      =:
TypeType .PRIMITIVE_TYPE codepoint PrimitiveType new Type Type.CODEPOINT =:
TypeType .PRIMITIVE_TYPE      uint PrimitiveType new Type Type.UINT      =:
TypeType .PRIMITIVE_TYPE       int PrimitiveType new Type Type.INT       =:
TypeType .PRIMITIVE_TYPE     float PrimitiveType new Type Type.FLOAT     =:
TypeType .PRIMITIVE_TYPE      type PrimitiveType new Type Type.TYPE      =:
TypeType .PRIMITIVE_TYPE       var PrimitiveType new Type Type.VAR       =:

TypeType .WRAPPER_TYPE WrapperTypeType .LIST Type.BYTE      WrapperType new Type Type.STRING  =:
TypeType .WRAPPER_TYPE WrapperTypeType .LIST Type.CODEPOINT WrapperType new Type Type.USTRING =:

Value struct{
  Type :valType
  var  :data
}

<< proc( string mut Value => string mut ){
  Value v =:
  v .valType << ": " <<*
  v .valType .typeType switch{
  PRIMITIVE_TYPE case
    v .valType Type.TYPE == if{
      v .data Type cast << return
    else
      v .data stringValue <<* return
    }
    end-case
  ENUM_TYPE case
   '[' << v .data EnumEntry cast .index stringValue <<* ']' << return
   end-case
  TUPLE_TYPE case
    "tuple-type unimplemented\n" eputs 1 exit
  end-case
  WRAPPER_TYPE case
    v .valType Type.STRING == ||{ v .valType Type.USTRING == } if{
      v .data stringValue <<* return
    else
      "wrapper-type unimplemented\n" eputs 1 exit
    }
  end-case
  }
}

Type.BOOL true  Value new Value Value.TRUE  =:
Type.BOOL false Value new Value Value.FALSE =:
Value.ofByte      proc( byte       => Value ){ Type.BYTE      swap Value new return }
Value.ofCodepoint proc( codepoint  => Value ){ Type.CODEPOINT swap Value new return }
Value.ofInt       proc( int        => Value ){ Type.INT       swap Value new return }
Value.ofUInt      proc( uint       => Value ){ Type.UINT      swap Value new return }
Value.ofFloat     proc( float      => Value ){ Type.FLOAT     swap Value new return }
Value.ofType      proc( Type       => Value ){ Type.TYPE      swap Value new return }
Value.ofString    proc( string     => Value ){ Type.STRING    swap Value new return }
Value.ofUString   proc( ustring    => Value ){ Type.USTRING   swap Value new return }

BlockType enum{
  IF_BLOCK
  WHILE_BLOCK
  SWITCH_BLOCK
  PROC_BLOCK
  ENUM_BLOCK
  TUPLE_BLOCK
}
CodeBlock struct{
  BlockType    :blockType
  FilePosition :startPos
  int          :start
}

WhileBlock struct{ CodeBlock extend
  int :forkPos mut
}
newWhileBlock proc( #+startPos+# FilePosition #+start+# int => WhileBlock ){
  int start =:
  FilePosition startPos =:
  BlockType .WHILE_BLOCK startPos start -1 WhileBlock new return
}

IfBlock struct{  CodeBlock extend
  int           :prevIf         mut
  uint list mut :else_positions
}
newIfBlock proc( #+startPos+# FilePosition #+start+# int => IfBlock ){
  int start =:
  FilePosition startPos =:
  BlockType .IF_BLOCK startPos start start 16 uint list mut new IfBlock new return
}

EnumBlock struct{ CodeBlock extend
  string               :name
  NameWithPos list mut :elements
}
newEnumBlock proc( #+name+# string #+startPos+# FilePosition #+start+# int => EnumBlock ){
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType .ENUM_BLOCK startPos start name 16 NameWithPos list mut new EnumBlock new return
}
TupleBlock struct{ CodeBlock extend
  string :name
}
newTupleBlock proc( #+name+# string #+startPos+# FilePosition #+start+# int => TupleBlock ){
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType .TUPLE_BLOCK startPos start name TupleBlock new return
}



DeclareableType enum{
  MACRO
  ENUM
  ENUM_ENTRY
  TUPLE
  VARIABLE_ID
  FINAL_VARIABLE
  PREDECLARED_PROCEDURE
  PROCEDURE
}
<<DeclareableType proc( #+str+# string mut #+a+# bool #+type+# DeclareableType => string mut ){
   #+type+# switch{
   MACRO case
     #+a+# if{ "a macro" else "macro" } <<* return
     end-case
   ENUM case
     #+a+# if{ "an enum" else "enum" } <<* return
     end-case
   ENUM_ENTRY case
     #+a+# if{ "an enum entry" else "enum entry" } <<* return
     end-case
   TUPLE case
     #+a+# if{ "a tuple" else "tuple" } <<* return
     end-case
   VARIABLE_ID case
     #+a+# if{ "a variable" else "variable" } <<* return
     end-case
   FINAL_VARIABLE case
     #+a+# if{ "a final variable" else "final variable" } <<* return
     end-case
   PREDECLARED_PROCEDURE case
     #+a+# if{ "a predeclared procedure" else "predeclared procedure" } <<* return
     end-case
   PROCEDURE case
     #+a+# if{ "a procedure" else "procedure" } <<* return
     end-case
   }
}

Declareable struct{
  DeclareableType :dType
  FilePosition    :pos mut
}

ContextType enum{ ROOT_CONTEXT PROC_CONTEXT BLOCK_CONTEXT }

Context struct{
  string Declareable HashMap :elements
  int                        :varCount mut
  ContextType                :cType
}
Context.incVarCount proc( Context => ){ dup .varCount 1 + swap .varCount = }

Macro struct{ Declareable extend
  string               :name mut
  NameWithPos list mut :words
}
newMacro proc( FilePosition string => Macro ){
  string name =:
  FilePosition mPos =:
  DeclareableType .MACRO mPos name 16 NameWithPos list mut new Macro new return
}

VariableId struct{ Declareable extend
  bool :global
  int  :level
  int  :varId
}
VariableId.isConst proc( VariableId => bool ){
  .dType DeclareableType .FINAL_VARIABLE ==
}

CurriedVariable struct{ Declareable extend }
PredeclaredProc struct{ Declareable extend }
Procedure struct{ Declareable extend }

Enum struct{ Declareable extend
  EnumType :enumType
}
newEnum proc( #+pos+# FilePosition #+name+# string #+fields+# NameWithPos list => Enum ){
  #+fields+# #+name+# newEnumType EnumType enumType =:
  FilePosition fPos =:
  DeclareableType .ENUM fPos enumType Enum new return
}
EnumEntry struct{ Declareable extend
  EnumType :enumType
  int      :index
}
newEnumEntry proc( #+enumType+# EnumType #+index+# int => EnumEntry ){
  int index =:
  EnumType enumType =:
  DeclareableType .ENUM_ENTRY enumType .fields index [] .pos enumType index EnumEntry new return
}

Tuple struct{ Declareable extend
  TupleType :tupleType
}

<< proc( string mut VariableId => string mut ){
  VariableId v =:
  v .global if{ "global:" else "local:" } <<*
  v .level <<u ':' <<
  v .varId <<u
  return
}
<< proc( string mut Declareable => string mut ){
  Declareable d =:
  false d .dType <<DeclareableType ": " <<*
  d .dType switch{
  MACRO case
    d Macro cast .name <<*
    end-case
  ENUM case
    d Enum cast .enumType <<
    end-case
  ENUM_ENTRY case
    d EnumEntry ee =:
    ee .enumType .name <<* '[' <<
    ee .index stringValue <<*
    ']' <<
    end-case
  TUPLE case
    d Tuple cast .tupleType <<
    end-case
  FINAL_VARIABLE VARIABLE_ID case
    d VariableId cast <<
    end-case
  PREDECLARED_PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  }
  " at " <<* d .pos << return
}

OpenModule struct{
  string list                    :path
  FilePosition                   :declaredAt
  string list mut                :imports
  string PredeclaredProc HashMap :predeclared
}
newOpenModule proc( #+path+# string list #+declaredAt+# FilePosition => OpenModule ){
  16 string list mut new 16 string PredeclaredProc newHashMap OpenModule new return
}
<< proc( string mut OpenModule => string mut ){
  OpenModule m =:
  string mut str =:
  0 int i =:
  str while{ i m .path .length < do
     m .path i [] <<* "'" <<*
  }
  " declared at " <<* m .declaredAt << return
}

OpenFile struct{
  string list mut                       :globalImports
  string PredeclaredProc HashMap        :globalPredeclared
    #+openModules+# OpenModule list mut :openModules
}

newOpenFile proc( => OpenFile ){
  16 string list mut new
  16 string PredeclaredProc newHashMap
  16 OpenModule list mut new
  OpenFile new return
}

RootContext struct{ Context extend
    OpenFile list mut   :openFiles
    string bool HashMap :namespaces
}
newRootContext proc( => RootContext ){
  16 string Declareable newHashMap
  0
  ContextType .ROOT_CONTEXT
  16 OpenFile list mut new
  16 string bool newHashMap
  RootContext new return
}

BlockContext struct{ Context extend
  Context :parent
}
newBlockContext proc( #+parent+# Context => BlockContext ){
  Context parent =:
  16 string Declareable newHashMap 0 ContextType .BLOCK_CONTEXT parent BlockContext new return
}

ProcContext struct{ BlockContext extend
   CurriedVariable list :curried
}

Context.isGlobal proc( Context => bool ){
  Context context =:
  context .cType switch{
  ROOT_CONTEXT case
    true return
    end-case
  PROC_CONTEXT case
    false return
    end-case
  BLOCK_CONTEXT case
    context BlockContext cast .parent Context.isGlobal return
    end-case
  }
}
Context.procContext proc( Context => ProcContext optional ){
  Context context =:
  context .cType switch{
  ROOT_CONTEXT case
    ProcContext empty return
    end-case
  PROC_CONTEXT case
    context ProcContext cast wrap return
    end-case
  BLOCK_CONTEXT case
    context BlockContext cast .parent Context.procContext return
    end-case
  }
}
Context.level proc( Context => int ){
  Context context =:
  context .cType switch{
  ROOT_CONTEXT PROC_CONTEXT case
    0 return
    end-case
  BLOCK_CONTEXT case
    context BlockContext cast .parent Context.level 1 + return
    end-case
  }
}
Context.ensureDeclareable proc( #+context+# Context #+name+#string #+type+# DeclareableType #+pos+# FilePosition
  => #+localName+# string ){
  FilePosition fPos =:
  DeclareableType dType =:
  string name =:
  Context context =:
  context .cType ContextType .ROOT_CONTEXT == if{ context name RootContext.inCurrentModule else name }  string localName =:
  context .elements localName HashMap.get if{
    Declareable prev =:
    ## procedures can overwrite predeclared procedures
    prev .dType DeclareableType .PREDECLARED_PROCEDURE != ||{ prev .dType DeclareableType .PROCEDURE != } if{
      128 string mut new
      "cannot declare " <<* false dType <<DeclareableType ' ' << name <<*
      ", the identifier is already used by " <<* true prev .dType <<DeclareableType
      " (declared at " <<* prev .pos << ") at " <<* fPos << '\n' << eputs
      1 exit
    }
  }
  context name Context.getDeclareable if{
    Declareable shadowed =:
    128 string mut new
    "Warning: " <<* false dType <<DeclareableType " " <<* name <<*
    " declared at " <<* fPos << "\n     shadows existing " <<*
    false shadowed .dType <<DeclareableType " declared at " <<*
    shadowed .pos << '\n' << eputs
  }
  localName return
}
Context.declareVariable proc( #+context+# Context #+name+# string #+isConst+# bool #+pos+# FilePosition => VariableId ){
    FilePosition fPos =:
    bool isConst =:
    string name mut =:
    Context context =:
    isConst if{ DeclareableType .FINAL_VARIABLE else DeclareableType .VARIABLE_ID } DeclareableType dType =:
    context name dType fPos Context.ensureDeclareable name =
    dType fPos context Context.isGlobal context Context.level context .varCount VariableId new VariableId varId =:
    context Context.incVarCount
    varId context .elements name HashMap.put drop
    varId return
}
Context.getDeclareable proc( #+context+# Context #+name+# string => Declareable optional ){
    string name =:
    Context context =:
    context .cType switch{
    ROOT_CONTEXT case
      context RootContext.currentPaths paths =::
      paths .length 1 - int i mut =:
      while{ i 0 >= do ##go through all namespaces
        context .elements paths i [] clone name <<* mut~ HashMap.get dup .hasValue if{
          #+element+# Declareable optional cast return
        else drop }
        i 1 - i =
      }
      context .elements name HashMap.get return
      end-case
    PROC_CONTEXT BLOCK_CONTEXT case
      context .elements name HashMap.get dup .hasValue if{
        #+element+# Declareable optional cast return
      else drop
        context BlockContext cast .parent name Context.getDeclareable return
      }
      end-case
    }
}
MODULE_SEPARATOR #define '\'' #end
##token that signals the compiler, that there will be no more statements in the current code-section
END_OF_SECTION #define "##" #end
RootContext.startFile proc( RootContext => ){
  .openFiles newOpenFile << drop
}
RootContext.file proc( RootContext => OpenFile ){
  RootContext context =:
  context .openFiles context .openFiles .length 1 - [] return
}

RootContext.inCurrentModule proc( RootContext  #+name+# string => string mut ){
   string name =:
   #+context+# RootContext.file .openModules namespaces =::
   name .length string mut new path =::
   namespaces .length 0 > if{
     0 int i mut =:
     while{ i namespaces .length < do
        namespaces i [] .path string list paths =:
        0 int j mut =:
        while{ j paths .length < do
          path paths j [] <<* MODULE_SEPARATOR << path =
          j 1 + j =
        }
        i 1 + i =
     }
   }
   path name <<* return
}
RootContext.startModule proc( RootContext #+name+# string #+declaredAt+# FilePosition => ){
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context .elements context name RootContext.inCurrentModule mut~ HashMap.get if{
    Declareable d =:
    64 string mut new
    "cannot declare namespace " <<* name <<* ", the identifier is already used by " <<*
    true d .dType <<DeclareableType
    " (declared at " <<* d .pos << ")\n at " <<*
    fPos  << '\n' << eputs
    1 exit
  }
  context "" RootContext.inCurrentModule fullPath =::
  16 string list mut new path =::
  16 string mut new tmp =::
  0 int i mut =:
  while{ i name .length < do
    fullPath name i [] << fullPath =
    name i [] MODULE_SEPARATOR == if{
      true context .namespaces fullPath mut~ HashMap.put drop
      path tmp mut~ << path =
      tmp clear
    else
      tmp name i [] << tmp =
    }
    i 1 + i =
  }
  path tmp mut~ << path =
  fullPath MODULE_SEPARATOR << fullPath =
  true context .namespaces fullPath mut~ HashMap.put drop
  context RootContext.file .openModules path mut~ fPos newOpenModule << drop
}
RootContext.addImport proc( RootContext #+name+# string #+declaredAt+# FilePosition => ){
  FilePosition fPos =:
  string name0 =:
  name0 clone '\'' << mut~ string name =:
  RootContext context =:
  context .namespaces name HashMap.contains if{
     context RootContext.file OpenFile file =:
     file .openModules .length 0 > if{
         file .openModules file .openModules .length 1 - [] .imports name << drop
     else
         file .globalImports name << drop
     }
  else context .elements name HashMap.get if
    drop
    "static imports are currently unimplemented"
    1 exit
  else
    64 string mut new
    "namespace " <<* name0 <<* " does not exist " <<* fPos << '\n' << eputs
    1 exit
  }
}
RootContext.endModule proc( RootContext FilePosition => ){
  FilePosition fPos =:
  RootContext context =:
  context RootContext.file OpenFile file =:
  file .openModules .length 0 == if{
    64 string mut new
    "Unexpected End of namespace " <<* fPos << '\n' << eputs
    1 exit
  }
  file .openModules file .openModules .length 1 - [] OpenModule removed =:
  file .openModules file .openModules .length 1 - file .openModules .length [:] clear
  removed .predeclared .size 0 > if{
    256 string mut new "Syntax Error: missing variables/procedures" <<* string mut message =:
    removed .predeclared ^_ for{
       string PredeclaredProc MapEntry e =:
       message "\n- " <<* e .key string cast <<* " (at " <<* e .value .pos << ')' << drop
    } drop
    message fPos << '\n' << eputs
    1 exit
  }
}
RootContext.endFile proc( RootContext FilePosition => ){
  FilePosition fPos =:
  RootContext context =:
  context .openFiles context .openFiles .length 1 - [] OpenFile closed =:
  context .openFiles context .openFiles .length 1 - context .openFiles .length [:] clear
  closed .openModules .length 0 > if{
    "unclosed namespaces at end of File:\n" eputs
    closed .openModules .length 1 - int i mut =:
    while{ i 0 >= do
      closed .openModules i [] OpenModule removed =:
      removed .predeclared .size 0 > if{
        64 string mut new "Syntax Error: missing variables/procedures" <<* message =::
        removed .predeclared ^_ for{
           string PredeclaredProc MapEntry e =:
           message "\n- " <<* e .key string cast <<* " (at " <<* e .value .pos << ')' << drop
        } drop
        message fPos << '\n' << eputs
        1 exit
      }
      32 string mut new " - " <<* removed << '\n' << eputs
      i 1 - i =
    }
    closed .openModules clear
  }
  closed .globalPredeclared .size 0 > if{
    256 string mut new "Syntax Error: missing variables/procedures" <<* message =::
    closed .globalPredeclared ^_ for{
       string PredeclaredProc MapEntry e =:
       message "\n- " <<* e .key string cast <<* " (at " <<* e .value .pos << ')' << drop
    } drop
    message fPos << '\n' << eputs
    1 exit
  }
}

RootContext.currentPaths proc( RootContext => string list mut ){
  #+context+# RootContext.file OpenFile file =:
  file .globalImports clone string list mut paths mut =:
  16 string mut new path =::
  file .openModules namespaces =::
  0 int i mut =:
  while{ i namespaces .length < do
    namespaces i [] .path string list mPath =:
    0 int j mut =:
    while{ j mPath .length < do
      path mPath j [] <<* MODULE_SEPARATOR << path =
      j 1 + j =
      paths path mut~ << paths =
    }
    namespaces i [] .imports  paths paths .length 1 - paths .length 1 - [:]=
    i 1 + i =
  }
  paths return
}
RootContext.predeclared proc( RootContext => string Declareable HashMap ){
  #+context+# RootContext.file OpenFile file =:
  file .openModules .length 0 > if{
    file .openModules file .openModules .length 1 - [] .predeclared return
  else
    file .globalPredeclared return
  }
}

RootContext.declareProcedure proc( #+context+# RootContext #+name+# string #+proc+# Procedure => ){
  Procedure aProc =:
  string name =:
  RootContext context =:
  context name DeclareableType .PROCEDURE aProc .pos Context.ensureDeclareable name =
  context RootContext.predeclared name HashMap.remove if{
    drop
  }
  context .elements name aProc HashMap.put drop
}

RootContext.declareMacro proc( #+context+# RootContext #+macro+# Macro => ){
  Macro macro =:
  macro .name string name mut =:
  RootContext context =:
  context name DeclareableType .MACRO macro .pos Context.ensureDeclareable name =
  macro context .elements name HashMap.put drop
}
RootContext.removeMacro proc( #+context+# RootContext #+name+# string #+pos+# FilePosition => ){
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context .elements context name RootContext.inCurrentModule mut~ HashMap.remove if{
    Declareable removed =:
    removed .dType DeclareableType .MACRO != if{
      128 string mut new
      "macro " <<* name <<* " does not exists, or is shadowed by " <<*
      false removed .dType <<DeclareableType
      " (declared at " <<* removed .pos << ") " <<*
      fPos << '\n' << eputs
      1 exit
    }
  else
    64 string mut new
    "macro " <<* name <<* " does not exists in the current namespace " <<* fPos << '\n' << eputs
    1 exit
  }
}
RootContext.declareEnum proc( #+context+# RootContext #+source+# EnumBlock => ){
  EnumBlock source =:
  source .name string name mut =:
  RootContext context =:
  source .startPos name source .elements mut~ newEnum Enum anEnum =:
  context name DeclareableType .ENUM anEnum .pos Context.ensureDeclareable name =
  anEnum context .elements name HashMap.put drop
  ##declare enum entries
  0 int i mut =:
  anEnum .enumType .fields NameWithPos list fields =:
  while{ i fields .length < do
    source .name clone MODULE_SEPARATOR << fields i [] .name <<* mut~ fieldName =::
    context fieldName DeclareableType .ENUM_ENTRY fields i [] .pos Context.ensureDeclareable fieldName =
    anEnum .enumType i newEnumEntry context .elements fieldName HashMap.put drop
    i 1 + i =
  }
}
RootContext.declareTuple proc( #+context+# RootContext #+tuple+# Tuple => ){
  Tuple aTuple =:
  aTuple .tupleType .name string name mut =:
  RootContext context =:
  context name DeclareableType .TUPLE aTuple .pos Context.ensureDeclareable name =
  aTuple context .elements name HashMap.put drop
}

TokenType enum{
  WORD
  KEY_WORD
  PROCEDURE_START
  ENUM_START
  VALUE
  IDENTIFIER
  VARIABLE
  OPERATOR
  BLOCK_TOKEN
  CONTEXT_OPEN
  CONTEXT_CLOSE
}
Token struct{
  TokenType    :tokenType
  FilePosition :pos
}

WordToken struct{ Token extend
  string :value
}

ValueToken struct{ Token extend
  Value :value
}

BlockTokenType enum{ IF ELSE _IF END-IF WHILE DO END-WHILE DO-WHILE SWITCH CASE END-CASE DEFAULT END-SWITCH }
BlockToken struct{ Token extend
  BlockTokenType :blockType
  int            :target    mut
}

ContextToken struct{ Token extend
  Context :context
}
ContextToken.varCount proc( ContextToken => int ){ .context .varCount }

IdentifierType enum{
  WRITE
  DECLARE
  CONST_DECLARE
  ADDRESS_OF
}
IdentifierToken struct{ Token extend
  IdentifierType :idType
  string         :value
}

OperatorType enum{
  PLUS MINUS NEGATE INVERT MULTIPLY DIVIDE MOD
  NOT FLIP AND OR XOR  SHIFT_L SHIFT_R
  LT LE EQ REF_EQ REF_NE NE GE GT
}
OperatorToken struct{ Token extend
  OperatorType :opType
}

AccessType enum{
  DECLARE_CONST DECLARE_VAR WRITE_VAR READ_VAR
}
VariableToken struct{ Token extend
  AccessType :accessType
  VariableId :id
}

<< proc( string mut Token => string mut ){
  Token token =:

  TokenType .fieldNames token .tokenType [] <<* ": " <<*
  token .tokenType switch{
  WORD KEY_WORD PROCEDURE_START ENUM_START case
    token WordToken cast .value <<*
    end-case
  VALUE case
    token ValueToken cast .value <<
    end-case
  BLOCK_TOKEN case
    BlockTokenType .fieldNames token BlockToken cast .blockType [] <<* '(' << token BlockToken cast .target stringValue <<* ')' <<
    end-case
  IDENTIFIER case
    IdentifierType .fieldNames token IdentifierToken cast .idType [] <<* ": " <<* token IdentifierToken cast .value <<*
    end-case
  OPERATOR case
    OperatorType .fieldNames token OperatorToken cast .opType [] <<*
    end-case
  VARIABLE case
    AccessType .fieldNames token VariableToken cast .accessType [] <<* " " <<*
    token VariableToken cast .id << " " <<*
    end-case
  CONTEXT_CLOSE case end-case
  CONTEXT_OPEN case
    token ContextToken.varCount stringValue <<*
    end-case
  }
}

ParserReader struct{
  BufferedInput :in
  FilePosition  :pos
  string mut    :word
  FilePosition  :wordPos
}
ParserReader.nextWord proc( ParserReader => ){
  ParserReader reader =:
  reader .word clear
  reader .pos .line       reader .wordPos .line =
  reader .pos .posInLine  reader .wordPos .posInLine =
}
ParserReader.nextByte proc( ParserReader => byte optional ){
  ParserReader reader =:
  reader .in BufferedInput.nextByte byte optional next =:
  next if{
    '\n' == if{
      reader .pos FilePosition.newLine
    else
      reader .pos FilePosition.nextChar
    }
  }
  next return
}

ParseState enum{
  STATE_WORD
  STATE_STRING
  STATE_USTRING
  STATE_CHAR
  STATE_UCHAR
  STATE_COMMENT
  STATE_LINE_COMMENT
}

OpenBlocks struct{
  Macro              :currentMacro mut
  CodeBlock list mut :blocks
}
Program struct{
  Token list mut :tokens
  Context        :context mut
}

parseWord proc( #+word+# string mut? #+next+# string mut? #+pos+# FilePosition #+open_blocks+# OpenBlocks
  #+program+# Program => ){
  Program program =:
  program .context Context context mut =:
  program .tokens tokens =::
  OpenBlocks openBlocks =:
  FilePosition fPos =:
  string       next =:
  string       word =:
  word .length 0 > if{
    openBlocks .currentMacro .name .length 0 > if{
      word switch{
      "#end" case
        context openBlocks .currentMacro RootContext.declareMacro
        fPos "" newMacro  openBlocks .currentMacro =
        end-case
      "#define" "#undef" "#namespace" "#include" "#import" "proc" "procedure" "enum" "tuple" case
        word clone " is not allowed in macros " <<* fPos << '\n' << eputs
        1 exit
        end-case
      default
        openBlocks .currentMacro .words word fPos NameWithPos new << drop
      }
      return
    }
    ##keywords that consume one or more words
    word switch{
    ## identifier - modifiers
    "."  case
      tokens .length 2 < if{
        "not enough arguments for . " clone fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 2 - [] Token prePrev =:
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for '.' modifier: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      prePrev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for '.' modifier: " <<* prePrev << ' ' << prePrev .pos << '\n' << eputs
        1 exit
      }
      TokenType .WORD fPos prePrev WordToken cast .value clone '\'' << prev WordToken cast .value <<* mut~ WordToken new
       tokens tokens .length 2 - []=
      tokens tokens .length 1 - tokens .length [:] clear
      end-case
    "="  case
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for '=' modifier: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .WRITE prev WordToken cast .value IdentifierToken new  tokens tokens .length 1 - []=
      end-case
    "=:" case
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for '=:' modifier: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .DECLARE prev WordToken cast .value IdentifierToken new  tokens tokens .length 1 - []=
      end-case
    "=$" case
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for '=$' modifier: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .CONST_DECLARE prev WordToken cast .value IdentifierToken new
        tokens tokens .length 1 - []=
      end-case
    "@()" case
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for '@()' modifier: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .ADDRESS_OF prev WordToken cast .value IdentifierToken new
        tokens tokens .length 1 - []=
      end-case
    ## macro&namespace key-words
    "#define" case
      tokens .length 0 == if{
        32 string mut new
        "missing macro name " <<* fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for macro name: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      prev WordToken cast .value  openBlocks .currentMacro .name =
      prev .pos        openBlocks .currentMacro .pos =
      end-case
    "#undef" case
      openBlocks .blocks .length 0 > if{
        64 string mut new
        "macros can only be undefined at root-level " <<* fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token preceding #undef: " <<* prev << ' ' << prev .pos <<
        " expected macro-name \n" <<* eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken cast .value fPos RootContext.removeMacro
      end-case
    "#namespace" case
      openBlocks .blocks .length 0 > if{
        64 string mut new
        "namespaces can only be declared at root-level " <<* fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for namespace name: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken cast .value fPos RootContext.startModule
      end-case
    "#end" case
      openBlocks .blocks .length 0 > if{
        64 string mut new
        "namespaces can only be closed at root-level " <<* fPos << '\n' << eputs
        1 exit
      }
      END_OF_SECTION "" fPos openBlocks program parseWord
      context fPos RootContext.endModule
      end-case
    "#import" case
      openBlocks .blocks .length 0 > if{
        64 string mut new
        "imports  are can only allowed at root-level " <<* fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "imported namespace name has to be an identifier, got " <<*
           prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken cast .value fPos RootContext.addImport
      end-case
    "#include" case
      "unimplemented\n" eputs
      1 exit
      end-case
    ## proc/enum key-words
    "proc" "procedure" case
      tokens .length 0 == if{
        64 string mut new
        "missing procedure name " <<* fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for procedure name: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      TokenType .PROCEDURE_START fPos prev WordToken cast .value WordToken new  tokens tokens .length 1 - []=
      openBlocks .blocks BlockType .PROC_BLOCK fPos tokens .length CodeBlock new << drop
      end-case
    "enum" case
      tokens .length 0 == if{
        64 string mut new
        "missing enum name " <<* fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for enum name: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      openBlocks .blocks prev WordToken cast .value fPos tokens .length newEnumBlock << drop
      end-case
    "tuple" case
      tokens .length 0 == if{
        64 string mut new
        "missing tuple name " <<* fPos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token prev =:
      prev .tokenType TokenType .WORD != if{
        64 string mut new
        "invalid token for tuple name: " <<* prev << ' ' << prev .pos << '\n' << eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      openBlocks .blocks prev WordToken cast .value fPos tokens .length newTupleBlock << drop
      end-case
    default
      tokens .length 0 > &&{ next "." != } if{
        tokens tokens .length 1 - [] Token prev =:
        prev .tokenType TokenType .IDENTIFIER == if{
          prev IdentifierToken cast .idType switch{
          DECLARE CONST_DECLARE case
            context
            prev IdentifierToken cast .value
            prev IdentifierToken cast .idType IdentifierType .DECLARE !=
            prev .pos
            Context.declareVariable VariableId id =:
            prev IdentifierToken cast .idType IdentifierType .DECLARE != if{
              AccessType .DECLARE_VAR else AccessType .DECLARE_CONST } AccessType aType =:
            TokenType .VARIABLE prev .pos aType id VariableToken new
              tokens tokens .length 1 - []=
            end-case
          WRITE case
            context prev IdentifierToken cast .value Context.getDeclareable if{
              Declareable d =:
              d .dType DeclareableType .VARIABLE_ID != if{
                64 string mut new
                false d .dType <<DeclareableType " " <<* prev IdentifierToken cast .value <<*
                " (declared at " <<* d .pos << ") is not a variable" <<*
                fPos << '\n' << eputs
                1 exit
              }
              ##context.wrapCurried(identifier.name,id,identifier.pos);
              TokenType .VARIABLE prev .pos AccessType .WRITE_VAR d VariableToken new
                tokens tokens .length 1 - []=
            else
              64 string mut new
              "variable " <<* prev IdentifierToken cast .value <<* " does not exist " <<* fPos << '\n' << eputs
              1 exit
            }
            end-case
          ADDRESS_OF case
            "unimplemented\n" eputs
            1 exit
            end-case
          }
        else  prev .tokenType TokenType .WORD == if
          context prev WordToken cast .value Context.getDeclareable if{
            Declareable d =:
            d .dType switch{
            MACRO case
              d Macro m =:
              tokens tokens .length 1 - tokens .length [:] clear ##remove prev
              0 int i mut =:
              while{ i m .words .length < do
                m .words i [] NameWithPos s =:
                i 1 + m .words .length < if{ m .words i 1 + [] .name else "##" } string nxt =:
                s .name nxt prev .pos openBlocks program parseWord
                i 1 + i =
              }
              ## update identifiers at end of macro
              END_OF_SECTION next prev .pos openBlocks program parseWord
              end-case
            ENUM case
              TokenType .VALUE fPos d Enum cast .enumType Value.ofType ValueToken new
                tokens tokens .length 1 - []=
              end-case
            ENUM_ENTRY case
              TokenType .VALUE fPos d EnumEntry cast .enumType d Value new ValueToken new
                tokens tokens .length 1 - []=
              end-case
            TUPLE case
              TokenType .VALUE fPos d Tuple cast .tupleType Value.ofType ValueToken new
                tokens tokens .length 1 - []=
              end-case
            FINAL_VARIABLE VARIABLE_ID case
              ##id=context.wrapCurried(identifier.name,id,identifier.pos);
              TokenType .VARIABLE prev .pos AccessType .READ_VAR d VariableToken new
                tokens tokens .length 1 - []=
            end-case
            PREDECLARED_PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            }
          else
          }
        }
      }
      ## try parsing as integer
      0 int off mut =:
      ## detect signs
      false bool sgn mut =:
           word 0 [] '-' ==  if{
        true sgn =
        off 1 + off =
      else word 0 [] '+' == if
        off 1 + off =
      }
      10 int base mut =:
      ##detect base modifiers
      word .length off - 3 > if{
             word off off 2 + [:] "0b" ==  if{
          2 base =
          off 2 + off =
        else word off off 2 + [:] "0x" == if
          16 base =
          off 2 + off =
        }
      }
      off word .length < &&{ word off [] base valueOfDigit 0 >= } if{ ##number starts with digit after prefixes
        word word .length 1 - [] 'u' == ||{ word word .length 1 - [] 'U' == } if{ ##unsigned
          word off word .length 1 - [:] base false stringToInt switch{
          ERR_NONE case
            sgn if{ -_ } uint val =:
            tokens TokenType .VALUE fPos val Value.ofUInt ValueToken new << tokens =
            return
            end-case
          ERR_OVERFLOW case
            64 string mut new
            "value does not fit in an unsigned int: \"" <<* word <<* "\" " <<*
                fPos << '\n' << eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          }
        else
          word off word .length [:] base true stringToInt switch{
          ERR_NONE case
              sgn if{ -_ } int val =:
              tokens TokenType .VALUE fPos val Value.ofInt ValueToken new << tokens =
              return
            end-case
          ERR_OVERFLOW case
            64 string mut new
            "value does not fit in a signed int: \"" <<* word <<* "\" " <<*
                fPos << '\n' << eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          }
          word off word .length [:] base stringToFloat StringParseError .ERR_NONE == if{
            sgn if{ -_ } float val =:
            tokens TokenType .VALUE fPos val Value.ofFloat ValueToken new << tokens =
            return
          else
            drop
          }
        }
      }
      ## end integer parsing
      ##constants, operators and remaining keywords
      word switch{
      END_OF_SECTION case
        ##do nothing
        end-case
      ## detect true and false
      "true" case
        tokens TokenType .VALUE fPos Value.TRUE  ValueToken new << tokens =
        end-case
      "false" case
        tokens TokenType .VALUE fPos Value.FALSE ValueToken new << tokens =
        end-case
      ## detect primitive type-names
      "bool" case
        tokens TokenType .VALUE fPos Type.BOOL Value.ofType ValueToken new << tokens =
        end-case
      "byte" case
        tokens TokenType .VALUE fPos Type.BYTE Value.ofType ValueToken new << tokens =
        end-case
      "codepoint" case
        tokens TokenType .VALUE fPos Type.CODEPOINT Value.ofType ValueToken new << tokens =
        end-case
      "int" case
        tokens TokenType .VALUE fPos Type.INT  Value.ofType ValueToken new << tokens =
        end-case
      "uint" case
        tokens TokenType .VALUE fPos Type.UINT Value.ofType ValueToken new << tokens =
        end-case
      "float" case
        tokens TokenType .VALUE fPos Type.FLOAT Value.ofType ValueToken new << tokens =
        end-case
      "type" case
        tokens TokenType .VALUE fPos Type.TYPE Value.ofType ValueToken new << tokens =
        end-case
      "var" case
        tokens TokenType .VALUE fPos Type.VAR Value.ofType ValueToken new << tokens =
        end-case
      ## control-flow key-words
      "lambda" "λ" case
        openBlocks .blocks BlockType .PROC_BLOCK fPos tokens .length CodeBlock new << drop
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "return" "exit" case
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "=>" ":" case
        openBlocks .blocks .length 0 == if{
          64 string mut new
          word <<* " can only be used in (lambda-)procedures " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock block =:
        block .blockType BlockType .PROC_BLOCK != if{
          64 string mut new
          word <<* " can only be used in (lambda-)procedures " <<* fPos << '\n' << eputs
          1 exit
        }
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "while" case
        openBlocks .blocks  fPos tokens .length newWhileBlock  << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .WHILE 0 BlockToken new << tokens =
        end-case
      "do" case
        openBlocks .blocks .length 0 == if{
          64 string mut new
          word <<* " can only be used in while-statement " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock block =:
        block .blockType BlockType .WHILE_BLOCK != if{
          64 string mut new
          word <<* " can only be used in while-statement " <<* fPos << '\n' << eputs
          1 exit
        }
        block WhileBlock wBlock =:
        wBlock .forkPos -1 != if{
          128 string mut new
          "duplicate 'do' in while-statement " <<* fPos <<
          "\n previous appearance at " <<* tokens wBlock .forkPos [] .pos << '\n' << eputs
          1 exit
        }
        tokens .length wBlock .forkPos =
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .DO -1 BlockToken new << tokens =
        ##open while-context
        context newBlockContext context =
        context program .context =
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        end-case
      "if" case
        openBlocks .blocks  fPos tokens .length newIfBlock  << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .IF 0 BlockToken new << tokens =
        ##open if-context
        context newBlockContext context =
        context program .context =
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        end-case
      "else" case
        openBlocks .blocks .length 0 == if{
          64 string mut new
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock block =:
        block .blockType BlockType .IF_BLOCK != if{
          64 string mut new
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        block IfBlock iBlock =:
        iBlock .prevIf -1 == if{
          128 string mut new
          "unexpected 'else'-statement, 'else' can only appear after 'if' or '_if' " <<*
          fPos << '\n' << eputs
          1 exit
        }
        ##close if-context
        context BlockContext cast .parent context =
        context program .context =
        tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
        iBlock .else_positions .length 0 > if{
          ##close else-context
          tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
        }
        iBlock .else_positions tokens .length << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .ELSE -1 BlockToken new << tokens =
        tokens iBlock .prevIf [] Token tmp =:
        tmp .tokenType TokenType .BLOCK_TOKEN == &&{
          tmp BlockToken cast .blockType BlockTokenType .IF == ||{ tmp BlockToken cast .blockType BlockTokenType ._IF == } }
          "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
        tokens .length iBlock .prevIf - tmp BlockToken cast .target =
        -1 iBlock .prevIf =
        iBlock .else_positions .length 1 <= if{
          ##open else-context
          context newBlockContext context =
          context program .context =
          tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        }
        end-case
      "_if" case
        openBlocks .blocks .length 0 == if{
          64 string mut new
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock block =:
        block .blockType BlockType .IF_BLOCK != if{
          64 string mut new
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        block IfBlock iBlock =:
        iBlock .prevIf -1 != if{
          64 string mut new
          "unexpected '_if'-statement, '_if' can only appear after 'else' " <<*
            fPos << '\n' << eputs
          1 exit
        }
        tokens .length iBlock .prevIf =
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType ._IF 0 BlockToken new << tokens =
        ##open if-context
        context newBlockContext context =
        context program .context =
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken new << tokens =
        end-case
      "switch" case
        openBlocks .blocks BlockType .SWITCH_BLOCK fPos tokens .length CodeBlock new << drop
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "case" "end-case" "default" case
        openBlocks .blocks .length 0 == if{
          64 string mut new
          word <<* " can only be used in switch-blocks " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock block =:
        block .blockType BlockType .SWITCH_BLOCK != if{
          64 string mut new
          word <<* " can only be used in switch-blocks " <<*  fPos << '\n' << eputs
          1 exit
        }
        tokens TokenType .KEY_WORD fPos word WordToken new << tokens =
        end-case
      "end" case
        openBlocks .blocks .length 0 == if{
          64 string mut new
          "unexpected end-statement " <<* fPos << '\n' << eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock block =:
        openBlocks .blocks openBlocks .blocks .length 1 - openBlocks .blocks .length [:] clear
        block .blockType switch{
        IF_BLOCK case
          block IfBlock iBlock =:
          iBlock .prevIf -1 != if{
            ##close if-context
            context BlockContext cast .parent context =
            context program .context =
            tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
            tokens iBlock .prevIf [] Token tmp =:
            tmp .tokenType TokenType .BLOCK_TOKEN == &&{
              tmp BlockToken cast .blockType BlockTokenType .IF == ||{ tmp BlockToken cast .blockType BlockTokenType ._IF == } }
              "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
            tokens .length iBlock .prevIf - tmp BlockToken cast .target =
            iBlock .else_positions .length 0 > if{
              ## close-else context
              tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
            }
          else
            ## close-else context
            tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
          }
          0 int i mut =:
          while{ i iBlock .else_positions .length < do
            tokens iBlock .else_positions i [] [] Token tmp =:
            tmp .tokenType TokenType .BLOCK_TOKEN == &&{ tmp BlockToken cast .blockType BlockTokenType .ELSE == }
            "token at end of if-branch has to be BlockToken:'else'" assert
            tokens .length iBlock .else_positions i [] - tmp BlockToken cast .target =
            i 1 + i =
          }
          iBlock .else_positions .length 0 > if{
            ##close-else context
            context BlockContext cast .parent context =
            context program .context =
          }
          tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .END-IF 0 BlockToken new << tokens =
          end-case
        WHILE_BLOCK case
          block WhileBlock wBlock =:
          wBlock .forkPos -1 == if{
            64 string mut new
            "while block at " <<* wBlock .startPos << " does not contain a 'do' statement " <<*
            fPos << eputs
            1 exit
          }
          ##close context
          context BlockContext cast .parent context =
          context program .context =
          tokens TokenType .CONTEXT_CLOSE fPos Token new << tokens =
          tokens wBlock .forkPos [] Token tmp =:
          tmp .tokenType TokenType .BLOCK_TOKEN == &&{ tmp BlockToken cast .blockType BlockTokenType .DO == }
            "token at fork-pos of While has to be BlockToken:'do'" assert
          wBlock .forkPos tokens .length 3 - == if{ ## do context-open context-close end
            tokens tokens .length 2 - tokens .length [:] clear ##remove context open/close
            TokenType .BLOCK_TOKEN fPos BlockTokenType .DO-WHILE wBlock .start tokens .length 1 - - BlockToken new
              tokens wBlock .forkPos []=
          else
            tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .END-WHILE
              wBlock .start tokens .length - BlockToken new << tokens =
            tokens .length wBlock .forkPos - tmp BlockToken cast .target =
          }
          end-case
        SWITCH_BLOCK case
          "Waring closing switch-blocks is currently not implemented\n" eputs
          end-case
        PROC_BLOCK case
          "Waring closing proc-blocks is currently not implemented\n" eputs
          end-case
        ENUM_BLOCK case
          tokens .length block .start > if{
            64 string mut new
            "Invalid token in enum: " <<* tokens block .start [] << ' '
              << tokens block .start [] .pos << '\n' << eputs
            1 exit
          }
          context block RootContext.declareEnum
          end-case
        TUPLE_BLOCK case
          block TupleBlock tBlock =:
          tokens tBlock .start tokens .length [:] subList =::
          subList constEvaluate values =::
          subList clear
          values .length Type list mut new types =::
          0 int i mut =:
          while{ i values .length < do
            values i [] .tokenType TokenType .VALUE != if{
              128 string mut new
              "tokens of type:" <<* TokenType .fieldNames values i [] .tokenType [] <<* " are not allowed in tuple signatures " <<*
              values i [] .pos << '\n' << eputs
              1 exit
            else values i [] ValueToken cast .value .valType Type.TYPE != if
              128 string mut new
              "values of type:" <<* values i [] ValueToken cast .value .valType << " are not allowed in tuple signatures " <<*
              values i [] .pos << '\n' << eputs
              1 exit
            }
             types values i [] ValueToken cast .value .data Type cast << types =
             i 1 + i =
          }
          values clear
          context
          DeclareableType .TUPLE  tBlock .startPos   tBlock .name  types newTupleType   Tuple new
          RootContext.declareTuple
          end-case
        }
        end-case
      ## operators
      "+" case
        tokens TokenType .OPERATOR fPos OperatorType .PLUS OperatorToken new << tokens =
        end-case
      "-" case
        tokens TokenType .OPERATOR fPos OperatorType .MINUS OperatorToken new << tokens =
        end-case
      "-_" case
        tokens TokenType .OPERATOR fPos OperatorType .NEGATE OperatorToken new << tokens =
        end-case
      "*" case
        tokens TokenType .OPERATOR fPos OperatorType .MULTIPLY OperatorToken new << tokens =
        end-case
      "/" case
        tokens TokenType .OPERATOR fPos OperatorType .DIVIDE OperatorToken new << tokens =
        end-case
      "%" case
        tokens TokenType .OPERATOR fPos OperatorType .MOD OperatorToken new << tokens =
        end-case

      "!" case
        tokens TokenType .OPERATOR fPos OperatorType .NOT OperatorToken new << tokens =
        end-case
      "~" case
        tokens TokenType .OPERATOR fPos OperatorType .FLIP OperatorToken new << tokens =
        end-case
      "&" case
        tokens TokenType .OPERATOR fPos OperatorType .AND OperatorToken new << tokens =
        end-case
      "|" case
        tokens TokenType .OPERATOR fPos OperatorType .OR OperatorToken new << tokens =
        end-case
      "xor" case
        tokens TokenType .OPERATOR fPos OperatorType .XOR OperatorToken new << tokens =
        end-case

      "<<" case
        tokens TokenType .OPERATOR fPos OperatorType .SHIFT_L OperatorToken new << tokens =
        end-case
      ">>" case
        tokens TokenType .OPERATOR fPos OperatorType .SHIFT_R OperatorToken new << tokens =
        end-case

      "<" case
        tokens TokenType .OPERATOR fPos OperatorType .LT OperatorToken new << tokens =
        end-case
      "<=" case
        tokens TokenType .OPERATOR fPos OperatorType .LE OperatorToken new << tokens =
        end-case
      "==" case
        tokens TokenType .OPERATOR fPos OperatorType .EQ OperatorToken new << tokens =
        end-case
      "===" case
        tokens TokenType .OPERATOR fPos OperatorType .REF_EQ OperatorToken new << tokens =
        end-case
      "=!=" case
        tokens TokenType .OPERATOR fPos OperatorType .REF_NE OperatorToken new << tokens =
        end-case
      "!=" case
        tokens TokenType .OPERATOR fPos OperatorType .NE OperatorToken new << tokens =
        end-case
      ">=" case
        tokens TokenType .OPERATOR fPos OperatorType .GE OperatorToken new << tokens =
        end-case
      ">" case
        tokens TokenType .OPERATOR fPos OperatorType .GT OperatorToken new << tokens =
        end-case
      default
        openBlocks .blocks .length 0 >
          &&{ openBlocks .blocks openBlocks .blocks .length 1 - [] .blockType BlockType .ENUM_BLOCK == } if{
          openBlocks .blocks openBlocks .blocks .length 1 - []
            EnumBlock cast .elements word fPos NameWithPos new << drop
        else
          tokens TokenType .WORD fPos word WordToken new << tokens =
        }
      }
    }
  }
}

readEscapeChar proc( ParserReader => ){
  ParserReader reader =:
  reader ParserReader.nextByte if{
    byte next =:
    next switch{
    '\\' '\'' '"' case
     reader .word next << drop
     end-case
    'n' case
     reader .word '\n' << drop
     end-case
    't' case
     reader .word '\t' << drop
     end-case
    'r' case
     reader .word '\r' << drop
     end-case
    'b' case
     reader .word '\b' << drop
     end-case
    'f' case
     reader .word '\f' << drop
     end-case
    '0' case
     reader .word '\0' << drop
     end-case
    'u' 'U' case
     "\\u is currently unimplemented" eputs
     1 exit
     end-case
    default
     64 string mut new
     "The escape sequence: '\\" <<* next << "' is not supported " <<* reader .pos << '\n' << eputs
     1 exit
    }
  else
    64 string mut new
    "unexpected end of file " <<* reader .pos << '\n' << eputs
    1 exit
  }
}

parseFile proc( #+fileName+# string #+program+# Program =>  ){
  Program program =:
  program .context Context context =:
  program .tokens tokens =::
  string fileName =:
  fileName "r" open if{ #+auto-unwrap+# else
    20 fileName .length + string mut new
    "file \"" <<* fileName <<* "\" not found\n" <<* eputs
    1 exit
  }
  16 newBufferedInput #+input+#
  fileName 1 1 FilePosition new       #+pos+#
  16 string mut new                   #+word+#
  fileName 1 1 FilePosition new       #+wordPos+#
  ParserReader new ParserReader reader =:
  context RootContext.startFile
  ParseState .STATE_WORD ParseState state mut =:
  reader .pos "" newMacro 16 CodeBlock list mut new OpenBlocks new OpenBlocks openBlocks =:

  16 string mut new prevWord =::
  fileName 1 1 FilePosition new FilePosition prevPos mut =:

  while{ reader ParserReader.nextByte do
    #+next-char+#
    state switch{
      STATE_WORD case
        byte next mut =:
        next ?WhiteSpace if{
          reader .word .length 0 > if{
            reader .word clone nextWord =::
            nextWord .length 0 > if{
              prevWord .length 0 > if{
                prevWord nextWord prevPos openBlocks program parseWord
              }
              nextWord prevWord =
              reader .wordPos clone prevPos =
            }
          }
          reader ParserReader.nextWord
        else
          next switch{
          '"' case
              reader .word "u" == if{
                ParseState .STATE_USTRING state =
                reader .word clear
              else reader .word .length 0 == if
                ParseState .STATE_STRING state =
              else
                64 string mut new
                "illegal string-prefix: \"" <<* reader .word <<* "\" " <<*
                   reader .pos << '\n' << eputs
                1 exit
              }
            end-case
          '\'' case
              reader .word "u" == if{
                ParseState .STATE_UCHAR state =
                reader .word clear
              else reader .word .length 0 == if
                ParseState .STATE_CHAR state =
              else
                64 string mut new
                "illegal char-prefix: \"" <<* reader .word <<* "\" " <<*
                   reader .pos << '\n' << eputs
                1 exit
              }
            end-case
          '#' case
              reader ParserReader.nextByte if{
                next =
                next '#' == if{
                  reader .word clone nextWord =::
                  nextWord .length 0 > if{
                    prevWord .length 0 > if{
                      prevWord nextWord prevPos openBlocks program parseWord
                    }
                    nextWord prevWord =
                    reader .wordPos clone prevPos =
                  }
                  reader ParserReader.nextWord
                  ParseState .STATE_LINE_COMMENT state =
                else next '+' == if
                  reader .word clone nextWord =::
                  nextWord .length 0 > if{
                    prevWord .length 0 > if{
                      prevWord nextWord prevPos openBlocks program parseWord
                    }
                    nextWord prevWord =
                    reader .wordPos clone prevPos =
                  }
                  reader ParserReader.nextWord
                  ParseState .STATE_COMMENT state =
                else
                  reader .word '#' << next << drop
                }
              else
                reader .word '#' << drop
              }
            end-case
          default
            reader .word next << drop
          }
        }
      end-case
      STATE_STRING STATE_USTRING case
        byte next =:
        next '"' == if{
          prevWord .length 0 > if{
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            prevWord clear
          }
          tokens
            TokenType .VALUE reader .wordPos clone
            state ParseState .STATE_USTRING == if{
              reader .word codepoints mut~ Value.ofUString
            else
              reader .word mut~ Value.ofString
            }
          ValueToken new << tokens =
          reader ParserReader.nextWord
          ParseState .STATE_WORD state =
        else next '\\' == if
          reader readEscapeChar
        else
          reader .word next << drop
        }
      end-case
      STATE_CHAR STATE_UCHAR case
        byte next =:
        next '\'' == if{
          prevWord .length 0 > if{
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            prevWord clear
          }
          tokens
            TokenType .VALUE reader .wordPos clone
            state ParseState .STATE_UCHAR == if{
              reader .word codepoints
              dup .length 1 != if{
                reader .word " is not a valid unicode character " <<*
                reader .pos << '\n' <<
                eputs
                1 exit
              }
              #+chars+# 0 [] Value.ofCodepoint
            else
              reader .word clone
              dup .length 1 != if{
                #+str+# " is not a valid unicode character " <<*
                reader .pos << '\n' <<
                eputs
                1 exit
              }
              #+chars+# 0 [] Value.ofByte
            }
          ValueToken new << tokens =
          reader ParserReader.nextWord
          ParseState .STATE_WORD state =
        else next '\\' == if
          reader readEscapeChar
        else
          reader .word next << drop
        }
      end-case
      STATE_COMMENT case
        #+input-char+# '+' == if{
          reader ParserReader.nextByte if{
            '#' == if{
              ParseState .STATE_WORD state =
            }
          }
        }
      end-case
      STATE_LINE_COMMENT case
        #+input-char+# '\n' == if{
          ParseState .STATE_WORD state =
        }
      end-case
    }
  }

  state switch{
    STATE_WORD case
      reader .word clone nextWord =::
      prevWord .length 0 > if{
        prevWord nextWord prevPos openBlocks program parseWord
        prevWord clear
      }
      nextWord "" reader .wordPos clone openBlocks program parseWord
      END_OF_SECTION "" reader .wordPos clone openBlocks program parseWord
      reader ParserReader.nextWord
      end-case
    STATE_CHAR STATE_UCHAR case
      64 string mut new
     "unfinished char-literal " <<* reader .wordPos << '\n' <<
      eputs
      1 exit
      end-case
    STATE_STRING STATE_USTRING case
      64 string mut new
     "unfinished string-literal " <<* reader .wordPos << '\n' <<
      eputs
      1 exit
      end-case
    STATE_COMMENT case
      64 string mut new
     "unfinished comment " <<* reader .wordPos << '\n' <<
      eputs
      1 exit
      end-case
    STATE_LINE_COMMENT case
      ##do nothing
      end-case
  }
  context reader .wordPos RootContext.endFile
}

constEvaluate proc( Token list mut? => Token list mut ){
  tokens =::
  tokens .length Token list mut new res =::
  0 i =::
  while{ i tokens .length < do
    tokens i [] .tokenType switch{
      VALUE case
        res tokens i [] << res =
        end-case
      OPERATOR case
        tokens i [] OperatorToken cast .opType switch{
          PLUS
          MINUS
          NEGATE
          INVERT
          MULTIPLY
          DIVIDE
          MOD

          NOT
          FLIP
          AND
          OR
          XOR

          SHIFT_L
          SHIFT_R

          LT
          LE
          EQ
          REF_EQ
          REF_NE
          NE
          GE
          GT case
            128 string mut new
            "operators of type:" <<* OperatorType .fieldNames tokens i [] OperatorToken cast .opType [] <<*
            " are currently not supported in constant evaluation " <<*
            tokens i [] .pos << '\n' << eputs
            1 exit
            end-case
        }
        end-case
      WORD
      KEY_WORD
      PROCEDURE_START
      ENUM_START
      IDENTIFIER
      VARIABLE
      BLOCK_TOKEN
      CONTEXT_OPEN
      CONTEXT_CLOSE case
        128 string mut new
        "tokens of type:" <<* TokenType .fieldNames tokens i [] .tokenType [] <<*
        " are currently not supported in constant evaluation " <<*
        tokens i [] .pos << '\n' << eputs
        1 exit
      end-case
    }
    i 1 + i =
  }
  res return
}

main public proc( string list => ){
  string list args =:
  args .length 2 < if{
    "usage: <pathToFile> \n" puts ## "usage: <pathToFile> (-lib <libPath>)"
    0 exit
  }
  args 1 [] string mut? path mut =:
  path .length 0 > &&{ path 0 [] '.' == } if{ ##local path
    args 0 [] .length path .length + string mut new
    args 0 [] <<* path 1 path .length [:] <<* path =
  }

  16 Token list mut new tokens =::
  newRootContext RootContext context =:
  path tokens context Program new parseFile
  0 int i mut =:
  while{ i tokens .length < do
    tokens i [] Token token =:
    64 string mut new token << " " <<* token .pos << '\n' << puts
    i 1 + i =
  }
  "\n" puts
  "declared values:\n" puts
  context .elements ^_ for{
      string Declareable MapEntry e =:
      64 string mut new e .key <<s ": " <<* e .value << println
   } drop
}
