concat.concat :
## concat compiler written in concat
#+
this file is based on an outdated version of the interpreter
the compiler will be updated once the language is stabilized

the current version of the compiler is kept up to date as an example of a complex concat program
+#

## currently in early development phase

stack   #include
chars   #include
valueIO #include
utf8    #include
core    #import

hashMap #include
hashMap #import

bufferedIO #include
io #import


FilePosition tuple string uint uint end
FilePosition.fileName   proc FilePosition => string : 0 []   end
FilePosition.line       proc FilePosition => uint   : 1 []   end
FilePosition.line=      proc FilePosition uint =>   : 1 [] = end
FilePosition.posInLine  proc FilePosition => uint   : 2 []   end
FilePosition.posInLine= proc FilePosition uint =>   : 2 [] = end
FilePosition.newLine    proc FilePosition => :
  dup dup 1 [] 1 + 1 [] = 1 2 [] =
end
FilePosition.nextChar   proc FilePosition => :
  dup 2 [] 1 + 2 [] =
end
FilePosition.strAppend proc string FilePosition => string :
  FilePosition position =:
  string str =:
  str position FilePosition.fileName :+
  ':' :<< position FilePosition.line      <<i
  ':' :<< position FilePosition.posInLine <<i return
end

NameWithPos tuple string FilePosition end
NameWithPos.name proc NameWithPos => string       : 0 [] end
NameWithPos.pos  proc NameWithPos => FilePosition : 1 [] end

TypeType enum PRIMITIVE_TYPE TUPLE_TYPE ENUM_TYPE WRAPPER_TYPE end
Type tuple TypeType end
Type.type proc Type => TypeType : 0 [] end

PrimitiveType tuple TypeType type end
PrimitiveType.wrapped proc PrimitiveType => type : 1 [] end

TupleType tuple TypeType #+name+# string #+types+# Type list end
TupleType.name  proc TupleType => string    : 1 [] end
TupleType.types proc TupleType => Type list : 2 [] end
newTupleType proc #+name+# string #+types+# Type list => TupleType :
  Type list elements =:
  string name =:
  TypeType TUPLE_TYPE . name elements TupleType new return
end

EnumType tuple TypeType #+name+# string #+fields+# NameWithPos list end
EnumType.name   proc EnumType => string           : 1 [] end
EnumType.fields proc EnumType => NameWithPos list : 2 [] end
newEnumType proc #+name+# string #+fields+# NameWithPos list => EnumType :
  NameWithPos list fields =:
  string name =:
  TypeType ENUM_TYPE . name fields EnumType new return
end

WrapperTypeType enum LIST OPTIONAL VAR_ARGS end
WrapperType tuple TypeType WrapperTypeType Type end
WrapperType.wrapperType proc WrapperType => WrapperTypeType : 1 [] end
WrapperType.wrapped     proc WrapperType => Type            : 2 [] end

Type.strAppend proc string Type => string :
  Type t =:
  t Type.type switch
  PRIMITIVE_TYPE case
    t PrimitiveType.wrapped stringValue :+ return
    end-case
  WRAPPER_TYPE case
    t WrapperType.wrapped Type.strAppend
    t WrapperType.wrapperType switch
    LIST     case " list"     :+ return end-case
    OPTIONAL case " optional" :+ return end-case
    VAR_ARGS case " ..."      :+ return end-case
    end
    end-case
  TUPLE_TYPE case
    t TupleType.name :+ '[' :<<
    0 int i =:
    while i t TupleType.types length < do
      i 0 > if ", " :+ end
      t TupleType.types i [] Type.strAppend
      i 1 + i =
    end
    ']' :<<
    end-case
  ENUM_TYPE case
    t EnumType.name :+ '[' :<<
    0 int i =:
    while i t EnumType.fields length < do
      i 0 > if ", " :+ end
      t EnumType.fields i [] NameWithPos.name :+
      i 1 + i =
    end
    ']' :<<
    end-case
  end
end

TypeType PRIMITIVE_TYPE .      bool PrimitiveType new Type Type.BOOL      =$
TypeType PRIMITIVE_TYPE .      byte PrimitiveType new Type Type.BYTE      =$
TypeType PRIMITIVE_TYPE . codepoint PrimitiveType new Type Type.CODEPOINT =$
TypeType PRIMITIVE_TYPE .      uint PrimitiveType new Type Type.UINT      =$
TypeType PRIMITIVE_TYPE .       int PrimitiveType new Type Type.INT       =$
TypeType PRIMITIVE_TYPE .     float PrimitiveType new Type Type.FLOAT     =$
TypeType PRIMITIVE_TYPE .      type PrimitiveType new Type Type.TYPE      =$
TypeType PRIMITIVE_TYPE .       var PrimitiveType new Type Type.VAR       =$

TypeType WRAPPER_TYPE . WrapperTypeType LIST . Type.BYTE      WrapperType new Type Type.STRING  =$
TypeType WRAPPER_TYPE . WrapperTypeType LIST . Type.CODEPOINT WrapperType new Type Type.USTRING =$

Value tuple Type var end
Value.type proc Value => Type : 0 [] end
Value.data proc Value => var  : 1 [] end

Value.strAppend proc string Value => string :
  Value v =:
  v Value.type Type.strAppend ": " :+
  v Value.type Type.type switch
  PRIMITIVE_TYPE case
    v Value.type Type.TYPE == if
      v Value.data Type.strAppend
    else
      v Value.data stringValue :+
    end
    end-case
  ENUM_TYPE case
   '[' :<< v Value.data EnumEntry.index stringValue :+ ']' :<<
   end-case
  TUPLE_TYPE case
    "tuple-type unimplemented\n" eputs 1 exit
  end-case
  WRAPPER_TYPE case
    v Value.type Type.STRING == || v Value.type Type.USTRING == end if
      v Value.data stringValue :+
    else
      "wrapper-type unimplemented\n" eputs 1 exit
    end
  end-case
  end
end

Type.BOOL true  Value new Value Value.TRUE  =$
Type.BOOL false Value new Value Value.FALSE =$
Value.ofByte      proc byte       => Value : Type.BYTE      swap Value new return end
Value.ofCodepoint proc codepoint  => Value : Type.CODEPOINT swap Value new return end
Value.ofInt       proc int        => Value : Type.INT       swap Value new return end
Value.ofUInt      proc uint       => Value : Type.UINT      swap Value new return end
Value.ofFloat     proc float      => Value : Type.FLOAT     swap Value new return end
Value.ofType      proc Type       => Value : Type.TYPE      swap Value new return end
Value.ofString    proc string     => Value : Type.STRING    swap Value new return end
Value.ofUString   proc ustring    => Value : Type.USTRING   swap Value new return end

BlockType enum
  IF_BLOCK
  WHILE_BLOCK
  SWITCH_BLOCK
  PROC_BLOCK
  ENUM_BLOCK
  TUPLE_BLOCK
end
CodeBlock tuple #+type+# BlockType #+startPos+# FilePosition #+start+# int end
CodeBlock.type     proc CodeBlock => BlockType    : 0 [] end
CodeBlock.startPos proc CodeBlock => FilePosition : 1 [] end
CodeBlock.start    proc CodeBlock => int          : 2 [] end

WhileBlock tuple #+type+# BlockType #+startPos+# FilePosition #+start+# int #+forkPos+# int end
WhileBlock.forkPos  proc WhileBlock => int : 3 []   end
WhileBlock.forkPos= proc WhileBlock int => : 3 [] = end
newWhileBlock proc #+startPos+# FilePosition #+start+# int => WhileBlock :
  int start =:
  FilePosition startPos =:
  BlockType WHILE_BLOCK . startPos start -1 WhileBlock new return
end

IfBlock tuple  #+type+# BlockType #+startPos+# FilePosition #+start+# int #+prev_if+# int #+else_positions+# uint list end
IfBlock.prevIf         proc IfBlock => int      : 3 []   end
IfBlock.prevIf=        proc IfBlock int =>      : 3 [] = end
IfBlock.else_positions proc IfBlock => uint list : 4 []   end
newIfBlock proc #+startPos+# FilePosition #+start+# int => IfBlock :
  int start =:
  FilePosition startPos =:
  BlockType IF_BLOCK . startPos start start 16 int list new IfBlock new return
end

EnumBlock tuple #+type+# BlockType #+startPos+# FilePosition #+start+# int
  #+name+# string #+elements+# NameWithPos list end
EnumBlock.name     proc EnumBlock => string           : 3 [] end
EnumBlock.elements proc EnumBlock => NameWithPos list : 4 [] end
newEnumBlock proc #+name+# string #+startPos+# FilePosition #+start+# int => EnumBlock :
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType ENUM_BLOCK . startPos start name 16 NameWithPos list new EnumBlock new return
end
TupleBlock tuple #+type+# BlockType #+startPos+# FilePosition #+start+# int #+name+# string end
TupleBlock.name proc TupleBlock => string : 3 [] end
newTupleBlock proc #+name+# string #+startPos+# FilePosition #+start+# int => TupleBlock :
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType TUPLE_BLOCK . startPos start name TupleBlock new return
end



DeclareableType enum
  MACRO
  ENUM
  ENUM_ENTRY
  TUPLE
  VARIABLE_ID
  FINAL_VARIABLE
  PREDECLARED_PROCEDURE
  PROCEDURE
end
DeclareableType.strAppend proc #+str+# string #+a+# bool #+type+# DeclareableType => string :
   #+type+# switch
   MACRO case
     #+a+# if "a macro" else "macro" end :+ return
     end-case
   ENUM case
     #+a+# if "an enum" else "enum" end :+ return
     end-case
   ENUM_ENTRY case
     #+a+# if "an enum entry" else "enum entry" end :+ return
     end-case
   TUPLE case
     #+a+# if "a tuple" else "tuple" end :+ return
     end-case
   VARIABLE_ID case
     #+a+# if "a variable" else "variable" end :+ return
     end-case
   FINAL_VARIABLE case
     #+a+# if "a final variable" else "final variable" end :+ return
     end-case
   PREDECLARED_PROCEDURE case
     #+a+# if "a predeclared procedure" else "predeclared procedure" end :+ return
     end-case
   PROCEDURE case
     #+a+# if "a procedure" else "procedure" end :+ return
     end-case
   end
end

Declareable tuple #+type+# DeclareableType #+pos+# FilePosition end
Declareable.type proc Declareable => DeclareableType : 0 []   end
Declareable.pos  proc Declareable => FilePosition    : 1 []   end
Declareable.pos= proc Declareable FilePosition =>    : 1 [] = end

ContextType enum ROOT_CONTEXT PROC_CONTEXT BLOCK_CONTEXT end

Context tuple #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType end
Context.elements    proc Context => string Declareable HashMap : 0 [] end
Context.varCount    proc Context => int                        : 1 [] end
Context.type        proc Context => ContextType                : 2 [] end
Context.incVarCount proc Context => : dup 1 [] 1 + 1 [] = end

Macro tuple #+type+# DeclareableType #+pos+# FilePosition #+name+# string #+words+# NameWithPos list end
Macro.name  proc Macro => string           : 2 []   end
Macro.name= proc Macro string =>           : 2 [] = end
Macro.words proc Macro => NameWithPos list : 3 []   end
newMacro proc FilePosition string => Macro :
  string name =:
  FilePosition mPos =:
  DeclareableType MACRO . mPos name 16 NameWithPos list new Macro new return
end

VariableId tuple #+type+# DeclareableType #+pos+# FilePosition #+global+# bool #+level+# int #+varId+# int end
VariableId.global  proc VariableId => bool : 2 [] end
VariableId.level   proc VariableId => int  : 3 [] end
VariableId.varId   proc VariableId => int  : 4 [] end
VariableId.isConst proc VariableId => bool :
  Declareable.type DeclareableType FINAL_VARIABLE . ==
end

CurriedVariable tuple #+type+# DeclareableType #+pos+# FilePosition end ##TODO curried variable
PredeclaredProc tuple #+type+# DeclareableType #+pos+# FilePosition end ##TODO predeclared proc
Procedure tuple #+type+# DeclareableType #+pos+# FilePosition end ##TODO proc

Enum tuple #+type+# DeclareableType #+pos+# FilePosition #+enum-type+# EnumType end
Enum.enumType proc Enum => EnumType : 2 [] end
newEnum proc #+pos+# FilePosition #+name+# string #+fields+# NameWithPos list => Enum :
  #+fields+# #+name+# newEnumType EnumType enumType =:
  FilePosition fPos =:
  DeclareableType ENUM . fPos enumType Enum new return
end
EnumEntry tuple #+type+# DeclareableType #+pos+# FilePosition #+enum-type+# EnumType #+index+# int end
EnumEntry.enumType proc EnumEntry => EnumType : 2 [] end
EnumEntry.index proc EnumEntry => int : 3 [] end
newEnumEntry proc #+enumType+# EnumType #+index+# int => EnumEntry :
  int index =:
  EnumType enumType =:
  DeclareableType ENUM_ENTRY . enumType EnumType.fields index [] NameWithPos.pos enumType index EnumEntry new return
end

Tuple tuple #+type+# DeclareableType #+pos+# FilePosition #+tupleType+# TupleType end
Tuple.tupleType proc Tuple => TupleType : 2 [] end

VariableId.strAppend proc string VariableId => string :
  Declareable d =:
  d VariableId.global if "global:" else "local:" end :+
  d VariableId.level <<u ':' :<<
  d VariableId.varId <<u
  return
end
Declareable.strAppend proc string Declareable => string :
  Declareable d =:
  false d Declareable.type DeclareableType.strAppend ": " :+
  d Declareable.type switch
  MACRO case
    d Macro.name :+
    end-case
  ENUM case
    d Enum.enumType Type.strAppend
    end-case
  ENUM_ENTRY case
    d EnumEntry.enumType EnumType.name :+ '[' :<<
    d EnumEntry.index stringValue :+
    ']' :<<
    end-case
  TUPLE case
    d Tuple.tupleType Type.strAppend
    end-case
  FINAL_VARIABLE VARIABLE_ID case
    d VariableId.strAppend
    end-case
  PREDECLARED_PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  end
  " at " :+ d Declareable.pos FilePosition.strAppend return
end

OpenModule tuple #+path+# string list #+declaredAt+# FilePosition #+imports+# string list
  #+predeclared+# string PredeclaredProc HashMap end
OpenModule.path        proc OpenModule => string list                    : 0 [] end
OpenModule.declaredAt  proc OpenModule => FilePosition                   : 1 [] end
OpenModule.imports     proc OpenModule => string list                    : 2 [] end
OpenModule.predeclared proc OpenModule => string PredeclaredProc HashMap : 3 [] end
newOpenModule proc #+path+# string list #+declaredAt+# FilePosition => OpenModule :
  16 string list new 16 string PredeclaredProc newHashMap OpenModule new return
end
OpenModule.strAppend proc string OpenModule => string :
  OpenModule m =:
  string str =:
  0 int i =:
  str while i m OpenModule.path length < do
     m OpenModule.path i [] :+ "'" :+
  end
  " declared at " :+ m OpenModule.declaredAt FilePosition.strAppend return
end

OpenFile tuple #+global imports +# string list #+global predeclared+# string PredeclaredProc HashMap
    #+openModules+# OpenModule list end
OpenFile.globalImports     proc OpenFile => string list                    : 0 [] end
OpenFile.globalPredeclared proc OpenFile => string PredeclaredProc HashMap : 1 [] end
OpenFile.openModules       proc OpenFile => OpenModule list                : 2 [] end

newOpenFile proc => OpenFile :
  16 string list new
  16 string PredeclaredProc newHashMap
  16 OpenModule list new
  OpenFile new return
end

RootContext tuple #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType
    #+openFiles+# OpenFile list #+namespaces+# string bool HashMap end
RootContext.openFiles  proc RootContext => OpenFile list       : 3 [] end
RootContext.namespaces proc RootContext => string bool HashMap : 4 [] end
newRootContext proc => RootContext :
  16 string Declareable newHashMap
  0
  ContextType ROOT_CONTEXT .
  16 OpenFile list new
  16 string bool newHashMap
  RootContext new return
end

BlockContext tuple #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType #+parent+# Context end
BlockContext.parent proc BlockContext => Context : 3 [] end
newBlockContext proc #+parent+# Context => BlockContext :
  Context parent =:
  16 string Declareable newHashMap 0 ContextType BLOCK_CONTEXT . parent BlockContext new return
end

ProcContext tuple #+elements+# string Declareable HashMap #+varCount+# int #+contextType+# ContextType #+parent+# Context
   #+curried+# CurriedVariable list end
ProcContext.curried proc ProcContext => CurriedVariable list : 4 [] end

Context.isGlobal proc Context => bool :
  Context context =:
  context Context.type switch
  ROOT_CONTEXT case
    true return
    end-case
  PROC_CONTEXT case
    false return
    end-case
  BLOCK_CONTEXT case
    context BlockContext.parent Context.isGlobal return
    end-case
  end
end
Context.procContext proc Context => ProcContext optional :
  Context context =:
  context Context.type switch
  ROOT_CONTEXT case
    ProcContext empty return
    end-case
  PROC_CONTEXT case
    context ProcContext cast wrap return
    end-case
  BLOCK_CONTEXT case
    context BlockContext.parent Context.procContext return
    end-case
  end
end
Context.level proc Context => int :
  Context context =:
  context Context.type switch
  ROOT_CONTEXT PROC_CONTEXT case
    0 return
    end-case
  BLOCK_CONTEXT case
    context BlockContext.parent Context.level 1 + return
    end-case
  end
end
Context.ensureDeclareable proc #+context+# Context #+name+#string #+type+# DeclareableType #+pos+# FilePosition
  => #+localName+# string :
  FilePosition fPos =:
  DeclareableType dType =:
  string name =:
  Context context =:
  context Context.type ContextType ROOT_CONTEXT . == if context name RootContext.inCurrentModule else name end  string localName =:
  context Context.elements localName HashMap.get if
    Declareable prev =:
    ## procedures can overwrite predeclared procedures
    prev Declareable.type DeclareableType PREDECLARED_PROCEDURE . != || prev Declareable.type DeclareableType PROCEDURE . != end if
      "cannot declare " false dType DeclareableType.strAppend ' ' :<< name :+
      ", the identifier is already used by " :+ true prev Declareable.type DeclareableType.strAppend
      " (declared at " prev Declareable.pos FilePosition.strAppend ") at " :+ fPos FilePosition.strAppend '\n' :<< eputs
      1 exit
    end
  end
  context name Context.getDeclareable if
    Declareable shadowed =:
    "Warning: " false dType DeclareableType.strAppend " " :+ name :+
     " declared at " :+ fPos FilePosition.strAppend "\n     shadows existing " :+
     false shadowed Declareable.type DeclareableType.strAppend " declared at " :+
     shadowed Declareable.pos FilePosition.strAppend '\n' :<< eputs
  end
  localName return
end
Context.declareVariable proc #+context+# Context #+name+# string #+isConst+# bool #+pos+# FilePosition => VariableId :
    FilePosition fPos =:
    bool isConst =:
    string name =:
    Context context =:
    isConst if DeclareableType FINAL_VARIABLE . else DeclareableType VARIABLE_ID . end DeclareableType dType =:
    context name dType fPos Context.ensureDeclareable name =
    dType fPos context Context.isGlobal context Context.level context Context.varCount VariableId new VariableId varId =:
    context Context.incVarCount
    context Context.elements name varId HashMap.put drop
    varId return
end
Context.getDeclareable proc #+context+# Context #+name+# string => Declareable optional :
    string name =:
    Context context =:
    context Context.type switch
    ROOT_CONTEXT case
      context RootContext.currentPaths string list paths =:
      paths length 1 - int i =:
      while i 0 >= do ##go through all namespaces
        context Context.elements paths i [] clone name :+ HashMap.get ?? if
          #+element+# Declareable optional cast return
        else drop end
        i 1 - i =
      end
      context Context.elements name HashMap.get return
      end-case
    PROC_CONTEXT BLOCK_CONTEXT case
      context Context.elements name HashMap.get ?? if
        #+element+# Declareable optional cast return
      else drop
        context BlockContext.parent name Context.getDeclareable return
      end
      end-case
    end
end
MODULE_SEPARATOR #define '\'' #end
##token that signals the compiler, that there will be no more statements in the current code-section
END_OF_SECTION #define "##" #end
RootContext.startFile proc RootContext => :
  RootContext.openFiles newOpenFile :<< drop
end
RootContext.file proc RootContext => OpenFile :
  RootContext context =:
  context RootContext.openFiles context RootContext.openFiles length 1 - [] return
end

RootContext.inCurrentModule proc RootContext  #+name+# string => string :
   string name =:
   #+context+# RootContext.file OpenFile.openModules OpenModule list namespaces =:
   namespaces length 0 > if
    "" string path =:
     0 int i =:
     while i namespaces length < do
        namespaces i [] OpenModule.path string list paths =:
        0 int j =:
        while j paths length < do
          path paths j [] :+ MODULE_SEPARATOR :<< path =
          j 1 + j =
        end
        i 1 + i =
     end
     path name :+ return
   end
   name return
end
RootContext.startModule proc RootContext #+name+# string #+declaredAt+# FilePosition => :
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context Context.elements context name RootContext.inCurrentModule HashMap.get if
    Declareable d =:
    "cannot declare namespace " name :+ ", the identifier is already used by " :+
    true d Declareable.type DeclareableType.strAppend
    " (declared at " :+ d Declareable.pos FilePosition.strAppend ")\n at " :+
    fPos  FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
  context "" RootContext.inCurrentModule string fullPath =:
  16 string list new string list path =:
  "" string tmp =:
  0 int i =:
  while i name length < do
    fullPath name i [] :<< fullPath =
    name i [] MODULE_SEPARATOR == if
      context RootContext.namespaces fullPath clone true HashMap.put drop
      path tmp :<< path =
      "" tmp =
    else
      tmp name i [] :<< tmp =
    end
    i 1 + i =
  end
  path tmp :<< path =
  fullPath MODULE_SEPARATOR :<< fullPath =
  context RootContext.namespaces fullPath clone true HashMap.put drop
  context RootContext.file OpenFile.openModules path fPos newOpenModule :<< drop
end
RootContext.addImport proc RootContext #+name+# string #+declaredAt+# FilePosition => :
  FilePosition fPos =:
  string name0 =:
  name0 clone '\'' :<< string name =:
  RootContext context =:
  context RootContext.namespaces name HashMap.contains if
     context RootContext.file OpenFile file =:
     file OpenFile.openModules length 0 > if
         file OpenFile.openModules file OpenFile.openModules length 1 - [] OpenModule.imports name :<< drop
     else
         file OpenFile.globalImports name :<< drop
     end
  else context Context.elements name HashMap.get _if
    ##addLater static imports
    drop
    "static imports are currently unimplemented"
    1 exit
  else
    context RootContext.namespaces
    "namespace " name0 :+ " does not exist " :+ fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end
RootContext.endModule proc RootContext FilePosition => :
  FilePosition fPos =:
  RootContext context =:
  context RootContext.file OpenFile file =:
  file OpenFile.openModules length 0 == if
    "Unexpected End of namespace " fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
  file OpenFile.openModules file OpenFile.openModules length 1 - [] OpenModule removed =:
  file OpenFile.openModules file OpenFile.openModules length 1 - file OpenFile.openModules length [:] clear
  removed OpenModule.predeclared HashMap.size 0 > if
    "Syntax Error: missing variables/procedures" string message =:
    removed OpenModule.predeclared HashMap.itr while HashMapItr.next do
       string PredeclaredProc MapEntry e =:
       message "\n- " :+ e MapEntry.key string cast :+ " (at " :+ e MapEntry.value Declareable.pos FilePosition.strAppend ')' :<< drop
    end drop
    message fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end
RootContext.endFile proc RootContext FilePosition => :
  FilePosition fPos =:
  RootContext context =:
  context RootContext.openFiles context RootContext.openFiles length 1 - [] OpenFile closed =:
  context RootContext.openFiles context RootContext.openFiles length 1 - context RootContext.openFiles length [:] clear
  closed OpenFile.openModules length 0 > if
    "unclosed namespaces at end of File:\n" eputs
    closed OpenFile.openModules length 1 - int i =:
    while i 0 >= do
      closed OpenFile.openModules i [] OpenModule removed =:
      removed OpenModule.predeclared HashMap.size 0 > if
        "Syntax Error: missing variables/procedures" string message =:
        removed OpenModule.predeclared HashMap.itr while HashMapItr.next do
           string PredeclaredProc MapEntry e =:
           message "\n- " :+ e MapEntry.key string cast :+ " (at " :+ e MapEntry.value Declareable.pos FilePosition.strAppend ')' :<< drop
        end drop
        message fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      " - " removed OpenModule.strAppend '\n' :<< eputs
      i 1 - i =
    end
    closed OpenFile.openModules clear
  end
  closed OpenFile.globalPredeclared HashMap.size 0 > if
    "Syntax Error: missing variables/procedures" string message =:
    closed OpenFile.globalPredeclared HashMap.itr while HashMapItr.next do
       string PredeclaredProc MapEntry e =:
       message "\n- " :+ e MapEntry.key string cast :+ " (at " :+ e MapEntry.value Declareable.pos FilePosition.strAppend ')' :<< drop
    end drop
    message fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end

RootContext.currentPaths proc RootContext => string list :
  #+context+# RootContext.file OpenFile file =:
  file OpenFile.globalImports clone string list paths =:
  16 string new string path =:
  file OpenFile.openModules OpenModule list namespaces =:
  0 int i =:
  while i namespaces length < do
    namespaces i [] OpenModule.path string list mPath =:
    0 int j =:
    while j mPath length < do
      path mPath j [] :+ MODULE_SEPARATOR :<< path =
      j 1 + j =
      paths path clone :<< paths =
    end
    paths  namespaces i [] OpenModule.imports  paths length 1 - paths length 1 - [:] =
    i 1 + i =
  end
  paths return
end
RootContext.predeclared proc RootContext => string Declareable HashMap :
  #+context+# RootContext.file OpenFile file =:
  file OpenFile.openModules length 0 > if
    file OpenFile.openModules file OpenFile.openModules length 1 - [] OpenModule.predeclared return
  else
    file OpenFile.globalPredeclared return
  end
end

RootContext.declareProcedure proc #+context+# RootContext #+name+# string #+proc+# Procedure => :
  Procedure aProc =:
  string name =:
  RootContext context =:
  context name DeclareableType PROCEDURE . aProc Declareable.pos Context.ensureDeclareable name =
  context RootContext.predeclared name HashMap.remove ?? if
    ##TODO handle predeclared procedure
    drop
  else drop end
  context Context.elements name aProc HashMap.put drop
end
##addLater predeclareProcedure

RootContext.declareMacro proc #+context+# RootContext #+macro+# Macro => :
  Macro macro =:
  macro Macro.name string name =:
  RootContext context =:
  context name DeclareableType MACRO . macro Declareable.pos Context.ensureDeclareable name =
  context Context.elements name macro HashMap.put drop
end
RootContext.removeMacro proc #+context+# RootContext #+name+# string #+pos+# FilePosition => :
  FilePosition fPos =:
  string name =:
  RootContext context =:
  context Context.elements context name RootContext.inCurrentModule HashMap.remove if
    Declareable removed =:
    removed Declareable.type DeclareableType MACRO . != if
      "macro " name :+ " does not exists, or is shadowed by " :+
      false removed Declareable.type DeclareableType.strAppend
      " (declared at " :+ removed Declareable.pos FilePosition.strAppend ") "
      fPos FilePosition.strAppend '\n' :<< eputs
      1 exit
    end
  else
    "macro " name :+ " does not exists in the current namespace " :+ fPos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end
RootContext.declareEnum proc #+context+# RootContext #+source+# EnumBlock => :
  EnumBlock source =:
  source EnumBlock.name string name =:
  RootContext context =:
  source CodeBlock.startPos name source EnumBlock.elements newEnum Enum anEnum =:
  context name DeclareableType ENUM . anEnum Declareable.pos Context.ensureDeclareable name =
  context Context.elements name anEnum HashMap.put drop
  ##declare enum entries
  0 int i =:
  anEnum Enum.enumType EnumType.fields NameWithPos list fields =:
  while i fields length < do
    source EnumBlock.name clone MODULE_SEPARATOR :<< fields i [] NameWithPos.name :+ string fieldName =:
    context fieldName DeclareableType ENUM_ENTRY . fields i [] NameWithPos.pos Context.ensureDeclareable fieldName =
    context Context.elements fieldName anEnum Enum.enumType i newEnumEntry HashMap.put drop
    i 1 + i =
  end
end
RootContext.declareTuple proc #+context+# RootContext #+tuple+# Tuple => :
  Tuple aTuple =:
  aTuple Tuple.tupleType TupleType.name string name =:
  RootContext context =:
  context name DeclareableType TUPLE . aTuple Declareable.pos Context.ensureDeclareable name =
  context Context.elements name aTuple HashMap.put drop
end
##TODO RootContext.declareNativeProc
##TODO Context.wrapCurried


TokenType enum
  WORD
  KEY_WORD
  PROCEDURE_START
  ENUM_START
  VALUE
  IDENTIFIER
  VARIABLE
  OPERATOR
  BLOCK_TOKEN
  CONTEXT_OPEN
  CONTEXT_CLOSE
end
Token tuple TokenType FilePosition end
Token.type  proc Token => TokenType    : 0 [] end
Token.pos   proc Token => FilePosition : 1 [] end

WordToken tuple TokenType FilePosition string end
WordToken.value proc WordToken => string : 2 [] end

ValueToken tuple TokenType FilePosition Value end
ValueToken.value proc ValueToken => Value : 2 [] end

BlockTokenType enum IF ELSE _IF END-IF WHILE DO END-WHILE DO-WHILE SWITCH CASE END-CASE DEFAULT END-SWITCH end
BlockToken tuple TokenType FilePosition BlockTokenType int end
BlockToken.type    proc BlockToken => BlockTokenType : 2 []   end
BlockToken.target  proc BlockToken => int            : 3 []   end
BlockToken.target= proc BlockToken int =>            : 3 [] = end

ContextToken tuple TokenType FilePosition Context end
ContextToken.varCount proc ContextToken => int : 2 [] Context.varCount end

IdentifierType enum
  WRITE
  DECLARE
  CONST_DECLARE
  ADDRESS_OF
end
IdentifierToken tuple TokenType FilePosition IdentifierType string end
IdentifierToken.idType proc IdentifierToken => IdentifierType : 2 [] end
IdentifierToken.value  proc IdentifierToken => string         : 3 [] end

OperatorType enum
  PLUS MINUS NEGATE INVERT MULTIPLY DIVIDE MOD
  NOT FLIP AND OR XOR  SHIFT_L SHIFT_R
  LT LE EQ REF_EQ REF_NE NE GE GT
end
OperatorToken tuple TokenType FilePosition OperatorType end
OperatorToken.opType proc OperatorToken => OperatorType : 2 [] end

AccessType enum
  DECLARE_CONST DECLARE_VAR WRITE_VAR READ_VAR
end
VariableToken tuple TokenType FilePosition AccessType VariableId end
VariableToken.accessType proc VariableToken => AccessType : 2 [] end
VariableToken.id         proc VariableToken => VariableId : 3 [] end


Token.strAppend proc string Token => string :
  Token token =:

  TokenType type.fields token Token.type [] +: ": " +:
  token Token.type switch
  WORD KEY_WORD PROCEDURE_START ENUM_START case
    token WordToken.value :+
    end-case
  VALUE case
    token ValueToken.value Value.strAppend
    end-case
  BLOCK_TOKEN case
    BlockTokenType type.fields token BlockToken.type [] :+ '(' :<< token BlockToken.target stringValue :+ ')' :<<
    end-case
  IDENTIFIER case
    IdentifierType type.fields token IdentifierToken.idType [] :+ ": " :+ token IdentifierToken.value :+
    end-case
  OPERATOR case
    OperatorType type.fields token OperatorToken.opType [] :+
    end-case
  VARIABLE case
    AccessType type.fields token VariableToken.accessType [] :+ " " :+
    token VariableToken.id VariableId.strAppend " " :+
    end-case
  CONTEXT_CLOSE case end-case
  CONTEXT_OPEN case
    token ContextToken.varCount stringValue :+
    end-case
  end
end

ParserReader tuple BufferedInput FilePosition string FilePosition end
ParserReader.in       proc ParserReader => BufferedInput : 0 [] end
ParserReader.pos      proc ParserReader => FilePosition  : 1 [] end
ParserReader.word     proc ParserReader => string        : 2 [] end
ParserReader.wordPos  proc ParserReader => FilePosition  : 3 [] end
ParserReader.nextWord proc ParserReader => :
  ParserReader reader =:
  reader ParserReader.word clear
  reader ParserReader.wordPos  reader ParserReader.pos FilePosition.line       FilePosition.line=
  reader ParserReader.wordPos  reader ParserReader.pos FilePosition.posInLine  FilePosition.posInLine=
end
ParserReader.nextByte proc ParserReader => byte optional :
  ParserReader reader =:
  reader ParserReader.in BufferedInput.nextByte byte optional next =:
  next if
    '\n' == if
      reader ParserReader.pos FilePosition.newLine
    else
      reader ParserReader.pos FilePosition.nextChar
    end
  end
  next return
end

ParseState enum
  STATE_WORD
  STATE_STRING
  STATE_USTRING
  STATE_CHAR
  STATE_UCHAR
  STATE_COMMENT
  STATE_LINE_COMMENT
end

OpenBlocks tuple Macro CodeBlock list end
OpenBlocks.currentMacro  proc OpenBlocks => Macro          : 0 []   end
OpenBlocks.currentMacro= proc OpenBlocks Macro =>          : 0 [] = end
OpenBlocks.blocks        proc OpenBlocks => CodeBlock list : 1 []   end

Program tuple #+tokens+# Token list #+root-context+# Context end
Program.tokens   proc Program => Token list : 0 []   end
Program.context  proc Program => Context    : 1 []   end
Program.context= proc Program Context =>    : 1 [] = end


parseWord proc #+word+# string #+next+# string #+pos+# FilePosition #+open_blocks+# OpenBlocks
  #+program+# Program => :
  Program program =:
  program Program.context Context context =:
  program Program.tokens Token list tokens =:
  OpenBlocks openBlocks =:
  FilePosition fPos =:
  string       next =:
  string       word =:
  word length 0 > if
    openBlocks OpenBlocks.currentMacro Macro.name length 0 > if
      word switch
      "#end" case
        context openBlocks OpenBlocks.currentMacro RootContext.declareMacro
        openBlocks fPos "" newMacro OpenBlocks.currentMacro=
        end-case
      "#define" "#undef" "#namespace" "#include" "#import" "proc" "procedure" "enum" "tuple" case
        word " is not allowed in macros " :+ fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
        end-case
      default
        openBlocks OpenBlocks.currentMacro Macro.words word fPos NameWithPos new :<< drop
      end
      return
    end
    ##keywords that consume one or more words
    word switch
    ## identifier - modifiers
    "."  case
      tokens length 2 < if
        "not enough arguments for . " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 2 - [] Token prePrev =:
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '.' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      prePrev Token.type TokenType WORD . != if
        "invalid token for '.' modifier: " prePrev Token.strAppend ' ' :<< prePrev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType WORD . fPos prePrev WordToken.value '\'' :<< prev WordToken.value :+ WordToken new tokens length 2 - [] =
      tokens tokens length 1 - tokens length [:] clear
      end-case
    "="  case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos IdentifierType WRITE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "=:" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=:' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos IdentifierType DECLARE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "=$" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=$' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos
        IdentifierType CONST_DECLARE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "@()" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '@()' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos
        IdentifierType ADDRESS_OF . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    ## macro&namespace key-words
    "#define" case
      tokens length 0 == if
        "missing macro name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for macro name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.currentMacro prev WordToken.value Macro.name=
      openBlocks OpenBlocks.currentMacro prev Token.pos   Declareable.pos=
      end-case
    "#undef" case
      openBlocks OpenBlocks.blocks length 0 > if
        "macros can only be undefined at root-level " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token preceding #undef: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend
        " expected macro-name \n" :+ eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      context prev WordToken.value fPos RootContext.removeMacro
      end-case
    "#namespace" case
      openBlocks OpenBlocks.blocks length 0 > if
        "namespaces can only be declared at root-level " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for namespace name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      context prev WordToken.value fPos RootContext.startModule
      end-case
    "#end" case
      openBlocks OpenBlocks.blocks length 0 > if
        "namespaces can only be closed at root-level " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      END_OF_SECTION "" fPos openBlocks program parseWord
      context fPos RootContext.endModule
      end-case
    "#import" case
      openBlocks OpenBlocks.blocks length 0 > if
        "imports  are can only allowed at root-level " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "imported namespace name has to be an identifier, got "
           prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      context prev WordToken.value fPos RootContext.addImport
      end-case
    "#include" case
      "unimplemented\n" eputs
      1 exit
      end-case
    ## proc/enum key-words
    "proc" "procedure" case
      tokens length 0 == if
        "missing procedure name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for procedure name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType PROCEDURE_START . fPos prev WordToken.value WordToken new tokens length 1 - [] =
      openBlocks OpenBlocks.blocks BlockType PROC_BLOCK . fPos tokens length CodeBlock new :<< drop
      end-case
    "enum" case
      tokens length 0 == if
        "missing enum name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for enum name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.blocks prev WordToken.value fPos tokens length newEnumBlock :<< drop
      end-case
    "tuple" case
      tokens length 0 == if
        "missing tuple name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for tuple name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.blocks prev WordToken.value fPos tokens length newTupleBlock :<< drop
      end-case
    default
      tokens length 0 > && next "." != end if
        tokens tokens length 1 - [] Token prev =:
        prev Token.type TokenType IDENTIFIER . == if
          prev IdentifierToken.idType switch
          DECLARE CONST_DECLARE case
            context
            prev IdentifierToken.value
            prev IdentifierToken.idType IdentifierType DECLARE . !=
            prev Token.pos
            Context.declareVariable VariableId id =:
            prev IdentifierToken.idType IdentifierType DECLARE . != if
              AccessType DECLARE_VAR . else AccessType DECLARE_CONST . end AccessType aType =:
            tokens
            TokenType VARIABLE . prev Token.pos aType id VariableToken new
            tokens length 1 - [] =
            end-case
          WRITE case
            context prev IdentifierToken.value Context.getDeclareable if
              Declareable d =:
              d Declareable.type DeclareableType VARIABLE_ID . != if
                "" false d Declareable.type DeclareableType.strAppend " " :+ prev IdentifierToken.value :+
                " (declared at " :+ d Declareable.pos FilePosition.strAppend ") is not a variable" :+
                fPos FilePosition.strAppend '\n' :<< eputs
                1 exit
              end
              ##TODO check for curried variables
              ##context.wrapCurried(identifier.name,id,identifier.pos);
              tokens
              TokenType VARIABLE . prev Token.pos AccessType WRITE_VAR . d VariableToken new
              tokens length 1 - [] =
            else
              "variable " prev IdentifierToken.value :+ " does not exist " :+ fPos FilePosition.strAppend '\n' :<< eputs
              1 exit
            end
            end-case
          ADDRESS_OF case
            ##TODO address of
            "unimplemented\n" eputs
            1 exit
            end-case
          end
        else  prev Token.type TokenType WORD . == _if
          context prev WordToken.value Context.getDeclareable if
            Declareable d =:
            d Declareable.type switch
            MACRO case
              tokens tokens length 1 - tokens length [:] clear ##remove prev
              0 int i =:
              while i d Macro.words length < do
                d Macro.words i [] NameWithPos s =:
                i 1 + d Macro.words length < if d Macro.words i 1 + [] NameWithPos.name else "##" end string nxt =:
                ##addLater remember position in macro for file-position
                s NameWithPos.name nxt prev Token.pos openBlocks program parseWord
                i 1 + i =
              end
              ## update identifiers at end of macro
              END_OF_SECTION next prev Token.pos openBlocks program parseWord
              end-case
            ENUM case
              tokens
              TokenType VALUE . fPos d Enum.enumType Value.ofType ValueToken new
              tokens length 1 - [] =
              end-case
            ENUM_ENTRY case
              tokens
              TokenType VALUE . fPos d EnumEntry.enumType d Value new ValueToken new
              tokens length 1 - [] =
              end-case
            TUPLE case
              tokens
              TokenType VALUE . fPos d Tuple.tupleType Value.ofType ValueToken new
              tokens length 1 - [] =
              end-case
            FINAL_VARIABLE VARIABLE_ID case
              ##addLater wrap curried variables
              ##id=context.wrapCurried(identifier.name,id,identifier.pos);
              ##addLater pre-evaluate global constants
              tokens
              TokenType VARIABLE . prev Token.pos AccessType READ_VAR . d VariableToken new
              tokens length 1 - [] =
            end-case
            PREDECLARED_PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            end
          else
            ##TODO resolve missing declarable
          end
        end
      end
      ## try parsing as integer
      0 int off =:
      ## detect signs
      false bool sgn =:
           word 0 [] '-' ==  if
        true sgn =
        off 1 + off =
      else word 0 [] '+' == _if
        off 1 + off =
      end
      10 int base =:
      ##detect base modifiers
      word length off - 3 > if
             word off off 2 + [:] "0b" ==  if
          2 base =
          off 2 + off =
        else word off off 2 + [:] "0x" == _if
          16 base =
          off 2 + off =
        end
      end
      off word length < && word off [] base valueOfDigit 0 >= end if ##number starts with digit after prefixes
        word word length 1 - [] 'u' == || word word length 1 - [] 'U' == end if ##unsigned
          word off word length 1 - [:] base false stringToInt switch
          ERR_NONE case
            sgn if -_ end uint val =:
            tokens TokenType VALUE . fPos val Value.ofUInt ValueToken new :<< tokens =
            return
            end-case
          ERR_OVERFLOW case
            "value does not fit in an unsigned int: \"" word :+ "\" " :+
                fPos FilePosition.strAppend '\n' :<< eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          end
        else
          word off word length [:] base true stringToInt switch
          ERR_NONE case
              sgn if -_ end int val =:
              tokens TokenType VALUE . fPos val Value.ofInt ValueToken new :<< tokens =
              return
            end-case
          ERR_OVERFLOW case
            "value does not fit in a signed int: \"" word :+ "\" " :+
                fPos FilePosition.strAppend '\n' :<< eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          end
          word off word length [:] base stringToFloat StringParseError ERR_NONE . == if
            sgn if -_ end float val =:
            tokens TokenType VALUE . fPos val Value.ofFloat ValueToken new :<< tokens =
            return
          else
            drop
          end
        end
      end
      ## end integer parsing
      ##constants, operators and remaining keywords
      word switch
      END_OF_SECTION case
        ##do nothing
        end-case
      ## detect true and false
      "true" case
        tokens TokenType VALUE . fPos Value.TRUE  ValueToken new :<< tokens =
        end-case
      "false" case
        tokens TokenType VALUE . fPos Value.FALSE ValueToken new :<< tokens =
        end-case
      ## detect primitive type-names
      "bool" case
        tokens TokenType VALUE . fPos Type.BOOL Value.ofType ValueToken new :<< tokens =
        end-case
      "byte" case
        tokens TokenType VALUE . fPos Type.BYTE Value.ofType ValueToken new :<< tokens =
        end-case
      "codepoint" case
        tokens TokenType VALUE . fPos Type.CODEPOINT Value.ofType ValueToken new :<< tokens =
        end-case
      "int" case
        tokens TokenType VALUE . fPos Type.INT  Value.ofType ValueToken new :<< tokens =
        end-case
      "uint" case
        tokens TokenType VALUE . fPos Type.UINT Value.ofType ValueToken new :<< tokens =
        end-case
      "float" case
        tokens TokenType VALUE . fPos Type.FLOAT Value.ofType ValueToken new :<< tokens =
        end-case
      "type" case
        tokens TokenType VALUE . fPos Type.TYPE Value.ofType ValueToken new :<< tokens =
        end-case
      "var" case
        tokens TokenType VALUE . fPos Type.VAR Value.ofType ValueToken new :<< tokens =
        end-case
      ## control-flow key-words
      "lambda" "Î»" case
        openBlocks OpenBlocks.blocks BlockType PROC_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "return" "exit" case
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "=>" ":" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in (lambda-)procedures " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType PROC_BLOCK . != if
          word " can only be used in (lambda-)procedures " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        ##TODO update procedure-block
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "while" case
        openBlocks OpenBlocks.blocks  fPos tokens length newWhileBlock  :<< drop
        tokens TokenType BLOCK_TOKEN . fPos BlockTokenType WHILE . 0 BlockToken new :<< tokens =
        end-case
      "do" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in while-statement " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType PROC_BLOCK . != && block CodeBlock.type BlockType WHILE_BLOCK . != end if
          word " can only be used in while-statement " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        block WhileBlock.forkPos -1 != if
          "duplicate 'do' in while-statement " fPos FilePosition.strAppend
          "\n previous appearance at " :+ tokens block WhileBlock.forkPos [] Token.pos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        block tokens length WhileBlock.forkPos=
        tokens TokenType BLOCK_TOKEN . fPos BlockTokenType DO . -1 BlockToken new :<< tokens =
        ##open while-context
        context newBlockContext context =
        program context Program.context=
        tokens TokenType CONTEXT_OPEN . fPos context ContextToken new :<< tokens =
        end-case
      "if" case
        openBlocks OpenBlocks.blocks  fPos tokens length newIfBlock  :<< drop
        tokens TokenType BLOCK_TOKEN . fPos BlockTokenType IF . 0 BlockToken new :<< tokens =
        ##open if-context
        context newBlockContext context =
        program context Program.context=
        tokens TokenType CONTEXT_OPEN . fPos context ContextToken new :<< tokens =
        end-case
      "else" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in if-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType IF_BLOCK . != if
          word " can only be used in if-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        block IfBlock.prevIf -1 == if
          "unexpected 'else'-statement, 'else' can only appear after 'if' or '_if' "
            fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        ##close if-context
        context BlockContext.parent context =
        program context Program.context=
        tokens TokenType CONTEXT_CLOSE . fPos Token new :<< tokens =
        block IfBlock.else_positions length 0 > if
          ##close else-context
          tokens TokenType CONTEXT_CLOSE . fPos Token new :<< tokens =
        end
        block IfBlock.else_positions tokens length :<< drop
        tokens TokenType BLOCK_TOKEN . fPos BlockTokenType ELSE . -1 BlockToken new :<< tokens =
        tokens block IfBlock.prevIf [] Token tmp =:
        tmp Token.type TokenType BLOCK_TOKEN . == &&
          tmp BlockToken.type BlockTokenType IF . == || tmp BlockToken.type BlockTokenType _IF . == end end
          "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
        tmp tokens length block IfBlock.prevIf - BlockToken.target=
        block -1 IfBlock.prevIf=
        block IfBlock.else_positions length 1 <= if
          ##open else-context
          context newBlockContext context =
          program context Program.context=
          tokens TokenType CONTEXT_OPEN . fPos context ContextToken new :<< tokens =
        end
        end-case
      "_if" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in if-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType IF_BLOCK . != if
          word " can only be used in if-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        block IfBlock.prevIf -1 != if
          "unexpected '_if'-statement, '_if' can only appear after 'else' "
            fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        block tokens length IfBlock.prevIf=
        tokens TokenType BLOCK_TOKEN . fPos BlockTokenType _IF . 0 BlockToken new :<< tokens =
        ##open if-context
        context newBlockContext context =
        program context Program.context=
        tokens TokenType CONTEXT_OPEN . fPos context ContextToken new :<< tokens =
        end-case
      "switch" case
        openBlocks OpenBlocks.blocks BlockType SWITCH_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "case" "end-case" "default" case
        openBlocks OpenBlocks.blocks length 0 == if
          word " can only be used in switch-blocks " :+ fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        block CodeBlock.type BlockType SWITCH_BLOCK . != if
          word " can only be used in switch-blocks " :+  fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        ##TODO update switch-block
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "end" case
        openBlocks OpenBlocks.blocks length 0 == if
          "unexpected end-statement " fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - openBlocks OpenBlocks.blocks length [:] clear
        block CodeBlock.type switch
        IF_BLOCK case
          block IfBlock.prevIf -1 != if
            ##close if-context
            context BlockContext.parent context =
            program context Program.context=
            tokens TokenType CONTEXT_CLOSE . fPos Token new :<< tokens =
            tokens block IfBlock.prevIf [] Token tmp =:
            tmp Token.type TokenType BLOCK_TOKEN . == &&
              tmp BlockToken.type BlockTokenType IF . == || tmp BlockToken.type BlockTokenType _IF . == end end
              "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
            tmp tokens length block IfBlock.prevIf - BlockToken.target=
            block IfBlock.else_positions length 0 > if
              ## close-else context
              tokens TokenType CONTEXT_CLOSE . fPos Token new :<< tokens =
            end
          else
            ## close-else context
            tokens TokenType CONTEXT_CLOSE . fPos Token new :<< tokens =
          end
          0 int i =:
          while i block IfBlock.else_positions length < do
            tokens block IfBlock.else_positions i [] [] Token tmp =:
            tmp Token.type TokenType BLOCK_TOKEN . == && tmp BlockToken.type BlockTokenType ELSE . == end
            "token at end of if-branch has to be BlockToken:'else'" assert
            tmp tokens length block IfBlock.else_positions i [] - BlockToken.target=
            i 1 + i =
          end
          block IfBlock.else_positions length 0 > if
            ##close-else context
            context BlockContext.parent context =
            program context Program.context=
          end
          tokens TokenType BLOCK_TOKEN . fPos BlockTokenType END-IF . 0 BlockToken new :<< tokens =
          end-case
        WHILE_BLOCK case
          block WhileBlock.forkPos -1 == if
            "while block at " block CodeBlock.startPos FilePosition.strAppend " does not contain a 'do' statement " :+
            fPos FilePosition.strAppend eputs
            1 exit
          end
          ##close context
          context BlockContext.parent context =
          program context Program.context=
          tokens TokenType CONTEXT_CLOSE . fPos Token new :<< tokens =
          tokens block WhileBlock.forkPos [] Token tmp =:
          tmp Token.type TokenType BLOCK_TOKEN . == && tmp BlockToken.type BlockTokenType DO . == end
            "token at fork-pos of While has to be BlockToken:'do'" assert
          block WhileBlock.forkPos tokens length 3 - == if ## do context-open context-close end
            tokens tokens length 2 - tokens length [:] clear ##remove context open/close
            tokens TokenType BLOCK_TOKEN . fPos BlockTokenType DO-WHILE .
              block CodeBlock.start tokens length 1 - - BlockToken new
            block WhileBlock.forkPos [] =
          else
            tokens TokenType BLOCK_TOKEN . fPos BlockTokenType END-WHILE .
              block CodeBlock.start tokens length - BlockToken new :<< tokens =
            tmp tokens length block WhileBlock.forkPos - BlockToken.target=
          end
          end-case
        SWITCH_BLOCK case
          ## TODO close switch block
          "Waring closing switch-blocks is currently not implemented\n" eputs
          end-case
        PROC_BLOCK case
          ## TODO close proc block
          "Waring closing proc-blocks is currently not implemented\n" eputs
          end-case
        ENUM_BLOCK case
          tokens length block CodeBlock.start > if
            "Invalid token in enum: " tokens block CodeBlock.start [] Token.strAppend ' '
              :<< tokens block CodeBlock.start [] Token.pos FilePosition.strAppend '\n' :<< eputs
            1 exit
          end
          context block RootContext.declareEnum
          end-case
        TUPLE_BLOCK case
          tokens block CodeBlock.start tokens length [:] Token list subList =:
          subList constEvaluate Token list values =:
          subList clear
          values length Type list new Type list types =:
          0 int i =:
          while i values length < do
            values i [] Token.type TokenType VALUE . != if
              "tokens of type:" TokenType type.fields values i [] Token.type [] :+ " are not allowed in tuple signatures " :+
              values i [] Token.pos FilePosition.strAppend '\n' :<< eputs
              1 exit
            else values i [] ValueToken.value Value.type Type.TYPE != _if
              "values of type:" values i [] ValueToken.value Value.type Type.strAppend " are not allowed in tuple signatures " :+
              values i [] Token.pos FilePosition.strAppend '\n' :<< eputs
              1 exit
            end
             types values i [] ValueToken.value Value.data Type cast :<< types =
             i 1 + i =
          end
          values clear
          context
          DeclareableType TUPLE .  block CodeBlock.startPos   block TupleBlock.name  types newTupleType   Tuple new
          RootContext.declareTuple
          end-case
        end
        end-case
      ## operators
      "+" case
        tokens TokenType OPERATOR . fPos OperatorType PLUS . OperatorToken new :<< tokens =
        end-case
      "-" case
        tokens TokenType OPERATOR . fPos OperatorType MINUS . OperatorToken new :<< tokens =
        end-case
      "-_" case
        tokens TokenType OPERATOR . fPos OperatorType NEGATE . OperatorToken new :<< tokens =
        end-case
      "*" case
        tokens TokenType OPERATOR . fPos OperatorType MULTIPLY . OperatorToken new :<< tokens =
        end-case
      "/" case
        tokens TokenType OPERATOR . fPos OperatorType DIVIDE . OperatorToken new :<< tokens =
        end-case
      "%" case
        tokens TokenType OPERATOR . fPos OperatorType MOD . OperatorToken new :<< tokens =
        end-case

      "!" case
        tokens TokenType OPERATOR . fPos OperatorType NOT . OperatorToken new :<< tokens =
        end-case
      "~" case
        tokens TokenType OPERATOR . fPos OperatorType FLIP . OperatorToken new :<< tokens =
        end-case
      "&" case
        tokens TokenType OPERATOR . fPos OperatorType AND . OperatorToken new :<< tokens =
        end-case
      "|" case
        tokens TokenType OPERATOR . fPos OperatorType OR . OperatorToken new :<< tokens =
        end-case
      "xor" case
        tokens TokenType OPERATOR . fPos OperatorType XOR . OperatorToken new :<< tokens =
        end-case

      "<<" case
        tokens TokenType OPERATOR . fPos OperatorType SHIFT_L . OperatorToken new :<< tokens =
        end-case
      ">>" case
        tokens TokenType OPERATOR . fPos OperatorType SHIFT_R . OperatorToken new :<< tokens =
        end-case

      "<" case
        tokens TokenType OPERATOR . fPos OperatorType LT . OperatorToken new :<< tokens =
        end-case
      "<=" case
        tokens TokenType OPERATOR . fPos OperatorType LE . OperatorToken new :<< tokens =
        end-case
      "==" case
        tokens TokenType OPERATOR . fPos OperatorType EQ . OperatorToken new :<< tokens =
        end-case
      "===" case
        tokens TokenType OPERATOR . fPos OperatorType REF_EQ . OperatorToken new :<< tokens =
        end-case
      "=!=" case
        tokens TokenType OPERATOR . fPos OperatorType REF_NE . OperatorToken new :<< tokens =
        end-case
      "!=" case
        tokens TokenType OPERATOR . fPos OperatorType NE . OperatorToken new :<< tokens =
        end-case
      ">=" case
        tokens TokenType OPERATOR . fPos OperatorType GE . OperatorToken new :<< tokens =
        end-case
      ">" case
        tokens TokenType OPERATOR . fPos OperatorType GT . OperatorToken new :<< tokens =
        end-case
      default
        openBlocks OpenBlocks.blocks length 0 >
          && openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock.type BlockType ENUM_BLOCK . == end
          if
          openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] EnumBlock.elements word fPos NameWithPos new :<< drop
        else
          tokens TokenType WORD . fPos word WordToken new :<< tokens =
        end
      end
    end
  end
end

readEscapeChar proc ParserReader => :
  ParserReader reader =:
  reader ParserReader.nextByte if
    byte next =:
    next switch
    '\\' '\'' '"' case
     reader ParserReader.word next :<< drop
     end-case
    'n' case
     reader ParserReader.word '\n' :<< drop
     end-case
    't' case
     reader ParserReader.word '\t' :<< drop
     end-case
    'r' case
     reader ParserReader.word '\r' :<< drop
     end-case
    'b' case
     reader ParserReader.word '\b' :<< drop
     end-case
    'f' case
     reader ParserReader.word '\f' :<< drop
     end-case
    '0' case
     reader ParserReader.word '\0' :<< drop
     end-case
    'u' 'U' case
     "\\u is currently unimplemented" eputs
     1 exit
     end-case
    default
     "The escape sequence: '\\" next :<< "' is not supported ":+ reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
     1 exit
    end
  else
    "unexpected end of file " reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
    1 exit
  end
end

parseFile proc #+fileName+# string #+program+# Program =>  :
  Program program =:
  program Program.context Context context =:
  program Program.tokens Token list tokens =:
  string fileName =:
  fileName "r" open if #+auto-unwrap+# else
    "file \"" fileName "\" not found\n" :+ :+ eputs
    1 exit
  end
  16 newBufferedInput #+input+#
  fileName 1 1 FilePosition new       #+pos+#
  16 byte list new                    #+word+#
  fileName 1 1 FilePosition new       #+wordPos+#
  ParserReader new ParserReader reader =:
  ## FIXME detect file header
  context RootContext.startFile
  ParseState STATE_WORD . ParseState state =:
  reader ParserReader.pos "" newMacro 16 CodeBlock list new OpenBlocks new OpenBlocks openBlocks =:

  "" string prevWord =:
  fileName 1 1 FilePosition new FilePosition prevPos =:

  while reader ParserReader.nextByte do
    #+next-char+#
    state switch
      STATE_WORD case
        byte next =:
        next ?WhiteSpace if
          reader ParserReader.word length 0 > if
            reader ParserReader.word clone string nextWord =:
            nextWord length 0 > if
              prevWord length 0 > if
                prevWord nextWord prevPos openBlocks program parseWord
              end
              nextWord prevWord =
              reader ParserReader.wordPos clone prevPos =
            end
          end
          reader ParserReader.nextWord
        else
          next switch
          '"' case
              reader ParserReader.word "u" == if
                ParseState STATE_USTRING . state =
                reader ParserReader.word clear
              else reader ParserReader.word length 0 == _if
                ParseState STATE_STRING . state =
              else
                "illegal string-prefix: \"" reader ParserReader.word :+ "\" " :+
                   reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
                1 exit
              end
            end-case
          '\'' case
              reader ParserReader.word "u" == if
                ParseState STATE_UCHAR . state =
                reader ParserReader.word clear
              else reader ParserReader.word length 0 == _if
                ParseState STATE_CHAR . state =
              else
                "illegal char-prefix: \"" reader ParserReader.word :+ "\" " :+
                   reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
                1 exit
              end
            end-case
          '#' case
              reader ParserReader.nextByte if
                next =
                next '#' == if
                  reader ParserReader.word clone string nextWord =:
                  nextWord length 0 > if
                    prevWord length 0 > if
                      prevWord nextWord prevPos openBlocks program parseWord
                    end
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  end
                  reader ParserReader.nextWord
                  ParseState STATE_LINE_COMMENT . state =
                else next '+' == _if
                  reader ParserReader.word clone string nextWord =:
                  nextWord length 0 > if
                    prevWord length 0 > if
                      prevWord nextWord prevPos openBlocks program parseWord
                    end
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  end
                  reader ParserReader.nextWord
                  ParseState STATE_COMMENT . state =
                else
                  reader ParserReader.word '#' :<< next :<< drop
                end
              else
                reader ParserReader.word '#' :<< drop
              end
            end-case
          default
            reader ParserReader.word next :<< drop
          end
        end
      end-case
      STATE_STRING STATE_USTRING case
        byte next =:
        next '"' == if
          prevWord length 0 > if
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            "" prevWord =
          end
          tokens
            TokenType VALUE . reader ParserReader.wordPos clone
            state ParseState STATE_USTRING . == if
              reader ParserReader.word codepoints Value.ofUString
            else
              reader ParserReader.word clone Value.ofString
            end
          ValueToken new :<< tokens =
          reader ParserReader.nextWord
          ParseState STATE_WORD . state =
        else next '\\' == _if
          reader readEscapeChar
        else
          reader ParserReader.word next :<< drop
        end
      end-case
      STATE_CHAR STATE_UCHAR case
        byte next =:
        next '\'' == if
          prevWord length 0 > if
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            "" prevWord =
          end
          tokens
            TokenType VALUE . reader ParserReader.wordPos clone
            state ParseState STATE_UCHAR . == if
              reader ParserReader.word codepoints
              dup length 1 != if
                reader ParserReader.word " is not a valid unicode character " :+
                reader ParserReader.pos FilePosition.strAppend '\n' :<<
                eputs
                1 exit
              end
              #+chars+# 0 [] Value.ofCodepoint
            else
              reader ParserReader.word clone
              dup length 1 != if
                #+str+# " is not a valid unicode character " :+
                reader ParserReader.pos FilePosition.strAppend '\n' :<<
                eputs
                1 exit
              end
              #+chars+# 0 [] Value.ofByte
            end
          ValueToken new :<< tokens =
          reader ParserReader.nextWord
          ParseState STATE_WORD . state =
        else next '\\' == _if
          reader readEscapeChar
        else
          reader ParserReader.word next :<< drop
        end
      end-case
      STATE_COMMENT case
        #+input-char+# '+' == if
          reader ParserReader.nextByte if
            '#' == if
              ParseState STATE_WORD . state =
            end
          end
        end
      end-case
      STATE_LINE_COMMENT case
        #+input-char+# '\n' == if
          ParseState STATE_WORD . state =
        end
      end-case
    end
  end

  state switch
    STATE_WORD case
      reader ParserReader.word clone string nextWord =:
      prevWord length 0 > if
        prevWord nextWord prevPos openBlocks program parseWord
        "" prevWord =
      end
      nextWord "" reader ParserReader.wordPos clone openBlocks program parseWord
      END_OF_SECTION "" reader ParserReader.wordPos clone openBlocks program parseWord
      reader ParserReader.nextWord
      end-case
    STATE_CHAR STATE_UCHAR case
     "unfinished char-literal " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
    STATE_STRING STATE_USTRING case
     "unfinished string-literal " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
    STATE_COMMENT case
     "unfinished comment " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
    STATE_LINE_COMMENT case
      ##do nothing
      end-case
  end
  context reader ParserReader.wordPos RootContext.endFile
end

constEvaluate proc Token list => Token list :
  Token list tokens =:
  tokens length Token list new Token list res =:
  0 int i =:
  while i tokens length < do
    tokens i [] Token.type switch
      VALUE case
        res tokens i [] :<< res =
        end-case
      OPERATOR case
        tokens i [] OperatorToken.opType switch
          PLUS
          MINUS
          NEGATE
          INVERT
          MULTIPLY
          DIVIDE
          MOD

          NOT
          FLIP
          AND
          OR
          XOR

          SHIFT_L
          SHIFT_R

          LT
          LE
          EQ
          REF_EQ
          REF_NE
          NE
          GE
          GT case
            "operators of type:" OperatorType type.fields tokens i [] OperatorToken.opType [] :+
            " are currently not supported in constant evaluation " :+
            tokens i [] Token.pos FilePosition.strAppend '\n' :<< eputs
            1 exit
            end-case
        end
        end-case
      WORD
      KEY_WORD
      PROCEDURE_START
      ENUM_START
      IDENTIFIER
      VARIABLE
      BLOCK_TOKEN
      CONTEXT_OPEN
      CONTEXT_CLOSE case
        "tokens of type:" TokenType type.fields tokens i [] Token.type [] :+
        " are currently not supported in constant evaluation " :+
        tokens i [] Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end-case
    end
    i 1 + i =
  end
  res return
end

##addLater typeCheckProgram
##addLater compileProgram

main proc string list => :
  string list args =:
  args length 2 < if
    "usage: <pathToFile> \n" puts ## "usage: <pathToFile> (-lib <libPath>)"
    0 exit
  end
  args 1 [] string path =:
  path length 0 > && path 0 [] '.' == end if ##local path
    args 0 [] clone path 1 path length [:] :+ path =
  end

  16 Token list new Token list tokens =:
  newRootContext RootContext context =:
  path tokens context Program new parseFile

  0 int i =:
  while i tokens length < do
    tokens i [] Token token =:
    "" token Token.strAppend " " :+ token Token.pos FilePosition.strAppend '\n' :<< puts
    i 1 + i =
  end
  "\n" puts
  "declared values:\n" puts
  context Context.elements HashMap.itr while HashMapItr.next do
      string Declareable MapEntry e =:
      e MapEntry.key print ": " e MapEntry.value Declareable.strAppend println
   end drop
end
