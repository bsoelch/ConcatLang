## concat compiler written in concat

## currently in early development phase

stack   #include
chars   #include
valueIO #include
utf8    #include
core #import

bufferedIO #include
io #import

string uint uint 3 tuple  type FilePosition =$
FilePosition.fileName   #define 0 []   #end
FilePosition.line       #define 1 []   #end
FilePosition.line=      #define 1 [] = #end
FilePosition.posInLine  #define 2 []   #end
FilePosition.posInLine= #define 2 [] = #end
FilePosition.newLine    #define dup dup 1 [] 1 + 1 [] = 1 2 [] = #end
FilePosition.nextChar   #define dup 2 [] 1 + 2 [] = #end
FilePosition.strAppend proc string FilePosition => string :
  FilePosition position =:
  string str =:
  str position FilePosition.fileName :+
  ':' :<< position FilePosition.line      10 true false intToString :+
  ':' :<< position FilePosition.posInLine 10 true false intToString :+ return
end

TokenType enum
  WORD
  KEY_WORD
  PROCEDURE_START
  ENUM_START
  VALUE
  IDENTIFIER
  OPERATOR
end
TokenType FilePosition 2 tuple type Token =$
Token.type  #define 0 [] #end
Token.pos   #define 1 [] #end
TokenType FilePosition string 3 tuple type WordToken =$
WordToken.value #define 2 [] #end
TokenType FilePosition var 3 tuple type ValueToken =$
ValueToken.value #define 2 [] #end

IdentifierType enum
  UNMODIFIED
  WRITE
  DECLARE
  CONST_DECLARE
  ADDRESS_OF
end
TokenType FilePosition IdentifierType string 4 tuple type IdentifierToken =$
IdentifierToken.idType #define 2 [] #end
IdentifierToken.value  #define 3 [] #end

OperatorType enum
  PLUS MINUS NEGATE INVERT MULTIPLY DIVIDE MOD
  NOT FLIP AND OR XOR  SHIFT_L SHIFT_R
  LT LE EQ REF_EQ REF_NE NE GE GT
end
TokenType FilePosition OperatorType 3 tuple type OperatorToken =$
OperatorToken.opType #define 2 [] #end

Token.strAppend proc string Token => string :
  Token token =:

  TokenType token Token.type [] +: ": " +:
  token Token.type switch
  TokenType WORD . TokenType KEY_WORD . TokenType PROCEDURE_START . TokenType ENUM_START . case
    token WordToken.value :+
    end-case
  TokenType VALUE . case
    token ValueToken.value typeof stringValue :+ ": " :+ token ValueToken.value  stringValue :+
    end-case
  TokenType IDENTIFIER . case
    IdentifierType token IdentifierToken.idType [] :+ ": " :+ token IdentifierToken.value :+
    end-case
  TokenType OPERATOR . case
    OperatorType token OperatorToken.opType [] :+
    end-case
  end
end

DeclarableType enum
  MACRO
  ENUM
  VARIABLE
  CONSTANT
  PROCEDURE
end

#_type_# DeclarableType #_pos_# FilePosition 2 tuple type Declarable =$

Declarable.type #define 0 []   #end
Declarable.pos  #define 1 []   #end
Declarable.pos= #define 1 [] = #end

#_type_# DeclarableType #_pos_# FilePosition #_name_# string #_words_# string list  4 tuple type Macro =$
Macro.name  #define 2 []   #end
Macro.name= #define 2 [] = #end
Macro.words #define 3 []   #end
newMacro proc FilePosition string => Macro :
  string name =:
  FilePosition mPos =:
  DeclarableType MACRO . mPos name 16 byte list new Macro new return
end

BlockType enum
  IF_BLOCK
  &&_BLOCK
  ||_BLOCK
  WHILE_BLOCK
  SWITCH_BLOCK
  PROC_BLOCK
  ENUM_BLOCK
end
#_type_# BlockType #_startPos_# FilePosition #_start_# int 3 tuple type CodeBlock =$
CodeBlock.type     #define 0 [] #end
CodeBlock.startPos #define 1 [] #end
CodeBlock.start    #define 2 [] #end
string FilePosition 2 tuple type NameWithPos =$
#_type_# BlockType #_startPos_# FilePosition #_start_# int
  #_name_# string #_elements_# NameWithPos list 5 tuple type EnumBlock =$
EnumBlock.name     #define 3 [] #end
EnumBlock.elements #define 4 [] #end
newEnumBlock proc #_name_# string #_startPos_# FilePosition #_start_# int => EnumBlock :
  int start =:
  FilePosition startPos =:
  string name =:
  BlockType ENUM_BLOCK . startPos start name 16 NameWithPos list new EnumBlock new return
end


BufferedInput FilePosition string FilePosition 4 tuple type ParserReader =$
ParserReader.in       #define 0 [] #end
ParserReader.pos      #define 1 [] #end
ParserReader.word     #define 2 [] #end
ParserReader.wordPos  #define 3 [] #end
ParserReader.nextWord proc ParserReader => :
  ParserReader reader =:
  reader ParserReader.word clear
  reader ParserReader.wordPos  reader ParserReader.pos FilePosition.line       FilePosition.line=
  reader ParserReader.wordPos  reader ParserReader.pos FilePosition.posInLine  FilePosition.posInLine=
end
ParserReader.nextByte proc ParserReader => byte optional :
  ParserReader reader =:
  reader ParserReader.in nextByte byte optional next =:
  next ?? if
    unwrap '\n' == if
      reader ParserReader.pos FilePosition.newLine
    else
      reader ParserReader.pos FilePosition.nextChar
    end
  else
    drop
  end
  next return
end

ParseState enum
  STATE_WORD
  STATE_STRING
  STATE_USTRING
  STATE_CHAR
  STATE_UCHAR
  STATE_COMMENT
  STATE_LINE_COMMENT
end

Macro CodeBlock list 2 tuple type OpenBlocks =$
OpenBlocks.currentMacro  #define 0 []   #end
OpenBlocks.currentMacro= #define 0 [] = #end
OpenBlocks.blocks        #define 1 []   #end

parseWord proc #_word_# string #_next_# string #_pos_# FilePosition #_open_blocks_# OpenBlocks #_tokens_# Token list => :
  Token list tokens =:
  OpenBlocks openBlocks =:
  FilePosition fPos =:
  string       next =:
  string       word =:
  word length 0 > if
    openBlocks OpenBlocks.currentMacro Macro.name length 0 > if
      word switch
      "#end" case
        ##TODO save macro
        openBlocks fPos "" newMacro OpenBlocks.currentMacro=
        end-case
      "#define" "#undef" "#module" "#include" "#import" "proc" "procedure" "enum" case
        word " is not allowed in macros " :+ fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
        end-case
      default
        openBlocks OpenBlocks.currentMacro Macro.words word :<< drop
      end
      return
    end
    ##keywords that consume one or more words
    word switch
    ## identifier - modifiers
    "."  case
      tokens length 2 < if
        "not enough arguments for . " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 2 - [] Token prePrev =:
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '.' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      prePrev Token.type TokenType WORD . != if
        "invalid token for '.' modifier: " prePrev Token.strAppend ' ' :<< prePrev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType WORD . fPos prePrev WordToken.value '\'' :<< prev WordToken.value :+ WordToken new tokens length 2 - [] =
      tokens tokens length 1 - tokens length [:] clear
      end-case
    "="  case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos IdentifierType WRITE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "=:" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=:' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos IdentifierType DECLARE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "=$" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '=$' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos
        IdentifierType CONST_DECLARE . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    "@()" case
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for '@()' modifier: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType IDENTIFIER . fPos
        IdentifierType ADDRESS_OF . prev WordToken.value IdentifierToken new tokens length 1 - [] =
      end-case
    ## macro&module key-words
    "#end" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#define" case
      tokens length 0 == if
        "missing macro name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for macro name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.currentMacro prev WordToken.value Macro.name=
      openBlocks OpenBlocks.currentMacro prev Token.pos   Declarable.pos=
      end-case
    "#undef" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#module" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#import" case
      "unimplemented\n" eputs
      1 exit
      end-case
    "#include" case
      "unimplemented\n" eputs
      1 exit
      end-case
    ## proc/enum key-words
    "proc" "procedure" case
      tokens length 0 == if
        "missing procedure name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for procedure name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens TokenType PROCEDURE_START . fPos prev WordToken.value WordToken new tokens length 1 - [] =
      end-case
    "enum" case
      tokens length 0 == if
        "missing enum name " fPos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - [] Token prev =:
      prev Token.type TokenType WORD . != if
        "invalid token for enum name: " prev Token.strAppend ' ' :<< prev Token.pos FilePosition.strAppend '\n' :<< eputs
        1 exit
      end
      tokens tokens length 1 - tokens length [:] clear
      openBlocks OpenBlocks.blocks prev WordToken.value fPos tokens length newEnumBlock :<< drop
      end-case
    default
      tokens length 0 > && next "." != end if
        tokens tokens length 1 - [] Token prev =:
        prev Token.type TokenType WORD . == if
          ##TODO resolve identifiers
          tokens TokenType IDENTIFIER . fPos
            IdentifierType UNMODIFIED . prev WordToken.value IdentifierToken new tokens length 1 - [] =
        end
      end
      ## try parsing as integer
      0 int off =:
      ## detect signs
      false bool sgn =:
           word 0 [] '-' ==  if
        true sgn =
        off 1 + off =
      else word 0 [] '+' == _if
        off 1 + off =
      end
      10 int base =:
      ##detect base modifiers
      word length off - 3 > if
             word off off 2 + [:] "0b" ==  if
          2 base =
          off 2 + off =
        else word off off 2 + [:] "0x" == _if
          16 base =
          off 2 + off =
        end
      end
      off word length < && word off [] base valueOfDigit 0 >= end if ##number starts with digit after prefixes
        word word length 1 - [] dup 'u' == || 'U' == end if ##unsigned
          word off word length 1 - [:] base true stringToInt switch
          StringParseError ERR_NONE . case
            sgn if -_ end uint val =:
            tokens TokenType VALUE . fPos val  ValueToken new :<< tokens =
            return
            end-case
          StringParseError ERR_OVERFLOW . case
            "value does not fit in an unsigned int: \"" word :+ "\" " :+
                fPos FilePosition.strAppend '\n' :<< eputs
            1 exit
            end-case
          StringParseError ERR_BASE . StringParseError ERR_EMPTY . StringParseError ERR_ILLEGAL_CHAR . case
            drop
            end-case
          end
        else
          word off word length [:] base false stringToInt switch
          StringParseError ERR_NONE . case
              sgn if -_ end int val =:
              tokens TokenType VALUE . fPos val  ValueToken new :<< tokens =
              return
            end-case
          StringParseError ERR_OVERFLOW . case
            "value does not fit in a signed int: \"" word :+ "\" " :+
                fPos FilePosition.strAppend '\n' :<< eputs
            1 exit
            end-case
          StringParseError ERR_BASE . StringParseError ERR_EMPTY . StringParseError ERR_ILLEGAL_CHAR . case
            drop
            end-case
          end
          word off word length [:] base stringToFloat StringParseError ERR_NONE . == if
            sgn if -_ end float val =:
            tokens TokenType VALUE . fPos val  ValueToken new :<< tokens =
            return
          else
            drop
          end
        end
      end
      ## end integer parsing
      ##constants, operators and remaining keywords
      word switch
      ## detect true and false
      "true" case
        tokens TokenType VALUE . fPos true  ValueToken new :<< tokens =
        end-case
      "false" case
        tokens TokenType VALUE . fPos false ValueToken new :<< tokens =
        end-case
      ## detect primitive type-names
      "bool" case
        tokens TokenType VALUE . fPos bool ValueToken new :<< tokens =
        end-case
      "byte" case
        tokens TokenType VALUE . fPos byte ValueToken new :<< tokens =
        end-case
      "int" case
        tokens TokenType VALUE . fPos int ValueToken new :<< tokens =
        end-case
      "uint" case
        tokens TokenType VALUE . fPos uint ValueToken new :<< tokens =
        end-case
      "codepoint" case
        tokens TokenType VALUE . fPos codepoint ValueToken new :<< tokens =
        end-case
      "type" case
        tokens TokenType VALUE . fPos type ValueToken new :<< tokens =
        end-case
      "var" case
        tokens TokenType VALUE . fPos var ValueToken new :<< tokens =
        end-case
      ## control-flow key-words
      "lambda" "Î»" "=>" ":"
      "while" "if" "else" "if_" "switch" "case" "end-case" "default" "&&" "||" "return" "exit" case
        ## TODO handle different block-types
        openBlocks OpenBlocks.blocks BlockType IF_BLOCK . fPos tokens length CodeBlock new :<< drop
        tokens TokenType KEY_WORD . fPos word WordToken new :<< tokens =
        end-case
      "end" case
        openBlocks OpenBlocks.blocks length 0 == if
          "unexpected end-statement " fPos FilePosition.strAppend '\n' :<< eputs
          1 exit
        end
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock block =:
        openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - openBlocks OpenBlocks.blocks length [:] clear
        ## TODO close block
        block CodeBlock.type switch
        BlockType IF_BLOCK . case
          "Waring closing if-blocks is currently not implemented\n" eputs
          end-case
        BlockType &&_BLOCK . BlockType ||_BLOCK . case
          "Waring closing &&-/||-blocks is currently not implemented\n" eputs
          end-case
        BlockType WHILE_BLOCK . case
          "Waring closing while-blocks is currently not implemented\n" eputs
          end-case
        BlockType SWITCH_BLOCK . case
          "Waring closing switch-blocks is currently not implemented\n" eputs
          end-case
        BlockType PROC_BLOCK . case
          "Waring closing proc-blocks is currently not implemented\n" eputs
          end-case
        BlockType ENUM_BLOCK . case
          tokens length block CodeBlock.start > if
            "Invalid token in enum: " tokens block CodeBlock.start [] Token.strAppend ' '
              :<< tokens block CodeBlock.start [] Token.pos FilePosition.strAppend '\n' :<< eputs
            1 exit
          end
          ##TODO save enum
          end-case
        end
        end-case
      ## operators
      "+" case
        tokens TokenType OPERATOR . fPos OperatorType PLUS . OperatorToken new :<< tokens =
        end-case
      "-" case
        tokens TokenType OPERATOR . fPos OperatorType MINUS . OperatorToken new :<< tokens =
        end-case
      "-_" case
        tokens TokenType OPERATOR . fPos OperatorType NEGATE . OperatorToken new :<< tokens =
        end-case
      "*" case
        tokens TokenType OPERATOR . fPos OperatorType MULTIPLY . OperatorToken new :<< tokens =
        end-case
      "/" case
        tokens TokenType OPERATOR . fPos OperatorType DIVIDE . OperatorToken new :<< tokens =
        end-case
      "%" case
        tokens TokenType OPERATOR . fPos OperatorType MOD . OperatorToken new :<< tokens =
        end-case

      "!" case
        tokens TokenType OPERATOR . fPos OperatorType NOT . OperatorToken new :<< tokens =
        end-case
      "~" case
        tokens TokenType OPERATOR . fPos OperatorType FLIP . OperatorToken new :<< tokens =
        end-case
      "&" case
        tokens TokenType OPERATOR . fPos OperatorType AND . OperatorToken new :<< tokens =
        end-case
      "|" case
        tokens TokenType OPERATOR . fPos OperatorType OR . OperatorToken new :<< tokens =
        end-case
      "xor" case
        tokens TokenType OPERATOR . fPos OperatorType XOR . OperatorToken new :<< tokens =
        end-case

      "<<" case
        tokens TokenType OPERATOR . fPos OperatorType SHIFT_L . OperatorToken new :<< tokens =
        end-case
      ">>" case
        tokens TokenType OPERATOR . fPos OperatorType SHIFT_R . OperatorToken new :<< tokens =
        end-case

      "<" case
        tokens TokenType OPERATOR . fPos OperatorType LT . OperatorToken new :<< tokens =
        end-case
      "<=" case
        tokens TokenType OPERATOR . fPos OperatorType LE . OperatorToken new :<< tokens =
        end-case
      "==" case
        tokens TokenType OPERATOR . fPos OperatorType EQ . OperatorToken new :<< tokens =
        end-case
      "===" case
        tokens TokenType OPERATOR . fPos OperatorType REF_EQ . OperatorToken new :<< tokens =
        end-case
      "=!=" case
        tokens TokenType OPERATOR . fPos OperatorType REF_NE . OperatorToken new :<< tokens =
        end-case
      "!=" case
        tokens TokenType OPERATOR . fPos OperatorType NE . OperatorToken new :<< tokens =
        end-case
      ">=" case
        tokens TokenType OPERATOR . fPos OperatorType GE . OperatorToken new :<< tokens =
        end-case
      ">" case
        tokens TokenType OPERATOR . fPos OperatorType GT . OperatorToken new :<< tokens =
        end-case
      default
        openBlocks OpenBlocks.blocks length 0 >
          && openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] CodeBlock.type BlockType ENUM_BLOCK . == end
          if
          openBlocks OpenBlocks.blocks openBlocks OpenBlocks.blocks length 1 - [] EnumBlock.elements word fPos NameWithPos new :<< drop
        else
          tokens TokenType WORD . fPos word WordToken new :<< tokens =
        end
      end
    end
  end
end

readEscapeChar proc ParserReader => :
  ParserReader reader =:
  reader ParserReader.nextByte ?? if
  unwrap byte next =:
  next switch
  '\\' '\'' '"' case
   reader ParserReader.word next :<< drop
   end-case
  'n' case
   reader ParserReader.word '\n' :<< drop
   end-case
  't' case
   reader ParserReader.word '\t' :<< drop
   end-case
  'r' case
   reader ParserReader.word '\r' :<< drop
   end-case
  'b' case
   reader ParserReader.word '\b' :<< drop
   end-case
  'f' case
   reader ParserReader.word '\f' :<< drop
   end-case
  '0' case
   reader ParserReader.word '\0' :<< drop
   end-case
  'u' 'U' case
   "\\u is currently unimplemented" eputs
   1 exit
   end-case
  default
   "The escape sequence: '\\" next :<< "' is not supported ":+ reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
   1 exit
  end
  else drop
  "unexpected end of file " reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
  1 exit
  end
end

parseFile proc #_fileName_# string => Token list :
  string fileName =:
  16 Token list new Token list tokens =:

  fileName "r" open 16 createBufferedIn #_input_#
  fileName 1 1 FilePosition new       #_pos_#
  16 byte list new                    #_word_#
  fileName 1 1 FilePosition new       #_wordPos_#
  ParserReader new ParserReader reader =:
  ParseState STATE_WORD . ParseState state =:
  reader ParserReader.pos "" newMacro 16 CodeBlock list new OpenBlocks new OpenBlocks openBlocks =:

  "" string prevWord =:
  fileName 1 1 FilePosition new FilePosition prevPos =:

  while reader ParserReader.nextByte ?? :
    unwrap #_next-char_#
    state switch
      ParseState STATE_WORD . case
        byte next =:
        next ?WhiteSpace if
          reader ParserReader.word clone string nextWord =:
          nextWord length 0 > if
            prevWord length 0 > if
              prevWord nextWord prevPos openBlocks tokens parseWord
            end
            nextWord prevWord =
            reader ParserReader.wordPos clone prevPos =
          end
          reader ParserReader.nextWord
        else
          next switch
          '"' case
              reader ParserReader.word "u" == if
                ParseState STATE_USTRING . state =
                reader ParserReader.word clear
              else reader ParserReader.word length 0 == _if
                ParseState STATE_STRING . state =
              else
                "illegal string-prefix: \"" reader ParserReader.word :+ "\" " :+
                   reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
                1 exit
              end
            end-case
          '\'' case
              reader ParserReader.word "u" == if
                ParseState STATE_UCHAR . state =
                reader ParserReader.word clear
              else reader ParserReader.word length 0 == _if
                ParseState STATE_CHAR . state =
              else
                "illegal char-prefix: \"" reader ParserReader.word :+ "\" " :+
                   reader ParserReader.pos FilePosition.strAppend '\n' :<< eputs
                1 exit
              end
            end-case
          '#' case
              reader ParserReader.nextByte ?? if
                unwrap next =
                next '#' == if
                  reader ParserReader.word clone string nextWord =:
                  nextWord length 0 > if
                    prevWord length 0 > if
                      prevWord nextWord prevPos openBlocks tokens parseWord
                    end
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  end
                  reader ParserReader.nextWord
                  ParseState STATE_LINE_COMMENT . state =
                else next '_' == _if
                  reader ParserReader.word clone string nextWord =:
                  nextWord length 0 > if
                    prevWord length 0 > if
                      prevWord nextWord prevPos openBlocks tokens parseWord
                    end
                    nextWord prevWord =
                    reader ParserReader.wordPos clone prevPos =
                  end
                  reader ParserReader.nextWord
                  ParseState STATE_COMMENT . state =
                else
                  reader ParserReader.word '#' :<< next :<< drop
                end
              else drop
                reader ParserReader.word '#' :<< drop
              end
            end-case
          default
            reader ParserReader.word next :<< drop
          end
        end
      end-case
      ParseState STATE_STRING . ParseState STATE_USTRING . case
        byte next =:
        next '"' == if
          prevWord length 0 > if
            prevWord "" prevPos openBlocks tokens parseWord
          end
          tokens
            TokenType VALUE . reader ParserReader.wordPos clone
            state ParseState STATE_USTRING . == if
              reader ParserReader.word codepoints
            else
              reader ParserReader.word clone
            end
          ValueToken new :<< tokens =
          reader ParserReader.nextWord
          ParseState STATE_WORD . state =
        else next '\\' == _if
          reader readEscapeChar
        else
          reader ParserReader.word next :<< drop
        end
      end-case
      ParseState STATE_CHAR . ParseState STATE_UCHAR . case
        byte next =:
        next '\'' == if
          prevWord length 0 > if
            prevWord "" prevPos openBlocks tokens parseWord
          end
          tokens
            TokenType VALUE . reader ParserReader.wordPos clone
            state ParseState STATE_UCHAR . == if
              reader ParserReader.word codepoints
              dup length 1 != if
                reader ParserReader.word " is not a valid unicode character " :+
                reader ParserReader.pos FilePosition.strAppend '\n' :<<
                eputs
                1 exit
              end
            else
              reader ParserReader.word clone
              dup length 1 != if
                #_str_# " is not a valid unicode character " :+
                reader ParserReader.pos FilePosition.strAppend '\n' :<<
                eputs
                1 exit
              end
            end
          #_chars_# 0 [] ValueToken new :<< tokens =
          reader ParserReader.nextWord
          ParseState STATE_WORD . state =
        else next '\\' == _if
          reader readEscapeChar
        else
          reader ParserReader.word next :<< drop
        end
      end-case
      ParseState STATE_COMMENT . case
        #_input-char_# '_' == if
          reader ParserReader.nextByte ?? if
            unwrap '#' == if
              ParseState STATE_WORD . state =
            end
          else
            drop
          end
        end
      end-case
      ParseState STATE_LINE_COMMENT . case
        #_input-char_# '\n' == if
          ParseState STATE_WORD . state =
        end
      end-case
    end
  end drop

  state switch
    ParseState STATE_WORD . case
      reader ParserReader.word clone string nextWord =:
      prevWord length 0 > if
        prevWord nextWord prevPos openBlocks tokens parseWord
      end
      nextWord "" reader ParserReader.wordPos clone openBlocks tokens parseWord
      reader ParserReader.nextWord
      end-case
    ParseState STATE_CHAR . ParseState STATE_UCHAR . case
     "unfinished char-literal " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
    ParseState STATE_STRING . ParseState STATE_USTRING . case
     "unfinished string-literal " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
    ParseState STATE_COMMENT . ParseState STATE_LINE_COMMENT . case
     "unfinished comment " reader ParserReader.wordPos FilePosition.strAppend '\n' :<<
      eputs
      1 exit
      end-case
  end
  tokens return
end

##addLater parseTokens

main proc string list => :
  string list args =:
  args length 2 < if
    "usage: <pathToFile> \n" puts ## "usage: <pathToFile> (-lib <libPath>)"
    0 exit
  end
  args 1 [] string path =:
  path length 0 > && path 0 [] '.' == end if ##local path
    args 0 [] clone path 1 path length [:] :+ path =
  end
  path parseFile Token list tokens =:

  0 int i =:
  while i tokens length < :
    tokens i [] Token token =:
    "" token Token.strAppend " " :+ token Token.pos FilePosition.strAppend '\n' :<< puts
    i 1 + i =
  end
end
