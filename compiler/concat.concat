concat.concat :
## concat compiler written in concat
#+
this file is based on an outdated version of the interpreter
the compiler will be updated once the language is stabilized

the current version of the compiler is kept up to date as an example of a complex concat program
+#
##TODO update concat.concat

## currently in early development phase

stack   #include
chars   #include
valueIO #include
utf8    #include
core    #import

hashMap #include
hashMap #import

bufferedIO #include
io #import


FilePosition struct{
  string :fileName
  uint   :line      mut
  uint   :posInLine mut
}
FilePosition.newLine    proc( FilePosition mut => ){
  dup dup .line 1 + swap .line = 1 swap .posInLine =
}
FilePosition.nextChar   proc( FilePosition mut => ){
  dup .posInLine 1 + swap .posInLine =
}
<< proc( stringBuilder FilePosition mut? => stringBuilder ){
  FilePosition mut? position =:
  #+str+# position .fileName <<*
  ':' << position .line      <<i
  ':' << position .posInLine <<i return
}

NameWithPos struct{
  string            :name
  FilePosition mut? :pos
}

TypeType enum{ PRIMITIVE_TYPE TUPLE_TYPE ENUM_TYPE WRAPPER_TYPE }
Type struct{
  TypeType :typeType
}
PrimitiveType struct{ Type extend
  type :wrapped
}

TupleType struct{ Type extend
  string    :name
  Type list :types
}
newTupleType proc( #+name+# string #+types+# Type list => TupleType ){
  Type list elements =:
  string name =:
  TypeType .TUPLE_TYPE name elements TupleType new return
}

EnumType struct{ Type extend
  string           :name
  NameWithPos list :fields
}
newEnumType proc( #+name+# string #+fields+# NameWithPos list => EnumType ){
  NameWithPos list fields =:
  string name =:
  TypeType .ENUM_TYPE name fields EnumType new return
}

WrapperTypeType enum{ LIST OPTIONAL VAR_ARGS }
WrapperType struct{ Type extend
  WrapperTypeType :wrapperType
  Type            :wrapped
}

<< proc( stringBuilder Type => stringBuilder ){
  Type t =:
  t .typeType switch{
  PRIMITIVE_TYPE case
    t PrimitiveType cast .wrapped stringValue <<* return
    end-case
  WRAPPER_TYPE case
    t WrapperType wt =:
    wt .wrapped <<
    wt .wrapperType switch{
    LIST     case " list"     <<* return end-case
    OPTIONAL case " optional" <<* return end-case
    VAR_ARGS case " ..."      <<* return end-case
    }
    end-case
  TUPLE_TYPE case
    t TupleType tt =:
    tt .name <<* '[' <<
    0 int i mut =:
    while{ i tt .types .length < do
      i 0 > if{ ", " <<* }
      tt .types i [] <<
      i 1 + i =
    }
    ']' <<
    end-case
  ENUM_TYPE case
    t EnumType et =:
    et .name <<* '[' <<
    0 int i mut =:
    while{ i et .fields .length < do
      i 0 > if{ ", " <<* }
      et .fields i [] .name <<*
      i 1 + i =
    }
    ']' <<
    end-case
  }
}

TypeType .PRIMITIVE_TYPE      bool PrimitiveType new Type Type.BOOL      =:
TypeType .PRIMITIVE_TYPE      byte PrimitiveType new Type Type.BYTE      =:
TypeType .PRIMITIVE_TYPE codepoint PrimitiveType new Type Type.CODEPOINT =:
TypeType .PRIMITIVE_TYPE      uint PrimitiveType new Type Type.UINT      =:
TypeType .PRIMITIVE_TYPE       int PrimitiveType new Type Type.INT       =:
TypeType .PRIMITIVE_TYPE     float PrimitiveType new Type Type.FLOAT     =:
TypeType .PRIMITIVE_TYPE      type PrimitiveType new Type Type.TYPE      =:
TypeType .PRIMITIVE_TYPE       var PrimitiveType new Type Type.VAR       =:

TypeType .WRAPPER_TYPE WrapperTypeType .LIST Type.BYTE      WrapperType new Type Type.STRING  =:
TypeType .WRAPPER_TYPE WrapperTypeType .LIST Type.CODEPOINT WrapperType new Type Type.USTRING =:

Value struct{
  Type :valType
  var  :data
}

<< proc( stringBuilder Value => stringBuilder ){
  Value v =:
  v .valType << ": " <<*
  v .valType .typeType switch{
  PRIMITIVE_TYPE case
    v .valType Type.TYPE == if{
      v .data Type cast << return
    else
      v .data stringValue <<* return
    }
    end-case
  ENUM_TYPE case
   '[' << v .data EnumEntry cast .index stringValue <<* ']' << return
   end-case
  TUPLE_TYPE case
    "tuple-type unimplemented\n" eputs 1 exit
  end-case
  WRAPPER_TYPE case
    v .valType Type.STRING == ||{ v .valType Type.USTRING == } if{
      v .data stringValue <<* return
    else
      "wrapper-type unimplemented\n" eputs 1 exit
    }
  end-case
  }
}

Type.BOOL true  Value new Value Value.TRUE  =:
Type.BOOL false Value new Value Value.FALSE =:
Value.ofByte      proc( byte       => Value ){ Type.BYTE      swap Value new return }
Value.ofCodepoint proc( codepoint  => Value ){ Type.CODEPOINT swap Value new return }
Value.ofInt       proc( int        => Value ){ Type.INT       swap Value new return }
Value.ofUInt      proc( uint       => Value ){ Type.UINT      swap Value new return }
Value.ofFloat     proc( float      => Value ){ Type.FLOAT     swap Value new return }
Value.ofType      proc( Type       => Value ){ Type.TYPE      swap Value new return }
Value.ofString    proc( string     => Value ){ Type.STRING    swap Value new return }
Value.ofUString   proc( ustring    => Value ){ Type.USTRING   swap Value new return }

BlockType enum{
  IF_BLOCK
  WHILE_BLOCK
  SWITCH_BLOCK
  PROC_BLOCK
  ENUM_BLOCK
  TUPLE_BLOCK
}
CodeBlock struct{
  BlockType         :blockType
  FilePosition mut? :startPos
  int               :start
}

WhileBlock struct{ CodeBlock extend
  int :forkPos mut
}
newWhileBlock proc( #+startPos+# FilePosition mut? #+start+# int => WhileBlock mut ){
  int start =:
  FilePosition mut? startPos =:
  BlockType .WHILE_BLOCK startPos start -1 WhileBlock mut new return
}

IfBlock struct{  CodeBlock extend
  int           :prevIf         mut
  uint list mut :else_positions
}
newIfBlock proc( #+startPos+# FilePosition mut? #+start+# int => IfBlock mut ){
  int start =:
  FilePosition mut? startPos =:
  BlockType .IF_BLOCK startPos start start 16 uint list mut new IfBlock mut new return
}

EnumBlock struct{ CodeBlock extend
  string               :name
  NameWithPos list mut :elements
}
newEnumBlock proc( #+name+# string #+startPos+# FilePosition mut?#+start+# int => EnumBlock mut ){
  int start =:
  FilePosition mut? startPos =:
  string name =:
  BlockType .ENUM_BLOCK startPos start name 16 NameWithPos list mut new EnumBlock mut new return
}
TupleBlock struct{ CodeBlock extend
  string :name
}
newTupleBlock proc( #+name+# string #+startPos+# FilePosition mut? #+start+# int => TupleBlock mut ){
  int start =:
  FilePosition mut? startPos =:
  string name =:
  BlockType .TUPLE_BLOCK startPos start name TupleBlock mut new return
}



DeclareableType enum{
  MACRO
  ENUM
  ENUM_ENTRY
  TUPLE
  VARIABLE_ID
  FINAL_VARIABLE
  PREDECLARED_PROCEDURE
  PROCEDURE
}
<<DeclareableType proc( #+str+# stringBuilder #+a+# bool #+type+# DeclareableType => stringBuilder ){
   #+type+# switch{
   MACRO case
     #+a+# if{ "a macro" else "macro" } <<* return
     end-case
   ENUM case
     #+a+# if{ "an enum" else "enum" } <<* return
     end-case
   ENUM_ENTRY case
     #+a+# if{ "an enum entry" else "enum entry" } <<* return
     end-case
   TUPLE case
     #+a+# if{ "a tuple" else "tuple" } <<* return
     end-case
   VARIABLE_ID case
     #+a+# if{ "a variable" else "variable" } <<* return
     end-case
   FINAL_VARIABLE case
     #+a+# if{ "a final variable" else "final variable" } <<* return
     end-case
   PREDECLARED_PROCEDURE case
     #+a+# if{ "a predeclared procedure" else "predeclared procedure" } <<* return
     end-case
   PROCEDURE case
     #+a+# if{ "a procedure" else "procedure" } <<* return
     end-case
   }
}

Declareable struct{
  DeclareableType   :dType
  FilePosition mut? :pos mut
}

ContextType enum{ ROOT_CONTEXT PROC_CONTEXT BLOCK_CONTEXT }

Context struct{
  string Declareable mut? HashMap mut :elements
  int                                 :varCount mut
  ContextType                         :cType
}
Context.incVarCount proc( Context mut => ){ dup .varCount 1 + swap .varCount = }

Macro struct{ Declareable extend
  string               :name mut
  NameWithPos list mut :words
}
newMacro proc( FilePosition mut? string => Macro mut ){
  string name =:
  FilePosition mut? mPos =:
  DeclareableType .MACRO mPos name 16 NameWithPos list mut new Macro mut new return
}

VariableId struct{ Declareable extend
  bool :global
  int  :level
  int  :varId
}
VariableId.isConst proc( VariableId => bool ){
  .dType DeclareableType .FINAL_VARIABLE ==
}

CurriedVariable struct{ Declareable extend }
PredeclaredProc struct{ Declareable extend }
Procedure struct{ Declareable extend }

Enum struct{ Declareable extend
  EnumType :enumType
}
newEnum proc( #+pos+# FilePosition mut? #+name+# string #+fields+# NameWithPos list => Enum ){
  #+fields+# #+name+# newEnumType EnumType enumType =:
  FilePosition mut? fPos =:
  DeclareableType .ENUM fPos enumType Enum new return
}
EnumEntry struct{ Declareable extend
  EnumType :enumType
  int      :index
}
newEnumEntry proc( #+enumType+# EnumType #+index+# int => EnumEntry ){
  int index =:
  EnumType enumType =:
  DeclareableType .ENUM_ENTRY enumType .fields index [] .pos enumType index EnumEntry new return
}

Tuple struct{ Declareable extend
  TupleType :tupleType
}

<< proc( stringBuilder VariableId mut? => stringBuilder ){
  VariableId mut? v =:
  v .global if{ "global:" else "local:" } <<*
  v .level <<u ':' <<
  v .varId <<u
  return
}
<< proc( stringBuilder Declareable mut? => stringBuilder ){
  Declareable mut? d =:
  false d .dType <<DeclareableType ": " <<*
  d .dType switch{
  MACRO case
    d Macro mut? cast .name <<*
    end-case
  ENUM case
    d Enum mut? cast .enumType <<
    end-case
  ENUM_ENTRY case
    d EnumEntry mut? ee =:
    ee .enumType .name <<* '[' <<
    ee .index stringValue <<*
    ']' <<
    end-case
  TUPLE case
    d Tuple mut? cast .tupleType <<
    end-case
  FINAL_VARIABLE VARIABLE_ID case
    d VariableId mut? cast <<
    end-case
  PREDECLARED_PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  PROCEDURE case
    "unimplemented\n" eputs 1 exit
    end-case
  }
  " at " <<* d .pos << return
}

OpenModule struct{
  string list                        :path
  FilePosition mut?                  :declaredAt
  string list mut                    :imports
  string PredeclaredProc HashMap mut :predeclared
}
newOpenModule proc( #+path+# string list #+declaredAt+# FilePosition mut? => OpenModule ){
  16 string list mut new 16 string PredeclaredProc newHashMap OpenModule new return
}
<< proc( stringBuilder OpenModule => stringBuilder ){
  OpenModule m =:
  stringBuilder str =:
  0 int i =:
  str while{ i m .path .length < do
     m .path i [] <<* "'" <<*
  }
  " declared at " <<* m .declaredAt << return
}

OpenFile struct{
  string list mut                       :globalImports
  string PredeclaredProc HashMap mut    :globalPredeclared
    #+openModules+# OpenModule list mut :openModules
}

newOpenFile proc( => OpenFile ){
  16 string list mut new
  16 string PredeclaredProc newHashMap
  16 OpenModule list mut new
  OpenFile new return
}

RootContext struct{ Context extend
    OpenFile list mut       :openFiles
    string bool HashMap mut :namespaces
}
newRootContext proc( => RootContext mut ){
  16 string Declareable mut? newHashMap
  0
  ContextType .ROOT_CONTEXT
  16 OpenFile list mut new
  16 string bool newHashMap
  RootContext mut new return
}

BlockContext struct{ Context extend
  Context mut :parent
}
newBlockContext proc( #+parent+# Context mut => BlockContext mut ){
  Context mut parent =:
  16 string Declareable mut? newHashMap 0 ContextType .BLOCK_CONTEXT parent BlockContext mut new return
}

ProcContext struct{ BlockContext extend
   CurriedVariable list :curried
}

Context.isGlobal proc( Context mut? => bool ){
  Context mut? context =:
  context .cType switch{
  ROOT_CONTEXT case
    true return
    end-case
  PROC_CONTEXT case
    false return
    end-case
  BLOCK_CONTEXT case
    context BlockContext mut? cast .parent Context.isGlobal return
    end-case
  }
}
Context.procContext proc( Context => ProcContext optional ){
  Context context =:
  context .cType switch{
  ROOT_CONTEXT case
    ProcContext empty return
    end-case
  PROC_CONTEXT case
    context ProcContext cast wrap return
    end-case
  BLOCK_CONTEXT case
    context BlockContext cast .parent Context.procContext return
    end-case
  }
}
Context.level proc( Context mut? => int ){
  Context mut? context =:
  context .cType switch{
  ROOT_CONTEXT PROC_CONTEXT case
    0 return
    end-case
  BLOCK_CONTEXT case
    context BlockContext mut? cast .parent Context.level 1 + return
    end-case
  }
}
Context.ensureDeclareable proc( #+context+# Context mut? #+name+#string #+type+# DeclareableType #+pos+# FilePosition mut?
  => #+localName+# string ){
  FilePosition mut? fPos =:
  DeclareableType dType =:
  string name =:
  Context mut? context =:
  context .cType ContextType .ROOT_CONTEXT == if{ context name RootContext.inCurrentModule else name } string localName =:
  context .elements localName clone-mut~ HashMap.get if{
    Declareable mut? prev =:
    ## procedures can overwrite predeclared procedures
    prev .dType DeclareableType .PREDECLARED_PROCEDURE != ||{ prev .dType DeclareableType .PROCEDURE != } if{
      128 buildString
      "cannot declare " <<* false dType <<DeclareableType ' ' << name <<*
      ", the identifier is already used by " <<* true prev .dType <<DeclareableType
      " (declared at " <<* prev .pos << ") at " <<* fPos << '\n' << build eputs
      1 exit
    }
  }
  context name Context.getDeclareable if{
    Declareable mut? shadowed =:
    128 buildString
    "Warning: " <<* false dType <<DeclareableType " " <<* name <<*
    " declared at " <<* fPos << "\n     shadows existing " <<*
    false shadowed .dType <<DeclareableType " declared at " <<*
    shadowed .pos << '\n' << build eputs
  }
  localName clone-mut~ return
}
Context.declareVariable proc( #+context+# Context mut #+name+# string #+isConst+# bool #+pos+# FilePosition mut? => VariableId ){
    FilePosition mut? fPos =:
    bool isConst =:
    string name mut =:
    Context mut context =:
    isConst if{ DeclareableType .FINAL_VARIABLE else DeclareableType .VARIABLE_ID } DeclareableType dType =:
    context name dType fPos Context.ensureDeclareable name =
    dType fPos context Context.isGlobal context Context.level context .varCount VariableId new VariableId varId =:
    context Context.incVarCount
    varId context .elements name HashMap.put drop
    varId return
}
Context.getDeclareable proc( #+context+# Context mut? #+name+# string => Declareable mut? optional ){
    string name =:
    Context mut? context =:
    context .cType switch{
    ROOT_CONTEXT case
      context RootContext.currentPaths paths =::
      paths .length 1 - int i mut =:
      while{ i 0 >= do ##go through all namespaces
        context .elements paths i [] buildString name <<* build HashMap.get dup .hasValue if{
          #+element+# Declareable mut? optional cast return
        else drop }
        i 1 - i =
      }
      context .elements name HashMap.get return
      end-case
    PROC_CONTEXT BLOCK_CONTEXT case
      context .elements name HashMap.get dup .hasValue if{
        #+element+# Declareable mut? optional cast return
      else drop
        context BlockContext mut? cast .parent name Context.getDeclareable return
      }
      end-case
    }
}
MODULE_SEPARATOR #define '\'' #end
##token that signals the compiler, that there will be no more statements in the current code-section
END_OF_SECTION #define "##" #end
RootContext.startFile proc( RootContext mut? => ){
  .openFiles newOpenFile << drop
}
RootContext.file proc( RootContext mut? => OpenFile ){
  RootContext mut? context =:
  context .openFiles context .openFiles .length 1 - [] return
}

RootContext.inCurrentModule proc( RootContext mut? #+name+# string => string ){
   string name =:
   #+context+# RootContext.file .openModules namespaces =::
   name .length buildString path =::
   namespaces .length 0 > if{
     0 int i mut =:
     while{ i namespaces .length < do
        namespaces i [] .path string list paths =:
        0 int j mut =:
        while{ j paths .length < do
          path paths j [] <<* MODULE_SEPARATOR << path =
          j 1 + j =
        }
        i 1 + i =
     }
   }
   path name <<* build return
}
RootContext.startModule proc( RootContext mut? #+name+# string #+declaredAt+# FilePosition mut? => ){
  FilePosition mut? fPos =:
  string name =:
  RootContext mut? context =:
  context .elements context name RootContext.inCurrentModule HashMap.get if{
    Declareable mut? d =:
    64 buildString
    "cannot declare namespace " <<* name <<* ", the identifier is already used by " <<*
    true d .dType <<DeclareableType
    " (declared at " <<* d .pos << ")\n at " <<*
    fPos  << '\n' << build eputs
    1 exit
  }
  context "" RootContext.inCurrentModule buildString fullPath =::
  16 string list mut new path =::
  16 buildString tmp =::
  0 int i mut =:
  while{ i name .length < do
    fullPath name i [] << fullPath =
    name i [] MODULE_SEPARATOR == if{
      true context .namespaces fullPath build HashMap.put drop
      path tmp build << path =
      tmp clear
    else
      tmp name i [] << tmp =
    }
    i 1 + i =
  }
  path tmp build << path =
  fullPath MODULE_SEPARATOR << fullPath =
  true context .namespaces fullPath build HashMap.put drop
  context RootContext.file .openModules path clone-mut~ fPos newOpenModule << drop
}
RootContext.addImport proc( RootContext mut? #+name+# string #+declaredAt+# FilePosition mut? => ){
  FilePosition mut? fPos =:
  string name0 =:
  name0 buildString '\'' << build string name =:
  RootContext mut? context =:
  context .namespaces name HashMap.contains if{
     context RootContext.file OpenFile file =:
     file .openModules .length 0 > if{
         file .openModules file .openModules .length 1 - [] .imports name << drop
     else
         file .globalImports name << drop
     }
  else context .elements name HashMap.get if
    drop
    "static imports are currently unimplemented"
    1 exit
  else
    64 buildString
    "namespace " <<* name0 <<* " does not exist " <<* fPos << '\n' << build eputs
    1 exit
  }
}
RootContext.endModule proc( RootContext mut? FilePosition mut? => ){
  FilePosition mut? fPos =:
  RootContext mut? context =:
  context RootContext.file OpenFile file =:
  file .openModules .length 0 == if{
    64 buildString
    "Unexpected End of namespace " <<* fPos << '\n' << build eputs
    1 exit
  }
  file .openModules file .openModules .length 1 - [] OpenModule removed =:
  file .openModules file .openModules .length 1 - file .openModules .length [:] clear
  removed .predeclared .size 0 > if{
    256 buildString "Syntax Error: missing variables/procedures" <<* stringBuilder message =:
    removed .predeclared ^_ for{
       string PredeclaredProc MapEntry mut? e =:
       message "\n- " <<* e .key string cast <<* " (at " <<* e .value .pos << ')' << drop
    } drop
    message fPos << '\n' << build eputs
    1 exit
  }
}
RootContext.endFile proc( RootContext mut? FilePosition mut? => ){
  FilePosition mut? fPos =:
  RootContext mut? context =:
  context .openFiles context .openFiles .length 1 - [] OpenFile closed =:
  context .openFiles context .openFiles .length 1 - context .openFiles .length [:] clear
  closed .openModules .length 0 > if{
    "unclosed namespaces at end of File:\n" eputs
    closed .openModules .length 1 - int i mut =:
    while{ i 0 >= do
      closed .openModules i [] OpenModule removed =:
      removed .predeclared .size 0 > if{
        64 buildString "Syntax Error: missing variables/procedures" <<* message =::
        removed .predeclared ^_ for{
           string PredeclaredProc MapEntry mut? e =:
           message "\n- " <<* e .key string cast <<* " (at " <<* e .value .pos << ')' << drop
        } drop
        message fPos << '\n' << build eputs
        1 exit
      }
      32 buildString " - " <<* removed << '\n' << build eputs
      i 1 - i =
    }
    closed .openModules clear
  }
  closed .globalPredeclared .size 0 > if{
    256 buildString "Syntax Error: missing variables/procedures" <<* message =::
    closed .globalPredeclared ^_ for{
       string PredeclaredProc MapEntry mut? e =:
       message "\n- " <<* e .key string cast <<* " (at " <<* e .value .pos << ')' << drop
    } drop
    message fPos << '\n' << build eputs
    1 exit
  }
}

RootContext.currentPaths proc( RootContext mut? => string list mut ){
  #+context+# RootContext.file OpenFile file =:
  file .globalImports clone string list mut paths mut =:
  16 buildString path =::
  file .openModules namespaces =::
  0 int i mut =:
  while{ i namespaces .length < do
    namespaces i [] .path string list mPath =:
    0 int j mut =:
    while{ j mPath .length < do
      path mPath j [] <<* MODULE_SEPARATOR << path =
      j 1 + j =
      paths path build << paths =
    }
    namespaces i [] .imports  paths paths .length 1 - paths .length 1 - [:]=
    i 1 + i =
  }
  paths return
}
RootContext.predeclared proc( RootContext => string Declareable HashMap ){
  #+context+# RootContext.file OpenFile file =:
  file .openModules .length 0 > if{
    file .openModules file .openModules .length 1 - [] .predeclared return
  else
    file .globalPredeclared return
  }
}

RootContext.declareProcedure proc( #+context+# RootContext #+name+# string #+proc+# Procedure => ){
  Procedure aProc =:
  string name =:
  RootContext context =:
  context name DeclareableType .PROCEDURE aProc .pos Context.ensureDeclareable name =
  context RootContext.predeclared name HashMap.remove if{
    drop
  }
  context .elements name aProc HashMap.put drop
}

RootContext.declareMacro proc( #+context+# RootContext mut? #+macro+# Macro mut? => ){
  Macro mut? macro =:
  macro .name string name mut =:
  RootContext mut? context =:
  context name DeclareableType .MACRO macro .pos Context.ensureDeclareable name =
  macro context .elements name HashMap.put drop
}
RootContext.removeMacro proc( #+context+# RootContext mut? #+name+# string #+pos+# FilePosition mut? => ){
  FilePosition mut? fPos =:
  string name =:
  RootContext mut? context =:
  context .elements context name RootContext.inCurrentModule HashMap.remove if{
    Declareable mut? removed =:
    removed .dType DeclareableType .MACRO != if{
      128 buildString
      "macro " <<* name <<* " does not exists, or is shadowed by " <<*
      false removed .dType <<DeclareableType
      " (declared at " <<* removed .pos << ") " <<*
      fPos << '\n' << build eputs
      1 exit
    }
  else
    64 buildString
    "macro " <<* name <<* " does not exists in the current namespace " <<* fPos << '\n' << build eputs
    1 exit
  }
}
RootContext.declareEnum proc( #+context+# RootContext mut? #+source+# EnumBlock mut? => ){
  EnumBlock mut? source =:
  source .name string name mut =:
  RootContext mut? context =:
  source .startPos name source .elements clone-mut~ newEnum Enum anEnum =:
  context name DeclareableType .ENUM anEnum .pos Context.ensureDeclareable name =
  anEnum context .elements name HashMap.put drop
  ##declare enum entries
  0 int i mut =:
  anEnum .enumType .fields NameWithPos list fields =:
  while{ i fields .length < do
    source .name buildString MODULE_SEPARATOR << fields i [] .name <<* build fieldName =::
    context fieldName DeclareableType .ENUM_ENTRY fields i [] .pos Context.ensureDeclareable fieldName =
    anEnum .enumType i newEnumEntry context .elements fieldName HashMap.put drop
    i 1 + i =
  }
}
RootContext.declareTuple proc( #+context+# RootContext mut? #+tuple+# Tuple => ){
  Tuple aTuple =:
  aTuple .tupleType .name string name mut =:
  RootContext mut? context =:
  context name DeclareableType .TUPLE aTuple .pos Context.ensureDeclareable name =
  aTuple context .elements name HashMap.put drop
}

TokenType enum{
  WORD
  KEY_WORD
  PROCEDURE_START
  ENUM_START
  VALUE
  IDENTIFIER
  VARIABLE
  OPERATOR
  BLOCK_TOKEN
  CONTEXT_OPEN
  CONTEXT_CLOSE
}
Token struct{
  TokenType         :tokenType
  FilePosition mut? :pos
}

WordToken struct{ Token extend
  string :value
}

ValueToken struct{ Token extend
  Value :value
}

BlockTokenType enum{ IF ELSE _IF END-IF WHILE DO END-WHILE DO-WHILE SWITCH CASE END-CASE DEFAULT END-SWITCH }
BlockToken struct{ Token extend
  BlockTokenType :blockType
  int            :target    mut
}

ContextToken struct{ Token extend
  Context mut? :context
}
ContextToken.varCount proc( ContextToken mut? => int ){ .context .varCount }

IdentifierType enum{
  WRITE
  DECLARE
  CONST_DECLARE
  ADDRESS_OF
}
IdentifierToken struct{ Token extend
  IdentifierType :idType
  string         :value
}

OperatorType enum{
  PLUS MINUS NEGATE INVERT MULTIPLY DIVIDE MOD
  NOT FLIP AND OR XOR  SHIFT_L SHIFT_R
  LT LE EQ REF_EQ REF_NE NE GE GT
}
OperatorToken struct{ Token extend
  OperatorType :opType
}

AccessType enum{
  DECLARE_CONST DECLARE_VAR WRITE_VAR READ_VAR
}
VariableToken struct{ Token extend
  AccessType      :accessType
  VariableId mut? :id
}

<< proc( stringBuilder Token mut? => stringBuilder ){
  Token mut? token =:

  TokenType .fieldNames token .tokenType [] <<* ": " <<*
  token .tokenType switch{
  WORD KEY_WORD PROCEDURE_START ENUM_START case
    token WordToken mut? cast .value <<*
    end-case
  VALUE case
    token ValueToken mut? cast .value <<
    end-case
  BLOCK_TOKEN case
    BlockTokenType .fieldNames token BlockToken mut? cast .blockType [] <<* '(' << token BlockToken mut? cast .target stringValue <<* ')' <<
    end-case
  IDENTIFIER case
    IdentifierType .fieldNames token IdentifierToken mut? cast .idType [] <<* ": " <<* token IdentifierToken mut? cast .value <<*
    end-case
  OPERATOR case
    OperatorType .fieldNames token OperatorToken mut? cast .opType [] <<*
    end-case
  VARIABLE case
    AccessType .fieldNames token VariableToken mut? cast .accessType [] <<* " " <<*
    token VariableToken mut? cast .id << " " <<*
    end-case
  CONTEXT_CLOSE case end-case
  CONTEXT_OPEN case
    token ContextToken.varCount stringValue <<*
    end-case
  }
}

ParserReader struct{
  BufferedInput    :in
  FilePosition mut :pos
  stringBuilder    :word
  FilePosition mut :wordPos
}
ParserReader.nextWord proc( ParserReader => ){
  ParserReader reader =:
  reader .word clear
  reader .pos .line       reader .wordPos .line =
  reader .pos .posInLine  reader .wordPos .posInLine =
}
ParserReader.nextByte proc( ParserReader => byte optional ){
  ParserReader reader =:
  reader .in BufferedInput.nextByte byte optional next =:
  next if{
    '\n' == if{
      reader .pos FilePosition.newLine
    else
      reader .pos FilePosition.nextChar
    }
  }
  next return
}

ParseState enum{
  STATE_WORD
  STATE_STRING
  STATE_USTRING
  STATE_CHAR
  STATE_UCHAR
  STATE_COMMENT
  STATE_LINE_COMMENT
}

OpenBlocks struct{
  Macro mut              :currentMacro mut
  CodeBlock mut list mut :blocks
}
Program struct{
  Token mut list mut :tokens
  Context mut        :context mut
}

parseWord proc( #+word+# string #+next+# string #+pos+# FilePosition mut? #+open_blocks+# OpenBlocks mut
  #+program+# Program mut => ){
  Program mut program =:
  program .context context =::
  program .tokens tokens =::
  OpenBlocks mut openBlocks =:
  FilePosition mut? fPos =:
  string next =:
  string word =:
  word .length 0 > if{
    openBlocks .currentMacro .name .length 0 > if{
      word switch{
      "#end" case
        context openBlocks .currentMacro RootContext.declareMacro
        fPos "" newMacro  openBlocks .currentMacro =
        end-case
      "#define" "#undef" "#namespace" "#include" "#import" "proc" "procedure" "enum" "tuple" case
        word buildString " is not allowed in macros " <<* fPos << '\n' << build eputs
        1 exit
        end-case
      default
        openBlocks .currentMacro .words word clone-mut~ fPos NameWithPos new << drop
      }
      return
    }
    ##keywords that consume one or more words
    word switch{
    ## identifier - modifiers
    "."  case
      tokens .length 2 < if{
        "not enough arguments for . " buildString fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 2 - [] Token mut prePrev =:
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for '.' modifier: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      prePrev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for '.' modifier: " <<* prePrev << ' ' << prePrev .pos << '\n' << build eputs
        1 exit
      }
      TokenType .WORD fPos prePrev WordToken mut? cast .value buildString '\'' << prev WordToken mut? cast .value <<* build WordToken mut new
       tokens tokens .length 2 - []=
      tokens tokens .length 1 - tokens .length [:] clear
      end-case
    "="  case
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for '=' modifier: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .WRITE prev WordToken mut cast .value IdentifierToken mut new  tokens tokens .length 1 - []=
      end-case
    "=:" case
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for '=:' modifier: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .DECLARE prev WordToken mut cast .value IdentifierToken mut new  tokens tokens .length 1 - []=
      end-case
    "=$" case
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for '=$' modifier: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .CONST_DECLARE prev WordToken mut cast .value IdentifierToken mut new
        tokens tokens .length 1 - []=
      end-case
    "@()" case
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for '@()' modifier: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      TokenType .IDENTIFIER fPos IdentifierType .ADDRESS_OF prev WordToken mut cast .value IdentifierToken mut new
        tokens tokens .length 1 - []=
      end-case
    ## macro&namespace key-words
    "#define" case
      tokens .length 0 == if{
        32 buildString
        "missing macro name " <<* fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for macro name: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      prev WordToken mut cast .value  openBlocks .currentMacro .name =
      prev .pos        openBlocks .currentMacro .pos =
      end-case
    "#undef" case
      openBlocks .blocks .length 0 > if{
        64 buildString
        "macros can only be undefined at root-level " <<* fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token preceding #undef: " <<* prev << ' ' << prev .pos <<
        " expected macro-name \n" <<* build eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken mut cast .value fPos RootContext.removeMacro
      end-case
    "#namespace" case
      openBlocks .blocks .length 0 > if{
        64 buildString
        "namespaces can only be declared at root-level " <<* fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for namespace name: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken mut cast .value fPos RootContext.startModule
      end-case
    "#end" case
      openBlocks .blocks .length 0 > if{
        64 buildString
        "namespaces can only be closed at root-level " <<* fPos << '\n' << build eputs
        1 exit
      }
      END_OF_SECTION "" fPos openBlocks program parseWord
      context fPos RootContext.endModule
      end-case
    "#import" case
      openBlocks .blocks .length 0 > if{
        64 buildString
        "imports  are can only allowed at root-level " <<* fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "imported namespace name has to be an identifier, got " <<*
           prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      context prev WordToken mut cast .value fPos RootContext.addImport
      end-case
    "#include" case
      "unimplemented\n" eputs
      1 exit
      end-case
    ## proc/enum key-words
    "proc" "procedure" case
      tokens .length 0 == if{
        64 buildString
        "missing procedure name " <<* fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for procedure name: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      TokenType .PROCEDURE_START fPos prev WordToken mut cast .value WordToken mut new  tokens tokens .length 1 - []=
      openBlocks .blocks BlockType .PROC_BLOCK fPos tokens .length CodeBlock mut new << drop
      end-case
    "enum" case
      tokens .length 0 == if{
        64 buildString
        "missing enum name " <<* fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for enum name: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      openBlocks .blocks prev WordToken mut cast .value fPos tokens .length newEnumBlock << drop
      end-case
    "tuple" case
      tokens .length 0 == if{
        64 buildString
        "missing tuple name " <<* fPos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - [] Token mut prev =:
      prev .tokenType TokenType .WORD != if{
        64 buildString
        "invalid token for tuple name: " <<* prev << ' ' << prev .pos << '\n' << build eputs
        1 exit
      }
      tokens tokens .length 1 - tokens .length [:] clear
      openBlocks .blocks prev WordToken mut cast .value fPos tokens .length newTupleBlock << drop
      end-case
    default
      tokens .length 0 > &&{ next "." != } if{
        tokens tokens .length 1 - [] Token mut prev =:
        prev .tokenType TokenType .IDENTIFIER == if{
          prev IdentifierToken mut cast .idType switch{
          DECLARE CONST_DECLARE case
            context
            prev IdentifierToken mut cast .value
            prev IdentifierToken mut cast .idType IdentifierType .DECLARE !=
            prev .pos
            Context.declareVariable VariableId id =:
            prev IdentifierToken mut cast .idType IdentifierType .DECLARE != if{
              AccessType .DECLARE_VAR else AccessType .DECLARE_CONST } AccessType aType =:
            TokenType .VARIABLE prev .pos aType id VariableToken mut new
              tokens tokens .length 1 - []=
            end-case
          WRITE case
            context prev IdentifierToken mut cast .value Context.getDeclareable if{
              Declareable mut? d =:
              d .dType DeclareableType .VARIABLE_ID != if{
                64 buildString
                false d .dType <<DeclareableType " " <<* prev IdentifierToken mut cast .value <<*
                " (declared at " <<* d .pos << ") is not a variable" <<*
                fPos << '\n' << build eputs
                1 exit
              }
              ##context.wrapCurried(identifier.name,id,identifier.pos);
              TokenType .VARIABLE prev .pos AccessType .WRITE_VAR d VariableToken mut new
                tokens tokens .length 1 - []=
            else
              64 buildString
              "variable " <<* prev IdentifierToken mut cast .value <<* " does not exist " <<* fPos << '\n' << build eputs
              1 exit
            }
            end-case
          ADDRESS_OF case
            "unimplemented\n" eputs
            1 exit
            end-case
          }
        else  prev .tokenType TokenType .WORD == if
          context prev WordToken mut cast .value Context.getDeclareable if{
            Declareable mut? d =:
            d .dType switch{
            MACRO case
              d Macro mut? m =:
              tokens tokens .length 1 - tokens .length [:] clear ##remove prev
              0 int i mut =:
              while{ i m .words .length < do
                m .words i [] NameWithPos s =:
                i 1 + m .words .length < if{ m .words i 1 + [] .name else "##" } string nxt =:
                s .name nxt prev .pos openBlocks program parseWord
                i 1 + i =
              }
              ## update identifiers at end of macro
              END_OF_SECTION next prev .pos openBlocks program parseWord
              end-case
            ENUM case
              TokenType .VALUE fPos d Enum mut? cast .enumType Value.ofType ValueToken mut new
                tokens tokens .length 1 - []=
              end-case
            ENUM_ENTRY case
              TokenType .VALUE fPos d EnumEntry mut? cast .enumType d Value new ValueToken mut new
                tokens tokens .length 1 - []=
              end-case
            TUPLE case
              TokenType .VALUE fPos d Tuple mut? cast .tupleType Value.ofType ValueToken mut new
                tokens tokens .length 1 - []=
              end-case
            FINAL_VARIABLE VARIABLE_ID case
              ##id=context.wrapCurried(identifier.name,id,identifier.pos);
              TokenType .VARIABLE prev .pos AccessType .READ_VAR d VariableToken mut new
                tokens tokens .length 1 - []=
            end-case
            PREDECLARED_PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            PROCEDURE case
              "resolving procedures is currently unimplemented\n" eputs
              1 exit
              end-case
            }
          else
          }
        }
      }
      ## try parsing as integer
      0 int off mut =:
      ## detect signs
      false bool sgn mut =:
           word 0 [] '-' ==  if{
        true sgn =
        off 1 + off =
      else word 0 [] '+' == if
        off 1 + off =
      }
      10 int base mut =:
      ##detect base modifiers
      word .length off - 3 > if{
             word off off 2 + [:] "0b" ==  if{
          2 base =
          off 2 + off =
        else word off off 2 + [:] "0x" == if
          16 base =
          off 2 + off =
        }
      }
      off word .length < &&{ word off [] base valueOfDigit 0 >= } if{ ##number starts with digit after prefixes
        word word .length 1 - [] 'u' == ||{ word word .length 1 - [] 'U' == } if{ ##unsigned
          word off word .length 1 - [:] base false stringToInt switch{
          ERR_NONE case
            sgn if{ -_ } uint val =:
            tokens TokenType .VALUE fPos val Value.ofUInt ValueToken mut new << tokens =
            return
            end-case
          ERR_OVERFLOW case
            64 buildString
            "value does not fit in an unsigned int: \"" <<* word <<* "\" " <<*
                fPos << '\n' << build eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          }
        else
          word off word .length [:] base true stringToInt switch{
          ERR_NONE case
              sgn if{ -_ } int val =:
              tokens TokenType .VALUE fPos val Value.ofInt ValueToken mut new << tokens =
              return
            end-case
          ERR_OVERFLOW case
            64 buildString
            "value does not fit in a signed int: \"" <<* word <<* "\" " <<*
                fPos << '\n' << build eputs
            1 exit
            end-case
          ERR_BASE ERR_EMPTY ERR_ILLEGAL_CHAR case
            drop
            end-case
          }
          word off word .length [:] base stringToFloat StringParseError .ERR_NONE == if{
            sgn if{ -_ } float val =:
            tokens TokenType .VALUE fPos val Value.ofFloat ValueToken mut new << tokens =
            return
          else
            drop
          }
        }
      }
      ## end integer parsing
      ##constants, operators and remaining keywords
      word switch{
      END_OF_SECTION case
        ##do nothing
        end-case
      ## detect true and false
      "true" case
        tokens TokenType .VALUE fPos Value.TRUE  ValueToken mut new << tokens =
        end-case
      "false" case
        tokens TokenType .VALUE fPos Value.FALSE ValueToken mut new << tokens =
        end-case
      ## detect primitive type-names
      "bool" case
        tokens TokenType .VALUE fPos Type.BOOL Value.ofType ValueToken mut new << tokens =
        end-case
      "byte" case
        tokens TokenType .VALUE fPos Type.BYTE Value.ofType ValueToken mut new << tokens =
        end-case
      "codepoint" case
        tokens TokenType .VALUE fPos Type.CODEPOINT Value.ofType ValueToken mut new << tokens =
        end-case
      "int" case
        tokens TokenType .VALUE fPos Type.INT  Value.ofType ValueToken mut new << tokens =
        end-case
      "uint" case
        tokens TokenType .VALUE fPos Type.UINT Value.ofType ValueToken mut new << tokens =
        end-case
      "float" case
        tokens TokenType .VALUE fPos Type.FLOAT Value.ofType ValueToken mut new << tokens =
        end-case
      "type" case
        tokens TokenType .VALUE fPos Type.TYPE Value.ofType ValueToken mut new << tokens =
        end-case
      "var" case
        tokens TokenType .VALUE fPos Type.VAR Value.ofType ValueToken mut new << tokens =
        end-case
      ## control-flow key-words
      "lambda" "λ" case
        openBlocks .blocks BlockType .PROC_BLOCK fPos tokens .length CodeBlock mut new << drop
        tokens TokenType .KEY_WORD fPos word WordToken mut new << tokens =
        end-case
      "return" "exit" case
        tokens TokenType .KEY_WORD fPos word WordToken mut new << tokens =
        end-case
      "=>" ":" case
        openBlocks .blocks .length 0 == if{
          64 buildString
          word <<* " can only be used in (lambda-)procedures " <<* fPos << '\n' << build eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock mut block =:
        block .blockType BlockType .PROC_BLOCK != if{
          64 buildString
          word <<* " can only be used in (lambda-)procedures " <<* fPos << '\n' << build eputs
          1 exit
        }
        tokens TokenType .KEY_WORD fPos word WordToken mut new << tokens =
        end-case
      "while" case
        openBlocks .blocks  fPos tokens .length newWhileBlock  << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .WHILE 0 BlockToken mut new << tokens =
        end-case
      "do" case
        openBlocks .blocks .length 0 == if{
          64 buildString
          word <<* " can only be used in while-statement " <<* fPos << '\n' << build eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock mut block =:
        block .blockType BlockType .WHILE_BLOCK != if{
          64 buildString
          word <<* " can only be used in while-statement " <<* fPos << '\n' << build eputs
          1 exit
        }
        block WhileBlock mut wBlock =:
        wBlock .forkPos -1 != if{
          128 buildString
          "duplicate 'do' in while-statement " <<* fPos <<
          "\n previous appearance at " <<* tokens wBlock .forkPos [] .pos << '\n' << build eputs
          1 exit
        }
        tokens .length wBlock .forkPos =
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .DO -1 BlockToken mut new << tokens =
        ##open while-context
        context newBlockContext context =
        context program .context =
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken mut new << tokens =
        end-case
      "if" case
        openBlocks .blocks  fPos tokens .length newIfBlock  << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .IF 0 BlockToken mut new << tokens =
        ##open if-context
        context newBlockContext context =
        context program .context =
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken mut new << tokens =
        end-case
      "else" case
        openBlocks .blocks .length 0 == if{
          64 buildString
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << build eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock mut block =:
        block .blockType BlockType .IF_BLOCK != if{
          64 buildString
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << build eputs
          1 exit
        }
        block IfBlock mut iBlock =:
        iBlock .prevIf -1 == if{
          128 buildString
          "unexpected 'else'-statement, 'else' can only appear after 'if' or '_if' " <<*
          fPos << '\n' << build eputs
          1 exit
        }
        ##close if-context
        context BlockContext mut cast .parent context =
        context program .context =
        tokens TokenType .CONTEXT_CLOSE fPos Token mut new << tokens =
        iBlock .else_positions .length 0 > if{
          ##close else-context
          tokens TokenType .CONTEXT_CLOSE fPos Token mut new << tokens =
        }
        iBlock .else_positions tokens .length << drop
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .ELSE -1 BlockToken mut new << tokens =
        tokens iBlock .prevIf [] Token mut tmp =:
        tmp .tokenType TokenType .BLOCK_TOKEN == &&{
          tmp BlockToken mut cast .blockType BlockTokenType .IF == ||{ tmp BlockToken mut cast .blockType BlockTokenType ._IF == } }
          "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
        tokens .length iBlock .prevIf - tmp BlockToken mut cast .target =
        -1 iBlock .prevIf =
        iBlock .else_positions .length 1 <= if{
          ##open else-context
          context newBlockContext context =
          context program .context =
          tokens TokenType .CONTEXT_OPEN fPos context ContextToken mut new << tokens =
        }
        end-case
      "_if" case
        openBlocks .blocks .length 0 == if{
          64 buildString
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << build eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock mut block =:
        block .blockType BlockType .IF_BLOCK != if{
          64 buildString
          word <<* " can only be used in if-blocks " <<* fPos << '\n' << build eputs
          1 exit
        }
        block IfBlock mut iBlock =:
        iBlock .prevIf -1 != if{
          64 buildString
          "unexpected '_if'-statement, '_if' can only appear after 'else' " <<*
            fPos << '\n' << build eputs
          1 exit
        }
        tokens .length iBlock .prevIf =
        tokens TokenType .BLOCK_TOKEN fPos BlockTokenType ._IF 0 BlockToken mut new << tokens =
        ##open if-context
        context newBlockContext context =
        context program .context =
        tokens TokenType .CONTEXT_OPEN fPos context ContextToken mut new << tokens =
        end-case
      "switch" case
        openBlocks .blocks BlockType .SWITCH_BLOCK fPos tokens .length CodeBlock mut new << drop
        tokens TokenType .KEY_WORD fPos word WordToken mut new << tokens =
        end-case
      "case" "end-case" "default" case
        openBlocks .blocks .length 0 == if{
          64 buildString
          word <<* " can only be used in switch-blocks " <<* fPos << '\n' << build eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock mut block =:
        block .blockType BlockType .SWITCH_BLOCK != if{
          64 buildString
          word <<* " can only be used in switch-blocks " <<*  fPos << '\n' << build eputs
          1 exit
        }
        tokens TokenType .KEY_WORD fPos word WordToken mut new << tokens =
        end-case
      "end" case
        openBlocks .blocks .length 0 == if{
          64 buildString
          "unexpected end-statement " <<* fPos << '\n' << build eputs
          1 exit
        }
        openBlocks .blocks openBlocks .blocks .length 1 - [] CodeBlock mut block =:
        openBlocks .blocks openBlocks .blocks .length 1 - openBlocks .blocks .length [:] clear
        block .blockType switch{
        IF_BLOCK case
          block IfBlock mut iBlock =:
          iBlock .prevIf -1 != if{
            ##close if-context
            context BlockContext mut cast .parent context =
            context program .context =
            tokens TokenType .CONTEXT_CLOSE fPos Token mut new << tokens =
            tokens iBlock .prevIf [] Token mut tmp =:
            tmp .tokenType TokenType .BLOCK_TOKEN == &&{
              tmp BlockToken mut cast .blockType BlockTokenType .IF == ||{ tmp BlockToken mut cast .blockType BlockTokenType ._IF == } }
              "token at fork-pos of If-statement has to be BlockToken:'if' or BlockToken:'_if'" assert
            tokens .length iBlock .prevIf - tmp BlockToken mut cast .target =
            iBlock .else_positions .length 0 > if{
              ## close-else context
              tokens TokenType .CONTEXT_CLOSE fPos Token mut new << tokens =
            }
          else
            ## close-else context
            tokens TokenType .CONTEXT_CLOSE fPos Token mut new << tokens =
          }
          0 int i mut =:
          while{ i iBlock .else_positions .length < do
            tokens iBlock .else_positions i [] [] Token mut tmp =:
            tmp .tokenType TokenType .BLOCK_TOKEN == &&{ tmp BlockToken mut cast .blockType BlockTokenType .ELSE == }
            "token at end of if-branch has to be BlockToken:'else'" assert
            tokens .length iBlock .else_positions i [] - tmp BlockToken mut cast .target =
            i 1 + i =
          }
          iBlock .else_positions .length 0 > if{
            ##close-else context
            context BlockContext mut cast .parent context =
            context program .context =
          }
          tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .END-IF 0 BlockToken mut new << tokens =
          end-case
        WHILE_BLOCK case
          block WhileBlock mut wBlock =:
          wBlock .forkPos -1 == if{
            64 buildString
            "while block at " <<* wBlock .startPos << " does not contain a 'do' statement " <<*
            fPos << build eputs
            1 exit
          }
          ##close context
          context BlockContext mut cast .parent context =
          context program .context =
          tokens TokenType .CONTEXT_CLOSE fPos Token mut new << tokens =
          tokens wBlock .forkPos [] Token mut tmp =:
          tmp .tokenType TokenType .BLOCK_TOKEN == &&{ tmp BlockToken mut cast .blockType BlockTokenType .DO == }
            "token at fork-pos of While has to be BlockToken:'do'" assert
          wBlock .forkPos tokens .length 3 - == if{ ## do context-open context-close end
            tokens tokens .length 2 - tokens .length [:] clear ##remove context open/close
            TokenType .BLOCK_TOKEN fPos BlockTokenType .DO-WHILE wBlock .start tokens .length 1 - - BlockToken mut new
              tokens wBlock .forkPos []=
          else
            tokens TokenType .BLOCK_TOKEN fPos BlockTokenType .END-WHILE
              wBlock .start tokens .length - BlockToken mut new << tokens =
            tokens .length wBlock .forkPos - tmp BlockToken mut cast .target =
          }
          end-case
        SWITCH_BLOCK case
          "Waring closing switch-blocks is currently not implemented\n" eputs
          end-case
        PROC_BLOCK case
          "Waring closing proc-blocks is currently not implemented\n" eputs
          end-case
        ENUM_BLOCK case
          tokens .length block .start > if{
            64 buildString
            "Invalid token in enum: " <<* tokens block .start [] << ' '
              << tokens block .start [] .pos << '\n' << build eputs
            1 exit
          }
          context block RootContext.declareEnum
          end-case
        TUPLE_BLOCK case
          block TupleBlock mut tBlock =:
          tokens tBlock .start tokens .length [:] subList =::
          subList constEvaluate values =::
          subList clear
          values .length Type list mut new types =::
          0 int i mut =:
          while{ i values .length < do
            values i [] .tokenType TokenType .VALUE != if{
              128 buildString
              "tokens of type:" <<* TokenType .fieldNames values i [] .tokenType [] <<* " are not allowed in tuple signatures " <<*
              values i [] .pos << '\n' << build eputs
              1 exit
            else values i [] ValueToken mut cast .value .valType Type.TYPE != if
              128 buildString
              "values of type:" <<* values i [] ValueToken mut cast .value .valType << " are not allowed in tuple signatures " <<*
              values i [] .pos << '\n' << build eputs
              1 exit
            }
             types values i [] ValueToken mut cast .value .data Type cast << types =
             i 1 + i =
          }
          values clear
          context
          DeclareableType .TUPLE  tBlock .startPos   tBlock .name  types clone-mut~ newTupleType   Tuple new
          RootContext.declareTuple
          end-case
        }
        end-case
      ## operators
      "+" case
        tokens TokenType .OPERATOR fPos OperatorType .PLUS OperatorToken mut new << tokens =
        end-case
      "-" case
        tokens TokenType .OPERATOR fPos OperatorType .MINUS OperatorToken mut new << tokens =
        end-case
      "-_" case
        tokens TokenType .OPERATOR fPos OperatorType .NEGATE OperatorToken mut new << tokens =
        end-case
      "*" case
        tokens TokenType .OPERATOR fPos OperatorType .MULTIPLY OperatorToken mut new << tokens =
        end-case
      "/" case
        tokens TokenType .OPERATOR fPos OperatorType .DIVIDE OperatorToken mut new << tokens =
        end-case
      "%" case
        tokens TokenType .OPERATOR fPos OperatorType .MOD OperatorToken mut new << tokens =
        end-case

      "!" case
        tokens TokenType .OPERATOR fPos OperatorType .NOT OperatorToken mut new << tokens =
        end-case
      "~" case
        tokens TokenType .OPERATOR fPos OperatorType .FLIP OperatorToken mut new << tokens =
        end-case
      "&" case
        tokens TokenType .OPERATOR fPos OperatorType .AND OperatorToken mut new << tokens =
        end-case
      "|" case
        tokens TokenType .OPERATOR fPos OperatorType .OR OperatorToken mut new << tokens =
        end-case
      "xor" case
        tokens TokenType .OPERATOR fPos OperatorType .XOR OperatorToken mut new << tokens =
        end-case

      "<<" case
        tokens TokenType .OPERATOR fPos OperatorType .SHIFT_L OperatorToken mut new << tokens =
        end-case
      ">>" case
        tokens TokenType .OPERATOR fPos OperatorType .SHIFT_R OperatorToken mut new << tokens =
        end-case

      "<" case
        tokens TokenType .OPERATOR fPos OperatorType .LT OperatorToken mut new << tokens =
        end-case
      "<=" case
        tokens TokenType .OPERATOR fPos OperatorType .LE OperatorToken mut new << tokens =
        end-case
      "==" case
        tokens TokenType .OPERATOR fPos OperatorType .EQ OperatorToken mut new << tokens =
        end-case
      "===" case
        tokens TokenType .OPERATOR fPos OperatorType .REF_EQ OperatorToken mut new << tokens =
        end-case
      "=!=" case
        tokens TokenType .OPERATOR fPos OperatorType .REF_NE OperatorToken mut new << tokens =
        end-case
      "!=" case
        tokens TokenType .OPERATOR fPos OperatorType .NE OperatorToken mut new << tokens =
        end-case
      ">=" case
        tokens TokenType .OPERATOR fPos OperatorType .GE OperatorToken mut new << tokens =
        end-case
      ">" case
        tokens TokenType .OPERATOR fPos OperatorType .GT OperatorToken mut new << tokens =
        end-case
      default
        openBlocks .blocks .length 0 >
          &&{ openBlocks .blocks openBlocks .blocks .length 1 - [] .blockType BlockType .ENUM_BLOCK == } if{
          openBlocks .blocks openBlocks .blocks .length 1 - []
            EnumBlock mut cast .elements word fPos NameWithPos new << drop
        else
          tokens TokenType .WORD fPos word WordToken mut new << tokens =
        }
      }
    }
  }
}

readEscapeChar proc( ParserReader => ){
  ParserReader reader =:
  reader ParserReader.nextByte if{
    byte next =:
    next switch{
    '\\' '\'' '"' case
     reader .word next << drop
     end-case
    'n' case
     reader .word '\n' << drop
     end-case
    't' case
     reader .word '\t' << drop
     end-case
    'r' case
     reader .word '\r' << drop
     end-case
    'b' case
     reader .word '\b' << drop
     end-case
    'f' case
     reader .word '\f' << drop
     end-case
    '0' case
     reader .word '\0' << drop
     end-case
    'u' 'U' case
     "\\u is currently unimplemented" eputs
     1 exit
     end-case
    default
     64 buildString
     "The escape sequence: '\\" <<* next << "' is not supported " <<* reader .pos << '\n' << build eputs
     1 exit
    }
  else
    64 buildString
    "unexpected end of file " <<* reader .pos << '\n' << build eputs
    1 exit
  }
}

parseFile proc( #+fileName+# string #+program+# Program mut =>  ){
  Program mut program =:
  program .context context =::
  program .tokens tokens =::
  string fileName =:
  fileName "r" open if{ #+auto-unwrap+# else
    20 fileName .length + buildString
    "file \"" <<* fileName <<* "\" not found\n" <<* build eputs
    1 exit
  }
  16 newBufferedInput #+input+#
  fileName 1 1 FilePosition mut new   #+pos+#
  16 buildString                   #+word+#
  fileName 1 1 FilePosition mut new   #+wordPos+#
  ParserReader new ParserReader reader =:
  context RootContext.startFile
  ParseState .STATE_WORD ParseState state mut =:
  reader .pos "" newMacro 16 CodeBlock mut list mut new OpenBlocks mut new openBlocks =::

  "" string prevWord mut =:
  fileName 1 1 FilePosition mut new FilePosition mut prevPos mut =:

  while{ reader ParserReader.nextByte do
    #+next-char+#
    state switch{
      STATE_WORD case
        byte next mut =:
        next ?WhiteSpace if{
          reader .word .length 0 > if{
            reader .word build nextWord =::
            nextWord .length 0 > if{
              prevWord .length 0 > if{
                prevWord nextWord prevPos openBlocks program parseWord
              }
              nextWord prevWord =
              reader .wordPos clone prevPos =
            }
          }
          reader ParserReader.nextWord
        else
          next switch{
          '"' case
              reader .word build prefix =::
              prefix "u" == if{
                ParseState .STATE_USTRING state =
                reader .word clear
              else prefix .length 0 == if
                ParseState .STATE_STRING state =
              else
                64 buildString
                "illegal string-prefix: \"" <<* prefix <<* "\" " <<*
                   reader .pos << '\n' << build eputs
                1 exit
              }
            end-case
          '\'' case
              reader .word build prefix =::
              prefix "u" == if{
                ParseState .STATE_UCHAR state =
                reader .word clear
              else prefix .length 0 == if
                ParseState .STATE_CHAR state =
              else
                64 buildString
                "illegal char-prefix: \"" <<* prefix <<* "\" " <<*
                   reader .pos << '\n' << build eputs
                1 exit
              }
            end-case
          '#' case
              reader ParserReader.nextByte if{
                next =
                next '#' == if{
                  reader .word build nextWord =::
                  nextWord .length 0 > if{
                    prevWord .length 0 > if{
                      prevWord nextWord prevPos openBlocks program parseWord
                    }
                    nextWord prevWord =
                    reader .wordPos clone prevPos =
                  }
                  reader ParserReader.nextWord
                  ParseState .STATE_LINE_COMMENT state =
                else next '+' == if
                  reader .word build nextWord =::
                  nextWord .length 0 > if{
                    prevWord .length 0 > if{
                      prevWord nextWord prevPos openBlocks program parseWord
                    }
                    nextWord prevWord =
                    reader .wordPos clone prevPos =
                  }
                  reader ParserReader.nextWord
                  ParseState .STATE_COMMENT state =
                else
                  reader .word '#' << next << drop
                }
              else
                reader .word '#' << drop
              }
            end-case
          default
            reader .word next << drop
          }
        }
      end-case
      STATE_STRING STATE_USTRING case
        byte next =:
        next '"' == if{
          prevWord .length 0 > if{
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            "" prevWord =
          }
          tokens
            TokenType .VALUE reader .wordPos clone
            state ParseState .STATE_USTRING == if{
              reader .word build codepoints Value.ofUString
            else
              reader .word build Value.ofString
            }
          ValueToken mut new << tokens =
          reader ParserReader.nextWord
          ParseState .STATE_WORD state =
        else next '\\' == if
          reader readEscapeChar
        else
          reader .word next << drop
        }
      end-case
      STATE_CHAR STATE_UCHAR case
        byte next =:
        next '\'' == if{
          prevWord .length 0 > if{
            prevWord "" prevPos openBlocks program parseWord
            END_OF_SECTION "" prevPos openBlocks program parseWord
            "" prevWord =
          }
          tokens
            TokenType .VALUE reader .wordPos clone
            state ParseState .STATE_UCHAR == if{
              reader .word build codepoints
              dup .length 1 != if{
                reader .word " is not a valid unicode character " <<*
                reader .pos << '\n' <<
                build eputs
                1 exit
              }
              #+chars+# 0 [] Value.ofCodepoint
            else
              reader .word clone
              dup .length 1 != if{
                #+str+# " is not a valid unicode character " <<*
                reader .pos << '\n' <<
                build eputs
                1 exit
              }
              #+chars+# 0 [] Value.ofByte
            }
          ValueToken mut new << tokens =
          reader ParserReader.nextWord
          ParseState .STATE_WORD state =
        else next '\\' == if
          reader readEscapeChar
        else
          reader .word next << drop
        }
      end-case
      STATE_COMMENT case
        #+input-char+# '+' == if{
          reader ParserReader.nextByte if{
            '#' == if{
              ParseState .STATE_WORD state =
            }
          }
        }
      end-case
      STATE_LINE_COMMENT case
        #+input-char+# '\n' == if{
          ParseState .STATE_WORD state =
        }
      end-case
    }
  }

  state switch{
    STATE_WORD case
      reader .word build nextWord =::
      prevWord .length 0 > if{
        prevWord nextWord prevPos openBlocks program parseWord
        "" prevWord =
      }
      nextWord "" reader .wordPos clone openBlocks program parseWord
      END_OF_SECTION "" reader .wordPos clone openBlocks program parseWord
      reader ParserReader.nextWord
      end-case
    STATE_CHAR STATE_UCHAR case
      64 buildString
     "unfinished char-literal " <<* reader .wordPos << '\n' <<
      build eputs
      1 exit
      end-case
    STATE_STRING STATE_USTRING case
      64 buildString
     "unfinished string-literal " <<* reader .wordPos << '\n' <<
      build eputs
      1 exit
      end-case
    STATE_COMMENT case
      64 buildString
     "unfinished comment " <<* reader .wordPos << '\n' <<
      build eputs
      1 exit
      end-case
    STATE_LINE_COMMENT case
      ##do nothing
      end-case
  }
  context reader .wordPos RootContext.endFile
}

constEvaluate proc( Token mut list mut? => Token mut list mut ){
  tokens =::
  tokens .length Token mut list mut new res =::
  0 i =::
  while{ i tokens .length < do
    tokens i [] .tokenType switch{
      VALUE case
        res tokens i [] << res =
        end-case
      OPERATOR case
        tokens i [] OperatorToken mut cast .opType switch{
          PLUS
          MINUS
          NEGATE
          INVERT
          MULTIPLY
          DIVIDE
          MOD

          NOT
          FLIP
          AND
          OR
          XOR

          SHIFT_L
          SHIFT_R

          LT
          LE
          EQ
          REF_EQ
          REF_NE
          NE
          GE
          GT case
            128 buildString
            "operators of type:" <<* OperatorType .fieldNames tokens i [] OperatorToken mut cast .opType [] <<*
            " are currently not supported in constant evaluation " <<*
            tokens i [] .pos << '\n' << build eputs
            1 exit
            end-case
        }
        end-case
      WORD
      KEY_WORD
      PROCEDURE_START
      ENUM_START
      IDENTIFIER
      VARIABLE
      BLOCK_TOKEN
      CONTEXT_OPEN
      CONTEXT_CLOSE case
        128 buildString
        "tokens of type:" <<* TokenType .fieldNames tokens i [] .tokenType [] <<*
        " are currently not supported in constant evaluation " <<*
        tokens i [] .pos << '\n' << build eputs
        1 exit
      end-case
    }
    i 1 + i =
  }
  res return
}

main public proc( string array => ){
  string array args =:
  args .length 2 < if{
    "usage: <pathToFile> \n" puts ## "usage: <pathToFile> (-lib <libPath>)"
    0 exit
  }
  args 1 [] string path mut =:
  path .length 0 > &&{ path 0 [] '.' == } if{ ##local path
    args 0 [] .length path .length + buildString
    args 0 [] <<* path 1 path .length [:] <<* build path =
  }

  16 Token mut list mut new tokens =::
  newRootContext RootContext mut context =:
  path tokens context Program mut new parseFile
  0 int i mut =:
  while{ i tokens .length < do
    tokens i [] Token mut token =:
    64 buildString token << " " <<* token .pos << '\n' << build puts
    i 1 + i =
  }
  "\n" puts
  "declared values:\n" puts
  context .elements ^_ for{
      string Declareable mut? MapEntry mut? e =:
      64 buildString e .key <<s ": " <<* e .value << build println
   } drop
}
