proc
  dup float a =$ float x =:
  while x x * a - 1E-16 > :
   a x / x + 2 / x =
  end
  x
end *->* sqrt =$

proc
 if dup 1 > :
  dup 1 - fib () swap 2 - fib () +
 elif 1 == :
  1
 else
  0
 end
end *->* fib =$

2.0 sqrt () println
3 sqrt () println

0 while dup 5 < :
 dup fib () println
 1 +
end drop

proc 0 != end *->* intToBool =$

3 intToBool () println
0 intToBool () println

2 3 proc + 2.0 / end () println

"Hello" ' ' "World" >>: :+ println

"Hello World!" 7 9 [:] println

0x42 "0x%04x" sprintf 3.41592653589793238 -20 0 16 "%s %*.*(*)f\n" printf

proc #_ list ? -> list ? _#
## store type and length of the list
dup typeof unwrap type arg.type   =:
dup length        int  arg.length =:
## Iterate though the elements in reverse order
..^ while <^ : swap end drop
## reassemble the list
arg.type arg.length {}
end *->* reverse =$

"Hello World" reverse () println

proc #_ list ? -> ?  _#
0 var tmp =: ## Initialize sum to 0
## Iterate though all elements of the list
^.. while ^> :
 tmp swap + tmp =
end drop
tmp ## load the total sum onto the stack
end *->* sum =$

1 2 3 4 5 6 7 8 9 int 9 {} sum () println
1.5 2.5 3.5 4.5 float 4 {} sum () println

struct 1 int a =: 2 int b =$ end (struct) test =:
test a . println
test 42 a . = println

"Hello World?" '!' 11 [] = println
"Hello World!" "Programmer" 6 11 [:] = println
"Hello World!" "" 5 11 [:] = println

"./examples/include.concat" include
"./examples/include.concat" include
included child . ()
struct
included child_struct . $import
end println

255 byte cast dup typeof swap "%s: %s\n" printf
0x123456789abcdef bytes asFloat_BE bytes println

"examples/testIO.txt" "rw" open
seekEnd drop
if pos :
 1 - seek drop
end
if read :
 if int cast 1 + 0xff & byte cast write ! :
   "IO Error" println
 end
elif state -1 == :
 if 0x41 byte cast write ! :
   "IO Error" println
 end
else
 "IO Error" println
end
close drop

"Test" dup "A" :+ clone "B" :+ println println println
"Test" string 1 {} clone! clone 0 [] "C" :+ :<< println println
