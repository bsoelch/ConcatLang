lib/hashMap :

hashMap #namespace

stack #include
codeblocks #include
core #import

_Empty_Tuple tuple{ }

listHash proc( A <?> A list => uint ){
  A list value =:
  0 uint hash =:
  0 uint i =:
  while{ i value .length < }do{
    hash 31 * value i [] hashCode + hash =
    i 1 + i =
  }
  hash return
}
hashCode proc( var => uint ){
  var value =:
  value .type type valType =:
  ## addLater? use list-hash for tuple/enum-types
  valType .isList if{
    value listHash return
  }else{ valType _Empty_Tuple <= }if{
    0 uint hash =:
    0 uint i =:
    while{ i value _Empty_Tuple cast .length < }do{
      hash 31 * value _Empty_Tuple cast i [] hashCode + hash =
      i 1 + i =
    }
    hash
  }else{
    value refId
  }
}

MapEntry tuple{ K <> V <> K V }
MapEntry.key   proc( K <?> V <?> K V MapEntry => K ){ .0 }
MapEntry.value proc( K <?> V <?> K V MapEntry => V ){ .1 }

_Entry tuple{ K <> V <> K V K V MapEntry optional } ## use MapEntry instead of _Entry because self-containing tuples are not supported
_Entry.val=  proc( K <?> V <?> V  K V _Entry =>                     ){ .1 = }
_Entry.next  proc( K <?> V <?> K V _Entry => K V MapEntry optional  ){ .2   }
_Entry.next= proc( K <?> V <?> K V MapEntry optional  K V _Entry => ){ .2 = }

HashMap tuple{ K <> V <> K V _Entry optional list int }
_Map.data    proc( K <?> V <?> K V HashMap => K V _Entry optional list ){ .0 }
HashMap.size proc( K <?> V <?> K V HashMap => int                      ){ .1 }
_Map.incSize proc( K <?> V <?> K V HashMap => ){ dup .1 1 + swap .1 = }
_Map.decSize proc( K <?> V <?> K V HashMap => ){ dup .1 1 - swap .1 = }

newHashMap proc( #+keyType+# K <> #+valType+# V <> #+cap+# int => K V HashMap ){
  int cap =:
  cap K V _Entry optional list new K V _Entry optional list data =:
  data 0 cap K V _Entry empty fill
  data 0 K V HashMap new
}

HashMap.put proc( K <?> V <?> #+map+# K V HashMap #+key+# K #+value+# V => #+prevVal+# V optional ){
  V value =:
  K key =:
  K V HashMap map =:
  ## cast elements to correct types
  ## value map _Map.valType cast value =
  ## key   map _Map.keyType cast key =
  key hashCode uint hash =:
  hash map _Map.data .length % uint i =:
  map _Map.data i [] if{
    K V _Entry entry =:
    while{ entry _Entry.next }do{
      entry MapEntry.key key == if{ drop ##drop next
        ##replace does not change size
        entry MapEntry.value
        value entry _Entry.val=
        wrap return
      }
      entry =
    } ##drop last entry
    entry MapEntry.key key == if{
      ##replace does not change size
      entry MapEntry.value
      value entry _Entry.val=
      wrap return
    }else{
      key value K V _Entry empty K V _Entry new wrap  entry _Entry.next=
      map _Map.incSize
      V empty return
    }
  }else{
    key value K V _Entry empty K V _Entry new wrap   map _Map.data i []=
    map _Map.incSize
    V empty return
  }
}

HashMap.contains proc( K <?> V <?> #+map+# K V HashMap #+key+# K => bool ){
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map _Map.data .length % uint i =:
  map _Map.data i [] K V _Entry optional entry =:
  while{ entry }do{
    K V _Entry unwrapped =:
    unwrapped MapEntry.key key == if{
      true return
    }
    unwrapped _Entry.next entry =
  }
  false return
}

HashMap.get proc( K <?> V <?> #+map+# K V HashMap #+key+# K => #+value+# V optional ){
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map _Map.data .length % uint i =:
  map _Map.data i [] K V _Entry optional entry =:
  while{ entry }do{
    K V _Entry unwrapped =:
    unwrapped MapEntry.key key == if{
      unwrapped MapEntry.value wrap return
    }
    unwrapped _Entry.next entry =
  }
  V empty return
}

HashMap.remove proc( K <?> V <?> #+map+# K V HashMap #+key+# K => #+prevVal+# V optional ){
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map _Map.data .length % uint i =:
  map _Map.data i [] if{
    K V _Entry entry =:
    entry MapEntry.key key == if{
      map _Map.decSize
      entry MapEntry.value ## get previous value
      entry _Entry.next K V _Entry optional cast  map _Map.data i []= ## remove entry
      wrap return
    }else{
      while{ entry _Entry.next }do{
        K V _Entry next =:
        next MapEntry.key key == if{
          map _Map.decSize
          next MapEntry.value ## get previous value
          next _Entry.next  entry _Entry.next= ## remove entry
          wrap return
        }
        next entry =
      }
      V empty return
    }
  }else{
    V empty return
  }
}

HashMapItr tuple{ K <> V <> K V HashMap #+index+# int #+next+# K V _Entry optional }
_HashMapItr.map   proc( K <?> V <?> K V HashMapItr  => K V HashMap         ){ .0   }
_HashMapItr.i     proc( K <?> V <?> K V HashMapItr  => int                 ){ .1   }
_HashMapItr.next  proc( K <?> V <?> K V HashMapItr  => K V _Entry optional ){ .2   }
_HashMapItr.next= proc( K <?> V <?> K V _Entry optional  K V HashMapItr => ){ .2 = }
_HashMapItr.incI  proc( K <?> V <?> K V HashMapItr => ){      dup .1 1 + swap .1 = }

HashMap.itr proc( K <?> V <?> K V HashMap => K V HashMapItr ){
  #+map+# -1 K V _Entry empty K V HashMapItr new return
}
HashMapItr.next proc( K <?> V <?> K V HashMapItr => K V HashMapItr K V MapEntry optional ){
  K V HashMapItr itr =:
  while{ itr _HashMapItr.next ! }do{
    itr _HashMapItr.incI
    itr _HashMapItr.i itr _HashMapItr.map _Map.data .length >= if{
      itr K V MapEntry empty return
    }
    itr _HashMapItr.map _Map.data itr _HashMapItr.i []  itr _HashMapItr.next=
  }
  itr _HashMapItr.next K V MapEntry optional res =:
  itr _HashMapItr.next if{
    _Entry.next itr _HashMapItr.next=
  }else{ unreachable }
  itr res return
}

## addLater? HashMap.listEntries
## addLater? HashMap.toString
## addLater? (automatically) duplicate capacity

#end ## hashMap