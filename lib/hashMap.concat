hashMap #module

optional #include
core #import

hashCode proc ## var -> int
  var value =:
  value typeof type valType =:
  if || valType (list) <= : valType (tuple) <= end :
    0 int hash =:
    0 int i =:
    while i value length < :
      hash 31 * value i [] hashCode + hash =
      i 1 + i =
    end
    hash
  else
    value refId
  end
end

var  var  (tuple)           3 tuple type _Entry =$
_Entry.key   #define 0 []   #end
_Entry.val   #define 1 []   #end
_Entry.val=  #define 1 [] = #end
_Entry.next  #define 2 []   #end
_Entry.next= #define 2 [] = #end
type type _Entry list 3 tuple type HashMap   =$
_Map.keyType #define 0 [] #end
_Map.valType #define 1 [] #end
_Map.data    #define 2 [] #end

false false  0 tuple new  _Entry new _Entry _Empty =$

newHashMap proc ## keyType:type valType:type cap:int -> HashMap
  int cap =:
  type keyType =:
  type valType =:
  cap _Entry list new _Entry list data =:
  data 0 cap _Empty fill
  keyType valType data HashMap new
end

HashMap.put proc ## map:HashMap key:var value:var -> prevVal:optional<var>
  var value =:
  var key =:
  HashMap map =:
  ## cast elements to correct types
  value map _Map.valType cast value =
  key   map _Map.keyType cast key =
  key hashCode int hash =:
  hash map _Map.data length % int i =:
  if map _Map.data i [] _Empty === :
    map _Map.data  key value _Empty _Entry new  i [] =
    optional_empty return
  else
    map _Map.data i [] _Entry entry =:
    while entry _Entry.next _Empty =!= :
      if entry _Entry.key key == :
        entry _Entry.val
        entry value _Entry.val=
        wrap return
      end
      entry _Entry.next entry =
    end
    if entry _Entry.key key == :
      entry _Entry.val
      entry value _Entry.val=
      wrap return
    else
      entry key value _Empty _Entry new _Entry.next=
      optional_empty return
    end
  end
end

HashMap.get proc ## map:HashMap key:var -> value:optional<var>
  var key =:
  HashMap map =:
  key hashCode int hash =:
  hash map _Map.data length % int i =:
  map _Map.data i [] _Entry entry =:
  while entry _Empty =!= :
    if entry _Entry.key key == :
      entry _Entry.val wrap return
    end
    entry _Entry.next entry =
  end
  optional_empty return
end

HashMap.remove proc ## map:HashMap key:var -> prevVal:optional<var>
  var key =:
  HashMap map =:
  key hashCode int hash =:
  hash map _Map.data length % int i =:
  if map _Map.data i [] _Empty === :
    optional_empty return
  elif map _Map.data i [] _Entry.key key == :
    map _Map.data i [] _Entry.val ## get previous value
    map _Map.data   map _Map.data i [] _Entry.next  i [] = ## remove entry
    wrap return
  else
    map _Map.data i [] _Entry entry =:
    while entry _Entry.next _Empty =!= :
      if entry _Entry.next _Entry.key key == :
        entry _Entry.next _Entry.val ## get previous value
        entry   entry _Entry.next _Entry.next  _Entry.next= ## remove entry
        wrap return
      end
      entry _Entry.next entry =
    end
    optional_empty return
  end
end

## addLater? HashMap.listEntries
## addLater? HashMap.toString

#end ## hashMap