if __hashCode ? ! :
optional #include

proc ## var -> int
  var value =:
  value typeof type valType =:
  if || valType (list) <= : valType (tuple) <= end :
    0 int hash =:
    0 int i =:
    while i value length < :
      hash 31 * value i [] __hashCode () + hash =
      i 1 + i =
    end
    hash
  else
    value refId
  end
end *->* __hashCode =$

var  var  (tuple)           3 tuple type __HASH_Entry =$
__HASH_Entry.key   #define 0 []   #end
__HASH_Entry.val   #define 1 []   #end
__HASH_Entry.val=  #define 1 [] = #end
__HASH_Entry.next  #define 2 []   #end
__HASH_Entry.next= #define 2 [] = #end
type type __HASH_Entry list 3 tuple type __HASH_Map   =$
__HASH_Map.keyType #define 0 [] #end
__HASH_Map.valType #define 1 [] #end
__HASH_Map.data    #define 2 [] #end

false false  0 tuple new  __HASH_Entry new __HASH_Entry __HASH_Empty =$

proc ## keyType:type valType:type cap:int -> __HASH_Map
  int cap =:
  type keyType =:
  type valType =:
  cap __HASH_Entry list new __HASH_Entry list data =:
  data 0 cap __HASH_Empty fill
  keyType valType data __HASH_Map new
end *->* __HASH_newMap =$

proc ## map:__HASH_Map key:var value:var -> prevVal:optional<var>
  var value =:
  var key =:
  __HASH_Map map =:
  ## cast elements to correct types
  value map __HASH_Map.valType cast value =
  key   map __HASH_Map.keyType cast key =
  key __hashCode () int hash =:
  hash map __HASH_Map.data length % int i =:
  if map __HASH_Map.data i [] __HASH_Empty === :
    map __HASH_Map.data  key value __HASH_Empty __HASH_Entry new  i [] =
    optional_empty return
  else
    map __HASH_Map.data i [] __HASH_Entry entry =:
    while entry __HASH_Entry.next __HASH_Empty =!= :
      if entry __HASH_Entry.key key == :
        entry __HASH_Entry.val
        entry value __HASH_Entry.val=
        wrap return
      end
      entry __HASH_Entry.next entry =
    end
    if entry __HASH_Entry.key key == :
      entry __HASH_Entry.val
      entry value __HASH_Entry.val=
      wrap return
    else
      entry key value __HASH_Empty __HASH_Entry new __HASH_Entry.next=
      optional_empty return
    end
  end
end *->* __HASH_put =$

proc ## map:__HASH_Map key:var -> value:optional<var>
  var key =:
  __HASH_Map map =:
  key __hashCode () int hash =:
  hash map __HASH_Map.data length % int i =:
  map __HASH_Map.data i [] __HASH_Entry entry =:
  while entry __HASH_Empty =!= :
    if entry __HASH_Entry.key key == :
      entry __HASH_Entry.val wrap return
    end
    entry __HASH_Entry.next entry =
  end
  optional_empty return
end *->* __HASH_get =$

proc ## map:__HASH_Map key:var -> prevVal:optional<var>
  var key =:
  __HASH_Map map =:
  key __hashCode () int hash =:
  hash map __HASH_Map.data length % int i =:
  if map __HASH_Map.data i [] __HASH_Empty === :
    optional_empty return
  elif map __HASH_Map.data i [] __HASH_Entry.key key == :
    map __HASH_Map.data i [] __HASH_Entry.val ## get previous value
    map __HASH_Map.data   map __HASH_Map.data i [] __HASH_Entry.next  i [] = ## remove entry
    wrap return
  else
    map __HASH_Map.data i [] __HASH_Entry entry =:
    while entry __HASH_Entry.next __HASH_Empty =!= :
      if entry __HASH_Entry.next __HASH_Entry.key key == :
        entry __HASH_Entry.next __HASH_Entry.val ## get previous value
        entry   entry __HASH_Entry.next __HASH_Entry.next  __HASH_Entry.next= ## remove entry
        wrap return
      end
      entry __HASH_Entry.next entry =
    end
    optional_empty return
  end
end *->* __HASH_remove =$

## addLater? hashPrint

end

hashCode       #define __hashCode ()    #end
HashMap        #define __HASH_Map       #end
newHashMap     #define __HASH_newMap () #end
HashMap.put    #define __HASH_put       #end
HashMap.get    #define __HASH_get       #end
HashMap.remove #define __HASH_remove    #end
