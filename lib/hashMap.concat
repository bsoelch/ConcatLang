lib/hashMap :

hashMap #namespace

stack #include
codeblocks #include
core #import

_Empty_Tuple tuple end

hashCode proc var => uint :
  var value =:
  value .type type valType =:
  valType (list) <= if
    0 uint hash =:
    0 uint i =:
    while i value (list) cast length < do
      hash 31 * value (list) cast i [] hashCode + hash =
      i 1 + i =
    end
    hash
  else valType _Empty_Tuple <= _if ## addLater? use list-hash for tuple/enum-types
    0 uint hash =:
    0 uint i =:
    while i value _Empty_Tuple cast length < do
      hash 31 * value _Empty_Tuple cast i [] hashCode + hash =
      i 1 + i =
    end
    hash
  else
    value refId
  end
end

MapEntry tuple K <> V <> K V end
MapEntry.key   proc K <?> V <?> K V MapEntry => K : 0 [] end
MapEntry.value proc K <?> V <?> K V MapEntry => V : 1 [] end

_Entry tuple K <> V <> K V K V MapEntry optional end ## use MapEntry instead of _Entry because self-containing tuples are not supported
_Entry.val=  proc K <?> V <?> K V _Entry V =>                 : 1 [] = end
_Entry.next  proc K <?> V <?> K V _Entry => K V MapEntry optional : 2 []   end
_Entry.next= proc K <?> V <?> K V _Entry K V MapEntry optional => : 2 [] = end

HashMap tuple K <> V <> K V _Entry optional list int end
_Map.data    proc K <?> V <?> K V HashMap => K V _Entry optional list : 0 [] end
HashMap.size proc K <?> V <?> K V HashMap => int                  : 1 [] end
_Map.incSize proc K <?> V <?> K V HashMap => : dup 1 [] 1 + 1 [] = end
_Map.decSize proc K <?> V <?> K V HashMap => : dup 1 [] 1 - 1 [] = end

newHashMap proc #+keyType+# K <> #+valType+# V <> #+cap+# int => K V HashMap :
  int cap =:
  cap K V _Entry optional list new K V _Entry optional list data =:
  data 0 cap K V _Entry empty fill
  data 0 K V HashMap new
end

HashMap.put proc K <?> V <?> #+map+# K V HashMap #+key+# K #+value+# V => #+prevVal+# V optional :
  V value =:
  K key =:
  K V HashMap map =:
  ## cast elements to correct types
  ## value map _Map.valType cast value =
  ## key   map _Map.keyType cast key =
  key hashCode uint hash =:
  hash map _Map.data length % uint i =:
  map _Map.data i [] if
    K V _Entry entry =:
    while entry _Entry.next do
      entry MapEntry.key key == if drop ##drop next
        ##replace does not change size
        entry MapEntry.value
        entry value _Entry.val=
        wrap return
      end
      entry =
    end ##drop last entry
    entry MapEntry.key key == if
      ##replace does not change size
      entry MapEntry.value
      entry value _Entry.val=
      wrap return
    else
      entry key value K V _Entry empty K V _Entry new wrap _Entry.next=
      map _Map.incSize
      V empty return
    end
  else
    map _Map.data  key value K V _Entry empty K V _Entry new wrap i [] =
    map _Map.incSize
    V empty return
  end
end

HashMap.contains proc K <?> V <?> #+map+# K V HashMap #+key+# K => bool :
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map _Map.data length % uint i =:
  map _Map.data i [] K V _Entry optional entry =:
  while entry do
    K V _Entry unwrapped =:
    unwrapped MapEntry.key key == if
      true return
    end
    unwrapped _Entry.next entry =
  end
  false return
end

HashMap.get proc K <?> V <?> #+map+# K V HashMap #+key+# K => #+value+# V optional :
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map _Map.data length % uint i =:
  map _Map.data i [] K V _Entry optional entry =:
  while entry do
    K V _Entry unwrapped =:
    unwrapped MapEntry.key key == if
      unwrapped MapEntry.value wrap return
    end
    unwrapped _Entry.next entry =
  end
  V empty return
end

HashMap.remove proc K <?> V <?> #+map+# K V HashMap #+key+# K => #+prevVal+# V optional :
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map _Map.data length % uint i =:
  map _Map.data i [] if
    K V _Entry entry =:
    entry MapEntry.key key == if
      map _Map.decSize
      entry MapEntry.value ## get previous value
      map _Map.data   entry _Entry.next K V _Entry optional cast i [] = ## remove entry
      wrap return
    else
      while entry _Entry.next do
        K V _Entry next =:
        next MapEntry.key key == if
          map _Map.decSize
          next MapEntry.value ## get previous value
          entry   next _Entry.next  _Entry.next= ## remove entry
          wrap return
        end
        next entry =
      end
      V empty return
    end
  else
    V empty return
  end
end

HashMapItr tuple K <> V <> K V HashMap #+index+# int #+next+# K V _Entry optional end
_HashMapItr.map   proc K <?> V <?> K V HashMapItr => K V HashMap         : 0 []   end
_HashMapItr.i     proc K <?> V <?> K V HashMapItr => int                 : 1 []   end
_HashMapItr.next  proc K <?> V <?> K V HashMapItr => K V _Entry optional : 2 []   end
_HashMapItr.next= proc K <?> V <?> K V HashMapItr K V _Entry optional => : 2 [] = end
_HashMapItr.incI  proc K <?> V <?> K V HashMapItr => :        dup 1 [] 1 + 1 [] = end

HashMap.itr proc K <?> V <?> K V HashMap => K V HashMapItr :
  #+map+# -1 K V _Entry empty K V HashMapItr new return
end
HashMapItr.next proc K <?> V <?> K V HashMapItr => K V HashMapItr K V MapEntry optional :
  K V HashMapItr itr =:
  while itr _HashMapItr.next ! do
    itr _HashMapItr.incI
    itr _HashMapItr.i itr _HashMapItr.map _Map.data length >= if
      itr K V MapEntry empty return
    end
    itr  itr _HashMapItr.map _Map.data itr _HashMapItr.i []  _HashMapItr.next=
  end
  itr _HashMapItr.next K V MapEntry optional res =:
  itr  itr _HashMapItr.next if
    _Entry.next _HashMapItr.next=
  else
    1 exit ##TODO mark as unreachable
  end
  itr res return
end

## addLater? HashMap.listEntries
## addLater? HashMap.toString
## addLater? (automatically) duplicate capacity

#end ## hashMap