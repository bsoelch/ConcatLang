lib/hashMap :

hashMap #namespace

stack #include
codeblocks #include
core #import

listHash public proc( A <?> A list => uint ){
  A list value =:
  0 uint hash =:
  0 uint i =:
  while{ i value .length < do
    hash 31 * value i [] hashCode + hash =
    i 1 + i =
  }
  hash return
}
hashCode public proc( var => uint ){
  var value =:
  value .type type valType =:
  ## addLater? use list-hash for tuple/enum-types
  valType .isList if{
    value listHash return
  else valType ( ) <= if
    0 uint hash =:
    0 uint i =:
    while{ i value ( ) cast .length < do
      hash 31 * value ( ) cast i [] hashCode + hash =
      i 1 + i =
    }
    hash
  else
    value refId
  }
}

MapEntry public struct{ K <> V <>
  K :key
  V :value
}

HashMapEntry struct{ K <> V <> K V MapEntry extend
  K V MapEntry optional :next ## use MapEntry instead of HashMapEntry because self-containing structs are not supported
}

HashMap public struct{ K <> V <>
  K V HashMapEntry optional list :data
  int :size
}
HashMap.incSize proc( K <?> V <?> K V HashMap => ){ dup .size 1 + swap .size = }
HashMap.decSize proc( K <?> V <?> K V HashMap => ){ dup .size 1 - swap .size = }

newHashMap public proc( #+keyType+# K <> #+valType+# V <> #+cap+# int => K V HashMap ){
  int cap =:
  cap K V HashMapEntry optional list new K V HashMapEntry optional list data =:
  data 0 cap K V HashMapEntry empty fill
  data 0 K V HashMap new
}

HashMap.put public proc( K <?> V <?> #+map+# K V HashMap #+key+# K #+value+# V => #+prevVal+# V optional ){
  V value =:
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map .data .length % uint i =:
  map .data i [] if{
    K V HashMapEntry entry =:
    while{ entry .next do
      entry .key key == if{ drop ##drop next
        ##replace does not change size
        entry .value
        value entry .value =
        wrap return
      }
      entry =
    } ##drop last entry
    entry .key key == if{
      ##replace does not change size
      entry .value
      value entry .value =
      wrap return
    else
      key value K V HashMapEntry empty K V HashMapEntry new wrap  entry .next =
      map HashMap.incSize
      V empty return
    }
  else
    key value K V HashMapEntry empty K V HashMapEntry new wrap   map .data i []=
    map HashMap.incSize
    V empty return
  }
}

HashMap.contains public proc( K <?> V <?> #+map+# K V HashMap #+key+# K => bool ){
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map .data .length % uint i =:
  map .data i [] K V HashMapEntry optional entry =:
  while{ entry do
    K V HashMapEntry unwrapped =:
    unwrapped .key key == if{
      true return
    }
    unwrapped .next entry =
  }
  false return
}

HashMap.get public proc( K <?> V <?> #+map+# K V HashMap #+key+# K => #+value+# V optional ){
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map .data .length % uint i =:
  map .data i [] K V HashMapEntry optional entry =:
  while{ entry do
    K V HashMapEntry unwrapped =:
    unwrapped .key key == if{
      unwrapped .value wrap return
    }
    unwrapped .next entry =
  }
  V empty return
}

HashMap.remove public proc( K <?> V <?> #+map+# K V HashMap #+key+# K => #+prevVal+# V optional ){
  K key =:
  K V HashMap map =:
  key hashCode uint hash =:
  hash map .data .length % uint i =:
  map .data i [] if{
    K V HashMapEntry entry =:
    entry .key key == if{
      map HashMap.decSize
      entry .value ## get previous value
      entry .next K V HashMapEntry optional cast  map .data i []= ## remove entry
      wrap return
    else
      while{ entry .next do
        K V HashMapEntry next =:
        next .key key == if{
          map HashMap.decSize
          next .value ## get previous value
          next .next  entry .next = ## remove entry
          wrap return
        }
        next entry =
      }
      V empty return
    }
  else
    V empty return
  }
}

HashMapItr public struct{ K <> V <>
  K V HashMap               :map
  int                       :index
  K V HashMapEntry optional :next
}
HashMapItr.incI  proc( K <?> V <?> K V HashMapItr => ){ dup .index 1 + swap .index = }

^_ public proc( K <?> V <?> K V HashMap => K V HashMapItr ){
  #+map+# -1 K V HashMapEntry empty K V HashMapItr new return
}
^> public proc( K <?> V <?> K V HashMapItr => K V HashMapItr K V MapEntry optional ){
  K V HashMapItr itr =:
  while{ itr .next ! do
    itr HashMapItr.incI
    itr .index itr .map .data .length >= if{
      itr K V MapEntry empty return
    }
    itr .map .data itr .index []  itr .next =
  }
  itr .next K V MapEntry optional res =:
  itr .next if{
    .next itr .next =
  else unreachable }
  itr res return
}

## addLater? HashMap.listEntries
## addLater? HashMap.toString
## addLater? (automatically) duplicate capacity

#end ## hashMap