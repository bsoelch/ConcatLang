lib/valueIO :

core #namespace

stack #include
io #include
io #import
numbers #include
utf8 #include

_EMPTY_TUPLE tuple end

<<s proc string var => string :
  var value =:
  value typeof string == if
    value string cast :+ return
  else value typeof ustring == _if
    value string:+ustring return
  else value typeof _EMPTY_TUPLE <= _if
    '(' :<< string res =:
    0 int i =:
    while i value _EMPTY_TUPLE cast length < do
      i 0 > if
        res ", " :+ res =
      end
      res value _EMPTY_TUPLE cast i [] <<s res =
      i 1 + i =
    end
    res ')' :<< return
  else value typeof (list) <= _if ##TODO use generic function for printing list (once available)
    '[' :<< string res =:
    0 int i =:
    while i value (list) cast length < do
      i 0 > if
        res ", " :+ res =
      end
      res value (list) cast i [] <<s res =
      i 1 + i =
    end
    res ']' :<< return
  else value typeof (optional) <= _if
    value (optional) cast ?? if
      unwrap <<s " wrap" :+ return
    else
      typeof content <<s " empty" :+ return
    end
  else value typeof isEnum _if
    value typeof type.name :+ ' ' :<< value typeof type.fields value uint cast [] :+ " ." :+ return
  else value typeof type == _if
    value string == if
      "string" :+ return
    else value ustring == _if
      "ustring" :+ return
    else value type cast _EMPTY_TUPLE <= _if
      value type cast type.name :+ return ## return tuple-name
    else value type cast *->* <= _if
      value *->* == if
        "*->*" :+ return
      else
        "( " :+ string res =:
        value type cast inTypes type list args =:
        0 int i =:
        while i args length < do
          res args i [] <<s " " :+ res =
          i 1 + i =
        end
        res "=> " :+ res =
        value type cast outTypes args =
        0 i =
        while i args length < do
          res args i [] <<s " " :+ res =
          i 1 + i =
        end
        res ")" :+ return
      end
    else value type cast (list) <= _if
      value (list) == if
        "(list)" :+ return
      else
        value type cast content <<s " list" :+ return
      end
    else value type cast (optional) <= _if
      value (optional) == if
        "(optional)" :+ return
      else
        value type cast content <<s " optional" :+ return
      end
    else value type cast isEnum _if
      value type cast type.name :+ return ## return enum-name
    else value type == _if
      "type"  :+ return
    else value bool == _if
      "bool"  :+ return
    else value byte == _if
      "byte"  :+ return
    else value  int == _if
      "int"   :+ return
    else value uint == _if
      "uint"  :+ return
    else value float == _if
      "float" :+ return
    else value codepoint == _if
      "codepoint" :+ return
    else value var == _if
      "var" :+ return
    else
      "unreachable\n" eputs
      1 exit
    end
  else value typeof bool == _if
    value bool cast if "true" else "false" end :+ return
  else value typeof byte == _if
    value byte cast 0x80 byte cast < if
      value byte cast :<< return ## print valid ascii-characters as character
    else
      value byteToString :+ return ## print all other bytes as their byte-code
    end
  else value typeof  int == _if
    value <<i return
  else value typeof uint == _if
    value  <<u return
  else value typeof float == _if
    value <<f return
  else value typeof codepoint == _if
    value string<<codepoint return
  else value typeof *->* <= _if
    ## procedure
    value typeof <<s "@" :+ value refId <<X return
  else
    "unreachable\n" eputs
    1 exit
  end
end
stringValue proc var => string :
  var val =:
  "" val <<s return
end

byteToString proc byte => string :
  byte value =:
  "0x" value int cast  <<x return
end

byteListToString proc byte list => string :
  byte list bytes =:
  bytes length 6 * string new string res =:
  res "[" :+ res =
  0 int i =:
  while i bytes length < do
    i 0 > if
      res ", " :+ res =
    end
    res bytes i [] byteToString :+ res =
    i 1 + i =
  end
  res "]" :+ return
end

print   proc var      =>      : core stringValue .           core puts .         end
println proc var      =>      : core stringValue . '\n' :<<  core puts .         end
fprint  proc var FILE => bool : swap core stringValue . swap core fputs . return end

1 int __IO_FLAG_PAD_0 =$
2 int __IO_FLAG_ALIGN_LEFT =$
4 int __IO_FLAG_SGN =$
8 int __IO_FLAG_SGN_SPACE =$

_IO_Format tuple bool end
__IO.isValue proc _IO_Format => bool   : 0 [] end
## isValue:bool value:string$
__IO_FormatString tuple bool string end
__IO.value   proc __IO_FormatString => string : 1 [] end
##isValue:bool index:int flags:int w:int w_ptr:boolean p:int p_ptr:boolean b:int b_ptr:boolean format:byte (char)
__IO_FormatValue tuple bool int int int bool int bool int bool byte end
__IO.index  proc __IO_FormatValue => int  : 1 [] end
__IO.flags  proc __IO_FormatValue => int  : 2 [] end
__IO.w      proc __IO_FormatValue => int  : 3 [] end
__IO.w_ptr  proc __IO_FormatValue => bool : 4 [] end
__IO.p      proc __IO_FormatValue => int  : 5 [] end
__IO.p_ptr  proc __IO_FormatValue => bool : 6 [] end
__IO.b      proc __IO_FormatValue => int  : 7 [] end
__IO.b_ptr  proc __IO_FormatValue => bool : 8 [] end
__IO.format proc __IO_FormatValue => byte : 9 [] end

__IO_printValue proc __IO_FormatValue var list => string : ## addLater runtime checks for correct types
  (list) values =:
  __IO_FormatValue format =:
  format __IO.flags __IO_FLAG_ALIGN_LEFT & 0 != bool alignLeft =:
  format __IO.w_ptr if values format __IO.w [] int cast else format __IO.w end int width =:
  width 0 < if ##negative precision => alignment on left side
    alignLeft ! alignLeft =
    width -_ width =
  end
  format __IO.p_ptr if values format __IO.p  [] int cast else format __IO.p  end int precision =:
  precision 0 < if ## 0 -> default
      "printf: precision has to be at greater that or equal to 0\n" eputs
      1 exit
  end
  format __IO.b_ptr if values format __IO.b  [] int cast else format __IO.b  end int base =:
  base 0 == if
    10 base =
  end
  '\0' byte plusSgn =:
  format __IO.flags __IO_FLAG_SGN & 0 != if
    '+' plusSgn =
  else format __IO.flags __IO_FLAG_SGN_SPACE & 0 != _if
    ' ' plusSgn =
  end
  format __IO.format  switch
  'b' case
    values format __IO.index [] bool cast if "true" else "false" end
    end-case
  'B' case
    values format __IO.index [] bool cast if "TRUE" else "FALSE" end
    end-case
  'i' case
    ""
    plusSgn '\0' != if
      values format __IO.index [] int cast 0 >= if
        plusSgn :<<
      end
    end
    values format __IO.index [] int cast base <<?i
    end-case
  'I' case
    ""
    plusSgn '\0' != if
      values format __IO.index [] int cast  0 >= if
        plusSgn :<<
      end
    end
    values format __IO.index [] int cast  base <<?I
    end-case
  'u' case
    ""
    plusSgn '\0' != if
      plusSgn :<<
    end
    values format __IO.index [] uint cast base <<?u
    end-case
  'U' case
    ""
    plusSgn '\0' != if
      plusSgn :<<
    end
    values format __IO.index [] uint cast base <<?U
    end-case
  'd' case
    ""
    plusSgn '\0' != if
      values format __IO.index [] int cast 0 >= if
        plusSgn :<<
      end
    end
    values format __IO.index [] int cast <<i
    end-case
  'x' case
    ""
    plusSgn '\0' != if
      plusSgn :<<
    end
    values format __IO.index [] uint cast <<x
   end-case
  'X' case
    ""
    plusSgn '\0' != if
      plusSgn :<<
    end
    values format __IO.index [] uint cast <<X
    end-case
  'e' case
    ""
    plusSgn '\0' != if
      values format __IO.index [] float cast 0 >= if
        plusSgn :<<
      end
    end
    values format __IO.index [] float cast precision base <<??e
    end-case
  'E' case
    ""
    plusSgn '\0' != if
      values format __IO.index [] float cast 0 >= if
        plusSgn :<<
      end
    end
    values format __IO.index [] float cast precision base <<??E
    end-case
  'f' case
    ""
    plusSgn '\0' != if
      values format __IO.index [] float cast 0 >= if
        plusSgn :<<
      end
    end
    values format __IO.index [] float cast precision base <<??f
    end-case
  'F' case
    ""
    plusSgn '\0' != if
      values format __IO.index [] float cast 0 >= if
        plusSgn :<<
      end
    end
    values format __IO.index [] float cast precision base <<??F
    end-case
  'c' case
    { values format __IO.index [] byte cast }
    end-case
  's' 'S' case
    values format __IO.index [] stringValue
    end-case
  '%' case
    "%"
    end-case
  default
    format __IO.format  " is no valid format specifier\n" >>: eputs
    1 exit
  end string res =:
  res length width < if
    width res length - int count =:
    format __IO.flags __IO_FLAG_PAD_0 & 0 != if '0' else ' ' end byte padChar =:
    count string new string padding =:
    padding 0 count padChar fill
    alignLeft if
      res padding :+ res =
    else
      padding res +: res =
    end
  end
  res
end

isFormatChar proc #+char+# byte => bool :
  byte c =:
  "bBiIuUdxXfFeEcsS%" string formats =:
  0 int i =:
  while i formats length < do
    formats i [] c == if
      true return
    end
    i 1 + i =
  end
  false
end

sprintf proc #+args+# var list #+format+# string => string :
  string format =:
  var list args =:

  format length 4 / _IO_Format list new _IO_Format list parts =:
  0 int i0 =:
  0 int i  =:
  format length int n  =:
   0 int count =:
  -1 int maxFormat =:
  0 byte tmpC =:
  0 string new string tmp =:
  while i0 n < do
    i0 i =
    while i format length < && format i [] '%' != end do
      i 1 + i =
    end
    i format length >= if
      parts   false format i0 format length [:] __IO_FormatString new   :<< parts =
      n i0 =
    else
      parts   false format i0 i [:] __IO_FormatString new   :<< parts =
      i 1 + dup i0 = i =
      while i0 format length < && format i0 [] isFormatChar ! end do
        i0 1 + i0 =
      end
      i0 format length >= if
        "printf: unfinished or invalid format String: "  format i format length [:] stringValue  :+ '\n' :<< eputs
        1 exit
      end
      format i0 [] byte _formatChar =:
      format i i0 [:] string _formatString =:
      i0 1 + i0 =
      _formatChar '%' == if
        _formatString length 0 > if
          "printf: invalid Format String: \"" _formatString :+
           "\" format '%' does not allow any additional parameters\n" :+ eputs
           1 exit
        end
        parts   false "%" __IO_FormatString new   :<< parts =
      else
        count int  index =:
        count 1 +  count =
        0     int  flags =:
        0     int  w     =:
        false bool w_ptr =:
        0     int  p     =:
        false bool p_ptr =:
        0     int  b     =:
        false bool b_ptr =:
        0 i =
        tmp clear
        tmp _formatString length ensureCap
        ## ([0-9]+$)?  index
        while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
          _formatString i [] :<<
          i 1 + i =
        end tmp =
        i _formatString length < && _formatString i [] '$' == end if
          tmp parseInt index =
          tmp clear
        end
        ## ([-+ 0]+)? flags
        ## '-'  The result will be left-justified.
        ## '+'  The result will always include a sign
        ## ' '  The result will include a leading space for positive values
        ## '0'  The result will be zero-padded
        0 int i1 =:
        while i1 tmp length < && tmp i1 [] '0' == end do
          flags __IO_FLAG_PAD_0 | flags =
          i1 1 + i1 =
        end
        tmp 0 i1 [:] clear
        tmp length 0 == if
          true while #+ loop condition (on stack) +#&& i _formatString length < end do
            _formatString i [] tmpC =
            tmpC '-' == if
              flags __IO_FLAG_ALIGN_LEFT | flags =
              i 1 + i =
              true ## continue loop
            else tmpC '+' == _if
              flags __IO_FLAG_SGN | flags =
              i 1 + i =
              true ## continue loop
            else tmpC ' ' == _if
              flags __IO_FLAG_SGN_SPACE | flags =
              i 1 + i =
              true ## continue loop
            else tmpC '0' == _if
              flags __IO_FLAG_PAD_0 | flags =
              i 1 + i =
              true ## continue loop
            else
              false ## break loop
            end
          end
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
        end
        ## ([0-9]+)? width
        tmp length 0 > if
          tmp parseInt w =
          tmp clear ## clear tmp
        else i _formatString length < && _formatString i [] '*' == end _if ## *(<index>).
          i 1 + i =
          true w_ptr =
          count w =
          count 1 + count =
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          tmp length 0 > if
            tmp parseInt w =
            tmp clear ## clear tmp
          end
        end
        ## (.[0-9]+)? precision
        i _formatString length < && _formatString i [] '.' == end if
               _formatChar 'f' ==  if else _formatChar 'F' == _if
          else _formatChar 'e' == _if else _formatChar 'E' == _if
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<<
                             "\" precision-parameter only allowed for formats f, F, e, E, s and S\n" :+ eputs
            1 exit
          end
          i 1 + i =
          i _formatString length < && _formatString i [] '*' == end if
            i 1 + i =
            true p_ptr =
            count p =
            count 1 + count =
          end
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          p_ptr ! || tmp length 0 > end if
            tmp parseInt p =
            tmp clear ## clear tmp
          end
        end
        ## '('[0-9]+')' base
        i _formatString length < && _formatString i [] '(' == end if
               _formatChar 'i' ==  if else _formatChar 'I' == _if
          else _formatChar 'u' == _if else _formatChar 'U' == _if
          else _formatChar 'f' == _if else _formatChar 'F' == _if
          else _formatChar 'e' == _if else _formatChar 'E' == _if
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<<
                             "\" base-parameter only allowed for formats i,u,f,e and s\n" :+ eputs
            1 exit
          end
          i 1 + i =
          i _formatString length < && _formatString i [] '*' == end if
            i 1 + i =
            true b_ptr =
            count b =
            count 1 + count =
          end
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          i _formatString length < && _formatString i [] ')' == end if
            b_ptr ! || tmp length 0 > end if
              tmp parseInt b =
              tmp clear ## clear tmp
            end
            i 1 + i =
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<< "\"\n" :+ eputs
            1 exit
          end
        end
        i _formatString length < || tmp length 0 > end if
          "printf: invalid Format String: \"" _formatString :+ _formatChar :<< "\"\n" :+ eputs
          1 exit
        end
        parts   true index flags w w_ptr p p_ptr b b_ptr _formatChar __IO_FormatValue new   :<< parts =
        maxFormat index < if
          index maxFormat =
        end
        w_ptr if
          maxFormat w < if
            w maxFormat =
          end
        end
        p_ptr if
          maxFormat p < if
            p maxFormat =
          end
        end
        b_ptr if
          maxFormat b < if
            b maxFormat =
          end
        end
      end
    end
  end
  maxFormat 1 + count =
  count args length != if
    "wrong number of arguments: " args length <<i " expected " :+ count <<i
    '\n' :<< eputs
    1 exit
  end
  0 i =
  while i parts length < do
    tmp
    parts i [] __IO.isValue if   ## Value format
      parts i [] args __IO_printValue
    else ## string format
      parts i [] __IO.value
    end
    :+ tmp =
    i 1 + i =
  end
  tmp
end

## variadic  wrappers

printf proc var list string => :
  sprintf puts
end

## formats string file
fprintf proc var list string FILE => bool :
  FILE file =:
  sprintf file fputs return
end

#end ##std