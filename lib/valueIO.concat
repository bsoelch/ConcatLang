core #module

stack #include
io #include
io #import
numbers #include
utf8 #include

_EMPTY_TUPLE tuple end

stringValue proc var => string :
  var value =:
  value typeof string == if
    value clone return
  else value typeof ustring == _if
    value codepointsToString return
  else value typeof _EMPTY_TUPLE <= _if
    "(" string res =:
    0 int i =:
    while i value length < do
      i 0 > if
        res ", " :+ res =
      end
      res value i [] stringValue :+ res =
      i 1 + i =
    end
    res ")" :+ return
  else value typeof (list) <= _if
    "[" string res =:
    0 int i =:
    while i value length < do
      i 0 > if
        res ", " :+ res =
      end
      res value i [] stringValue :+ res =
      i 1 + i =
    end
    res "]" :+ return
  else value typeof (optional) <= _if
    value ?? if
      unwrap stringValue " wrap" +: return
    else
      typeof content stringValue " empty" +: return
    end
  else value typeof isEnum _if
    value typeof string cast " " :+ value typeof value [] :+ " ." :+ return
  else value typeof type == _if
    value string == if
      "string" return
    else value ustring == _if
      "ustring" return
    else value _EMPTY_TUPLE <= _if
      value string cast return ## return tuple-name
    else value *->* <= _if
      value *->* == if
        "*->*" return
      else
        "( " string res =:
        value 0 [] type list args =:
        0 int i =:
        while i args length < do
          res args i [] stringValue :+ " " :+ res =
          i 1 + i =
        end
        res "=> " :+ res =
        value 1 [] args =
        0 i =
        while i args length < do
          res args i [] stringValue :+ " " :+ res =
          i 1 + i =
        end
        res ")" :+ return
      end
    else value (list) <= _if
      value (list) == if
        "(list)" return
      else
        value content stringValue " list" :+ return
      end
    else value (optional) <= _if
      value (optional) == if
        "(optional)" return
      else
        value content stringValue " optional" :+ return
      end
    else value isEnum _if
      value string cast return ## return enum-name
    else value type == _if
      "type" return
    else value bool == _if
      "bool" return
    else value byte == _if
      "byte" return
    else value  int == _if
      "int" return
    else value uint == _if
      "uint" return
    else value float == _if
      "float" return
    else value codepoint == _if
      "codepoint" return
    else value var == _if
      "var" return
    else
      "unreachable\n" eputs
      1 exit
    end
  else value typeof bool == _if
    value if "true" else "false" end return
  else value typeof byte == _if
    value 0x80 byte cast < if
      { value byte cast } return ## print valid ascii-characters as character
    else
      value byteToString return ## print all other bytes as their byte-code
    end
  else value typeof  int == _if
    value   10 false false intToString return
  else value typeof uint == _if
    value   10  true false intToString return
  else value typeof float == _if
    value 0 10 false false floatToString return
  else value typeof codepoint == _if
    value codepointToString return
  else value typeof *->* <= _if
    ## procedure
    value typeof stringValue "@" :+ value refId  16 true true intToString :+ return
  else
    "unreachable\n" eputs
    1 exit
  end
end

byteToString proc byte => string :
  byte value =:
  "0x" value int cast  16 true false intToString :+ return
end

byteListToString proc byte list => string :
  byte list bytes =:
  bytes length 6 * string new string res =:
  res "[" :+ res =
  0 int i =:
  while i bytes length < do
    i 0 > if
      res ", " :+ res =
    end
    res bytes i [] byteToString :+ res =
    i 1 + i =
  end
  res "]" :+ return
end

print   proc var      => : core stringValue .           core puts .  end
println proc var      => : core stringValue . "\n" :+   core puts .  end
fprint  proc var FILE => : swap core stringValue . swap core fputs . end

1 int __IO_FLAG_PAD_0 =$
2 int __IO_FLAG_ALIGN_LEFT =$
4 int __IO_FLAG_SGN =$
8 int __IO_FLAG_SGN_SPACE =$

_IO_Format tuple bool end
__IO.isValue proc _IO_Format => bool   : 0 [] end
## isValue:bool value:string$
__IO_FormatString tuple bool string end
__IO.value   proc __IO_FormatString => string : 1 [] end
##isValue:bool index:int flags:int w:int w_ptr:boolean p:int p_ptr:boolean b:int b_ptr:boolean format:byte (char)
__IO_FormatValue tuple bool int int int bool int bool int bool byte end
__IO.index  proc __IO_FormatValue => int  : 1 [] end
__IO.flags  proc __IO_FormatValue => int  : 2 [] end
__IO.w      proc __IO_FormatValue => int  : 3 [] end
__IO.w_ptr  proc __IO_FormatValue => bool : 4 [] end
__IO.p      proc __IO_FormatValue => int  : 5 [] end
__IO.p_ptr  proc __IO_FormatValue => bool : 6 [] end
__IO.b      proc __IO_FormatValue => int  : 7 [] end
__IO.b_ptr  proc __IO_FormatValue => bool : 8 [] end
__IO.format proc __IO_FormatValue => byte : 9 [] end

__IO_printValue proc __IO_FormatValue var list => string :
  (list) values =:
  __IO_FormatValue format =:
  format __IO.flags __IO_FLAG_ALIGN_LEFT & 0 != bool alignLeft =:
  format __IO.w_ptr if values format __IO.w [] int cast else format __IO.w end int width =:
  width 0 < if ##negative precision => alignment on left side
    alignLeft ! alignLeft =
    width -_ width =
  end
  format __IO.p_ptr if values format __IO.p  [] int cast else format __IO.p  end int precision =:
  precision 0 < if ## 0 -> default
      "printf: precision has to be at greater that or equal to 0\n" eputs
      1 exit
  end
  format __IO.b_ptr if values format __IO.b  [] int cast else format __IO.b  end int base =:
  base 0 == if
    10 base =
  end
  '\0' byte plusSgn =:
  format __IO.flags __IO_FLAG_SGN & 0 != if
    '+' plusSgn =
  else format __IO.flags __IO_FLAG_SGN_SPACE & 0 != _if
    ' ' plusSgn =
  end
  format __IO.format  'b' == if
    values format __IO.index [] bool cast if "true" else "false" end
  else format __IO.format  'B' == _if
    values format __IO.index [] bool cast if "TRUE" else "FALSE" end
  else format __IO.format  'i' == _if
    values format __IO.index []  base false false intToString
    plusSgn '\0' != if
      values format __IO.index [] 0 >= if
        plusSgn swap >>:
      end
    end
  else format __IO.format  'I' == _if
    values format __IO.index []  base false true intToString
    plusSgn '\0' != if
      values format __IO.index [] 0 >= if
        plusSgn swap >>:
      end
    end
  else format __IO.format  'u' == _if
    values format __IO.index []   base true false intToString
    plusSgn '\0' != if
        plusSgn swap >>:
    end
  else format __IO.format  'U' == _if
    values format __IO.index []   base true true intToString
    plusSgn '\0' != if
      plusSgn swap >>:
    end
  else format __IO.format  'd' == _if
    values format __IO.index []   10 false false intToString
    plusSgn '\0' != if
      values format __IO.index [] 0 >= if
        plusSgn swap >>:
      end
    end
  else format __IO.format  'x' == _if
    values format __IO.index []  16 true false intToString
    plusSgn '\0' != if
      plusSgn swap >>:
    end
  else format __IO.format  'X' == _if
    values format __IO.index []  16 true true intToString
    plusSgn '\0' != if
      plusSgn swap >>:
    end
  else format __IO.format  'e' == _if
    values format __IO.index [] precision base false true  floatToString
    plusSgn '\0' != if
      values format __IO.index [] 0 >= if
        plusSgn swap >>:
      end
    end
  else format __IO.format  'E' == _if
    values format __IO.index [] precision base true  true  floatToString
    plusSgn '\0' != if
      values format __IO.index [] 0 >= if
        plusSgn swap >>:
      end
    end
  else format __IO.format  'f' == _if
    values format __IO.index [] precision base false false floatToString
    plusSgn '\0' != if
      values format __IO.index [] 0 >= if
        plusSgn swap >>:
      end
    end
  else format __IO.format  'F' == _if
    values format __IO.index [] precision base true  false floatToString
    plusSgn '\0' != if
      values format __IO.index [] 0 >= if
        plusSgn swap >>:
      end
    end
  else format __IO.format  'c' == _if
    { values format __IO.index [] byte cast }
  else format __IO.format  's' == _if
    values format __IO.index [] stringValue
  else format __IO.format  'S' == _if
    values format __IO.index [] stringValue
  else format __IO.format  '%' == _if
    "%"
  else
    format __IO.format  " is no valid format specifier\n" >>: eputs
    1 exit
  end string res =:
  res length width < if
    width res length - int count =:
    format __IO.flags __IO_FLAG_PAD_0 & 0 != if '0' else ' ' end byte padChar =:
    count string new string padding =:
    padding 0 count padChar fill
    alignLeft if
      res padding :+ res =
    else
      padding res +: res =
    end
  end
  res
end

isFormatChar proc #_char_# byte => bool :
  byte c =:
  "bBiIuUdxXfFeEcsS%" string formats =: ## addLater? formatted printing of lists
  0 int i =:
  while i formats length < do
    formats i [] c == if
      true return
    end
    i 1 + i =
  end
  false
end

sprintf proc #_args_# var list #_format_# string => string :
  string format =:
  var list args =:

  format length 4 / _IO_Format list new _IO_Format list parts =:
  0 int i0 =:
  0 int i  =:
  format length int n  =:
   0 int count =:
  -1 int maxFormat =:
  0 byte tmpC =:
  0 string new string tmp =:
  while i0 n < do
    i0 i =
    while i format length < && format i [] '%' != end do
      i 1 + i =
    end
    i format length >= if
      parts   false format i0 format length [:] __IO_FormatString new   :<< parts =
      n i0 =
    else
      parts   false format i0 i [:] __IO_FormatString new   :<< parts =
      i 1 + dup i0 = i =
      while i0 format length < && format i0 [] isFormatChar ! end do
        i0 1 + i0 =
      end
      i0 format length >= if
        "printf: unfinished or invalid format String: "  format i format length [:] stringValue  :+ '\n' :<< eputs
        1 exit
      end
      format i0 [] byte _formatChar =:
      format i i0 [:] string _formatString =:
      i0 1 + i0 =
      _formatChar '%' == if
        _formatString length 0 > if
          "printf: invalid Format String: \"" _formatString :+
           "\" format '%' does not allow any additional parameters\n" :+ eputs
           1 exit
        end
        parts   false "%" __IO_FormatString new   :<< parts =
      else
        count int  index =:
        count 1 +  count =
        0     int  flags =:
        0     int  w     =:
        false bool w_ptr =:
        0     int  p     =:
        false bool p_ptr =:
        0     int  b     =:
        false bool b_ptr =:
        0 i =
        tmp clear
        tmp _formatString length ensureCap
        ## ([0-9]+$)?  index
        while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
          _formatString i [] :<<
          i 1 + i =
        end tmp =
        i _formatString length < && _formatString i [] '$' == end if
          tmp parseInt index =
          tmp clear
        end
        ## ([-+ 0]+)? flags
        ## '-'  The result will be left-justified.
        ## '+'  The result will always include a sign
        ## ' '  The result will include a leading space for positive values
        ## '0'  The result will be zero-padded
        0 int i1 =:
        while i1 tmp length < && tmp i1 [] '0' == end do
          flags __IO_FLAG_PAD_0 | flags =
          i1 1 + i1 =
        end
        tmp 0 i1 [:] clear
        tmp length 0 == if
          true while #_ loop condition on stack _#&& i _formatString length < end do
            _formatString i [] tmpC =
            tmpC '-' == if
              flags __IO_FLAG_ALIGN_LEFT | flags =
              i 1 + i =
              true ## continue loop
            else tmpC '+' == _if
              flags __IO_FLAG_SGN | flags =
              i 1 + i =
              true ## continue loop
            else tmpC ' ' == _if
              flags __IO_FLAG_SGN_SPACE | flags =
              i 1 + i =
              true ## continue loop
            else tmpC '0' == _if
              flags __IO_FLAG_PAD_0 | flags =
              i 1 + i =
              true ## continue loop
            else
              false ## break loop
            end
          end
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
        end
        ## ([0-9]+)? width
        tmp length 0 > if
          tmp parseInt w =
          tmp clear ## clear tmp
        else i _formatString length < && _formatString i [] '*' == end _if ## *(<index>).
          i 1 + i =
          true w_ptr =
          count w =
          count 1 + count =
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          tmp length 0 > if
            tmp parseInt w =
            tmp clear ## clear tmp
          end
        end
        ## (.[0-9]+)? precision
        i _formatString length < && _formatString i [] '.' == end if
               _formatChar 'f' ==  if else _formatChar 'F' == _if
          else _formatChar 'e' == _if else _formatChar 'E' == _if
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<<
                             "\" precision-parameter only allowed for formats f, F, e, E, s and S\n" :+ eputs
            1 exit
          end
          i 1 + i =
          i _formatString length < && _formatString i [] '*' == end if
            i 1 + i =
            true p_ptr =
            count p =
            count 1 + count =
          end
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          p_ptr ! || tmp length 0 > end if
            tmp parseInt p =
            tmp clear ## clear tmp
          end
        end
        ## '('[0-9]+')' base
        i _formatString length < && _formatString i [] '(' == end if
               _formatChar 'i' ==  if else _formatChar 'I' == _if
          else _formatChar 'u' == _if else _formatChar 'U' == _if
          else _formatChar 'f' == _if else _formatChar 'F' == _if
          else _formatChar 'e' == _if else _formatChar 'E' == _if
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<<
                             "\" base-parameter only allowed for formats i,u,f,e and s\n" :+ eputs
            1 exit
          end
          i 1 + i =
          i _formatString length < && _formatString i [] '*' == end if
            i 1 + i =
            true b_ptr =
            count b =
            count 1 + count =
          end
          tmp while i _formatString length < && '0' _formatString i [] <= && '9' _formatString i [] >= end end do
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          i _formatString length < && _formatString i [] ')' == end if
            b_ptr ! || tmp length 0 > end if
              tmp parseInt b =
              tmp clear ## clear tmp
            end
            i 1 + i =
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<< "\"\n" :+ eputs
            1 exit
          end
        end
        i _formatString length < || tmp length 0 > end if
          "printf: invalid Format String: \"" _formatString :+ _formatChar :<< "\"\n" :+ eputs
          1 exit
        end
        parts   true index flags w w_ptr p p_ptr b b_ptr _formatChar __IO_FormatValue new   :<< parts =
        maxFormat index < if
          index maxFormat =
        end
        w_ptr if
          maxFormat w < if
            w maxFormat =
          end
        end
        p_ptr if
          maxFormat p < if
            p maxFormat =
          end
        end
        b_ptr if
          maxFormat b < if
            b maxFormat =
          end
        end
      end
    end
  end
  maxFormat 1 + count =
  count args length != if
    "wrong number of arguments: " args length 10 false false intToString :+ " expected " :+ count 10 false false intToString :+
    '\n' :<< eputs
    1 exit
  end
  0 i =
  while i parts length < do
    tmp
    parts i [] __IO.isValue if   ## Value format
      parts i [] args __IO_printValue
    else ## string format
      parts i [] __IO.value
    end
    :+ tmp =
    i 1 + i =
  end
  tmp
end

## variadic  wrappers

printf proc var list string => :
  sprintf puts
end

## formats string file
fprintf proc var list string FILE => :
  FILE file =:
  sprintf file fputs
end

#end ##std