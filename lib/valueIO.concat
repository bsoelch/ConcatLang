core #module

stack #include
stringIO #include
numbers #include
utf8 #include

stringValue proc var => string :
  var value =:
  if value typeof string == :
    value return
  elif value typeof ustring == :
    value codepointsToString return
  elif value typeof (tuple) <= :
    "(" string res =:
    0 int i =:
    while i value length < :
      if i 0 > :
        res ", " :+ res =
      end
      res value i [] stringValue :+ res =
      i 1 + i =
    end
    res ")" :+ return
  elif value typeof (list) <= :
    "[" string res =:
    0 int i =:
    while i value length < :
      if i 0 > :
        res ", " :+ res =
      end
      res value i [] stringValue :+ res =
      i 1 + i =
    end
    res "]" :+ return
  elif value typeof (optional) <= :
    if value ?? :
      unwrap stringValue " wrap" +: return
    else
      typeof content stringValue " empty" +: return
    end
  elif value typeof type == :
    if value string == :
      "string" return
    elif value ustring == :
      "ustring" return
    elif value (tuple) <= :
      if value (tuple) == :
        "(tuple)" return
      else
        "" string res =:
        0 int i =:
        while i value length < :
          if i 0 > :
            res " " :+ res =
          end
          res value i [] stringValue :+ res =
          i 1 + i =
        end
        res " " :+ i  10 false false intToString :+ " tuple" :+ return
      end
    elif value (list) <= :
      if value (list) == :
        "(list)" return
      else
        value content stringValue " list" :+ return
      end
    elif value (optional) <= :
      if value (optional) == :
        "(optional)" return
      else
        value content stringValue " optional" :+ return
      end
    elif value *->* <= :
      "*->*" return
    elif value (file) == :
      "(file)" return
    elif value type == :
      "type" return
    elif value bool == :
      "bool" return
    elif value byte == :
      "byte" return
    elif value int == :
      "int" return
    elif value float == :
      "float" return
    elif value codepoint == :
      "codepoint" return
    elif value var == :
      "var" return
    else
      "unreachable\n" eputs
      1 exit
    end
  elif value typeof bool == :
    if value : "true" else "false" end return
  elif value typeof byte == :
    if value 0x80 byte cast < :
      value 1 byte {}  return ## print valid ascii-characters as character
    else
      value byteToString return ## print all other bytes as their byte-code
    end
  elif value typeof int == :
    value  10 false false intToString return
  elif value typeof float == :
    value 0 10 false false floatToString return
  elif value typeof codepoint == :
    value codepointToString return
  elif value typeof *->* <= :
    ## procedure
    "*->*@" value refId  16 true true intToString +: return
  elif value typeof (file) == :
    ## procedure
    "(file)@" value refId  16 true true intToString +: return
  else
    "unreachable\n" eputs
    1 exit
  end
end

byteToString proc byte => string :
  byte value =:
  "0x" value int cast  16 true false intToString :+ return
end

byteListToString proc byte list => string :
  byte list bytes =:
  bytes length 6 * string new string res =:
  res "[" :+ res =
  0 int i =:
  while i bytes length < :
    if i 0 > :
      res ", " :+ res =
    end
    res bytes i [] byteToString :+ res =
    i 1 + i =
  end
  res "]" :+ return
end

print   #define core stringValue . puts #end
## !!! result of stringValue is not mutable
println #define core stringValue . puts "\n" puts #end ## TODO get rid of additional puts call
fprint  #define swap core stringValue . swap fputs #end

1 int __IO_FLAG_PAD_0 =$
2 int __IO_FLAG_ALIGN_LEFT =$
4 int __IO_FLAG_SGN =$
8 int __IO_FLAG_SGN_SPACE =$

## isValue:bool value:string$
bool string 2 tuple   type __IO_FormatString =$
__IO.isValue #define 0 [] #end
__IO.value   #define 1 [] #end
##isValue:bool index:int flags:int w:int w_ptr:boolean p:int p_ptr:boolean b:int b_ptr:boolean format:byte (char)
bool int int int bool int bool int bool byte 10 tuple   type __IO_FormatValue =$
__IO.index   #define 1 [] #end
__IO.flags   #define 2 [] #end
__IO.w       #define 3 [] #end
__IO.w_ptr   #define 4 [] #end
__IO.p       #define 5 [] #end
__IO.p_ptr   #define 6 [] #end
__IO.b       #define 7 [] #end
__IO.b_ptr   #define 8 [] #end
__IO.format  #define 9 [] #end

__IO_printValue proc ## __IO_FormatValue , var list -> string
  (list) values =:
  __IO_FormatValue format =:
  format __IO.flags __IO_FLAG_ALIGN_LEFT & 0 != bool alignLeft =:
  if format __IO.w_ptr : values format __IO.w [] int cast else format __IO.w end int width =:
  if width 0 < : ##negative precision => alignment on left side
    alignLeft ! alignLeft =
    width -_ width =
  end
  if format __IO.p_ptr  : values format __IO.p  [] int cast else format __IO.p  end int precision =:
  if precision 0 < : ## 0 -> default
      "printf: precision has to be at greater that or equal to 0\n" eputs
      1 exit
  end
  if format __IO.b_ptr  : values format __IO.b  [] int cast else format __IO.b  end int base =:
  if base 0 == :
    10 base =
  end
  '\0' byte plusSgn =:
  if format __IO.flags __IO_FLAG_SGN & 0 != :
    '+' plusSgn =
  elif format __IO.flags __IO_FLAG_SGN_SPACE & 0 != :
    ' ' plusSgn =
  end
  if format __IO.format  'b' == :
    if values format __IO.index [] cast bool : "true" else "false" end
  elif format __IO.format  'B' == :
    if values format __IO.index [] cast bool : "TRUE" else "FALSE" end
  elif format __IO.format  'i' == :
    values format __IO.index []  base false false intToString
    if plusSgn '\0' != :
      if values format __IO.index [] 0 >= :
        plusSgn swap >>:
      end
    end
  elif format __IO.format  'I' == :
    values format __IO.index []  base false true intToString
    if plusSgn '\0' != :
      if values format __IO.index [] 0 >= :
        plusSgn swap >>:
      end
    end
  elif format __IO.format  'u' == :
    values format __IO.index []   base true false intToString
    if plusSgn '\0' != :
        plusSgn swap >>:
    end
  elif format __IO.format  'U' == :
    values format __IO.index []   base true true intToString
    if plusSgn '\0' != :
      plusSgn swap >>:
    end
  elif format __IO.format  'd' == :
    values format __IO.index []   10 false false intToString
    if plusSgn '\0' != :
      if values format __IO.index [] 0 >= :
        plusSgn swap >>:
      end
    end
  elif format __IO.format  'x' == :
    values format __IO.index []  16 true false intToString
    if plusSgn '\0' != :
      plusSgn swap >>:
    end
  elif format __IO.format  'X' == :
    values format __IO.index []  16 true true intToString
    if plusSgn '\0' != :
      plusSgn swap >>:
    end
  elif format __IO.format  'e' == :
    values format __IO.index [] precision base false true  floatToString
    if plusSgn '\0' != :
      if values format __IO.index [] 0 >= :
        plusSgn swap >>:
      end
    end
  elif format __IO.format  'E' == :
    values format __IO.index [] precision base true  true  floatToString
    if plusSgn '\0' != :
      if values format __IO.index [] 0 >= :
        plusSgn swap >>:
      end
    end
  elif format __IO.format  'f' == :
    values format __IO.index [] precision base false false floatToString
    if plusSgn '\0' != :
      if values format __IO.index [] 0 >= :
        plusSgn swap >>:
      end
    end
  elif format __IO.format  'F' == :
    values format __IO.index [] precision base true  false floatToString
    if plusSgn '\0' != :
      if values format __IO.index [] 0 >= :
        plusSgn swap >>:
      end
    end
  elif format __IO.format  'c' == :
    values format __IO.index [] 1 byte {}
  elif format __IO.format  's' == :
    values format __IO.index [] stringValue
  elif format __IO.format  'S' == :
    values format __IO.index [] stringValue
  elif format __IO.format  '%' == :
    "%"
  else
    format __IO.format  " is no valid format specifier\n" >>: eputs
    1 exit
  end string res =:
  if res length width < :
    width res length - int count =:
    if format __IO.flags __IO_FLAG_PAD_0 & 0 != : '0' else ' ' end byte padChar =:
    count string new string padding =:
    padding 0 count padChar fill
    if alignLeft :
      res padding :+ res =
    else
      padding res +: res =
    end
  end
  res
end

isFormatChar proc #_char_# byte => bool :
  byte c =:
  "bBiIuUdxXfFeEcsS%" string formats =: ## addLater? formatted printing of lists
  0 int i =:
  while i formats length < :
    if formats i [] c == :
      true return
    end
    i 1 + i =
  end
  false
end

formatString proc #_args_# var ... #_format_# string => string :
  string format =:
  int argCount =:

  format length 4 / var list new var list parts =:
  0 int i0 =:
  0 int i  =:
  format length int n  =:
   0 int count =:
  -1 int maxFormat =:
  0 byte tmpC =:
  0 string new string tmp =:
  while i0 n < :
    i0 i =
    while && i format length < : format i [] '%' != end :
      i 1 + i =
    end
    if i format length >= :
      parts   false format i0 format length [:] __IO_FormatString new   :<< parts =
      n i0 =
    else
      parts   false format i0 i [:] __IO_FormatString new   :<< parts =
      i 1 + dup i0 = i =
      while && i0 format length < : format i0 [] isFormatChar ! end :
        i0 1 + i0 =
      end
      if i0 format length >= :
        "printf: unfinished or invalid format String: "  format i format length [:] stringValue  :+ '\n' :<< eputs
        1 exit
      end
      format i0 [] byte _formatChar =:
      format i i0 [:] string _formatString =:
      i0 1 + i0 =
      if _formatChar '%' == :
        if _formatString length 0 > :
          "printf: invalid Format String: \"" _formatString :+
           "\" format '%' does not allow any additional parameters\n" :+ eputs
           1 exit
        end
        parts   false "%" __IO_FormatString new   :<< parts =
      else
        count int  index =:
        count 1 +  count =
        0     int  flags =:
        0     int  w     =:
        false bool w_ptr =:
        0     int  p     =:
        false bool p_ptr =:
        0     int  b     =:
        false bool b_ptr =:
        0 i =
        tmp clear
        tmp _formatString length ensureCap
        ## ([0-9]+$)?  index
        while && i _formatString length < : && '0' _formatString i [] <= : '9' _formatString i [] >= end end :
          _formatString i [] :<<
          i 1 + i =
        end tmp =
        if && i _formatString length < : _formatString i [] '$' == end :
          tmp parseInt index =
          tmp clear
        end
        ## ([-+ 0]+)? flags
        ## '-'  The result will be left-justified.
        ## '+'  The result will always include a sign
        ## ' '  The result will include a leading space for positive values
        ## '0'  The result will be zero-padded
        0 int i1 =:
        while && i1 tmp length < : tmp i1 [] '0' == end :
          flags __IO_FLAG_PAD_0 | flags =
          i1 1 + i1 =
        end
        tmp 0 i1 [:] clear
        if tmp length 0 == :
          true while && #_ loop condition on stack _#: i _formatString length < end :
            _formatString i [] tmpC =
            if tmpC '-' == :
              flags __IO_FLAG_ALIGN_LEFT | flags =
              i 1 + i =
              true ## continue loop
            elif tmpC '+' == :
              flags __IO_FLAG_SGN | flags =
              i 1 + i =
              true ## continue loop
            elif tmpC ' ' == :
              flags __IO_FLAG_SGN_SPACE | flags =
              i 1 + i =
              true ## continue loop
            elif tmpC '0' == :
              flags __IO_FLAG_PAD_0 | flags =
              i 1 + i =
              true ## continue loop
            else
              false ## break loop
            end
          end
          tmp while && i _formatString length < : && '0' _formatString i [] <= : '9' _formatString i [] >= end end :
            _formatString i [] :<<
            i 1 + i =
          end tmp =
        end
        ## ([0-9]+)? width
        if tmp length 0 > :
          tmp parseInt w =
          tmp clear ## clear tmp
        elif && i _formatString length < : _formatString i [] '*' == end : ## *(<index>).
          i 1 + i =
          true w_ptr =
          count w =
          count 1 + count =
          tmp while && i _formatString length < : && '0' _formatString i [] <= : '9' _formatString i [] >= end end :
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          if tmp length 0 > :
            tmp parseInt w =
            tmp clear ## clear tmp
          end
        end
        ## (.[0-9]+)? precision
        if && i _formatString length < : _formatString i [] '.' == end :
          if   _formatChar 'f' == : elif _formatChar 'F' == :
          elif _formatChar 'e' == : elif _formatChar 'E' == :
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<<
                             "\" precision-parameter only allowed for formats f, F, e, E, s and S\n" :+ eputs
            1 exit
          end
          i 1 + i =
          if && i _formatString length < : _formatString i [] '*' == end :
            i 1 + i =
            true p_ptr =
            count p =
            count 1 + count =
          end
          tmp while && i _formatString length < : && '0' _formatString i [] <= : '9' _formatString i [] >= end end :
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          if || p_ptr ! : tmp length 0 > end :
            tmp parseInt p =
            tmp clear ## clear tmp
          end
        end
        ## '('[0-9]+')' base
        if && i _formatString length < : _formatString i [] '(' == end :
            if _formatChar 'i' == : elif _formatChar 'I' == :
          elif _formatChar 'u' == : elif _formatChar 'U' == :
          elif _formatChar 'f' == : elif _formatChar 'F' == :
          elif _formatChar 'e' == : elif _formatChar 'E' == :
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<<
                             "\" base-parameter only allowed for formats i,u,f,e and s\n" :+ eputs
            1 exit
          end
          i 1 + i =
          if && i _formatString length < : _formatString i [] '*' == end :
            i 1 + i =
            true b_ptr =
            count b =
            count 1 + count =
          end
          tmp while && i _formatString length < : && '0' _formatString i [] <= : '9' _formatString i [] >= end end :
            _formatString i [] :<<
            i 1 + i =
          end tmp =
          if && i _formatString length < : _formatString i [] ')' == end :
            if || b_ptr ! : tmp length 0 > end :
              tmp parseInt b =
              tmp clear ## clear tmp
            end
            i 1 + i =
          else
            "printf: invalid Format String: \"" _formatString :+ _formatChar :<< "\"\n" :+ eputs
            1 exit
          end
        end
        if || i _formatString length < : tmp length 0 > end :
          "printf: invalid Format String: \"" _formatString :+ _formatChar :<< "\"\n" :+ eputs
          1 exit
        end
        parts   true index flags w w_ptr p p_ptr b b_ptr _formatChar __IO_FormatValue new   :<< parts =
        if maxFormat index < :
          index maxFormat =
        end
        if w_ptr :
          if maxFormat w < :
            w maxFormat =
          end
        end
        if p_ptr :
          if maxFormat p < :
            p maxFormat =
          end
        end
        if b_ptr :
          if maxFormat b < :
            b maxFormat =
          end
        end
      end
    end
  end
  maxFormat 1 + count =
  if count argCount != :
    "wrong number of arguments: " argCount 10 false false intToString :+ " expected " :+ count 10 false false intToString :+
    '\n' :<< eputs
    1 exit
  end
  count var list new var list args =:
  0 i =
  while i count < :
    args >>: args = ## get var-arg arguments from stack
    i 1 + i =
  end
  0 i =
  while i parts length < :
    tmp
    if parts i [] __IO.isValue :  ## Value format
      parts i [] args __IO_printValue
    else ## string format
      parts i [] __IO.value
    end
    :+ tmp =
    i 1 + i =
  end
  tmp
end

printf #define core formatString . puts #end
## formats string file
fprintf proc
  (file) file =:
  formatString file fputs
end

#end ##std