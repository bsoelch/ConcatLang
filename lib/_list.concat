lib/list: ##TODO change filename to list.concat once native list is removed

core #namespace
stack #include
codeblocks #include
valueIO #include

## TODO better way of reallocating:
##   try moving offset to avoid reallocating
##   set growth rate to factor less than 2 ( 9/8 ? )

List public struct{ A <> ##TODO? rename to 'list' once native list is removed
  A memory mut^ :data mut
}
ListSlice public struct{ A <>
  A List mut^ :parent
  uint        :offset
  uint        :length mut
}

newList public proc( A <> uint => A List mut ){
  A memory mut new A List mut new return
}

## addLater clear

ensureCap public proc( A <?> A List mut uint => ){##addLater better names for capacity procedure, add procedure for offset
  newCap =::
  mList =::
  mList .data .capacity newCap < if{
    mList .data newCap realloc
  }
}

fill public proc( A <?> A A List mut int uint => ){
  count =::
  off =::
  ## cast to array to natively check bounds
  .data A array mut cast off count fill
}
fill public proc( A <?> A A ListSlice mut int uint => ){
  count =::
  off =::
  slice =::
  off 0 < ||{ off count + slice .length > } if{
    64 string mut new
    "invalid slice " <<* off <<i ":" <<* count <<u " length:" <<* slice .length <<u '\n' << eputs
    1 exit
  }
  #+val+# slice .parent slice .offset off + count fill
}

[] public proc( A <?> A List mut? uint => A ){
  i =::
  mList =::
  mList .data i [] return
}
[] public proc( A <?> A ListSlice mut? uint => A ){
  i =::
  slice =::
  i 0 < ||{ i slice .length >= } if{
    64 string mut new
    "index out of bounds " <<* i <<i " length:" <<* slice .length <<u '\n' << eputs
    1 exit
  }
  slice .parent i slice .offset + [] return
}

[]= public proc( A <?> A A List mut uint => ){
  i =::
  mList =::
  #+val+# mList .data i []=
}
[]= public proc( A <?> A A ListSlice mut uint => ){
  i =::
  slice =::
  i 0 < ||{ i slice .length >= } if{
    64 string mut new
    "index out of bounds " <<* i <<i " length:" <<* slice .length <<u '\n' << eputs
    1 exit
  }
  #+val+# slice .parent .data slice .offset i + []=
}

##inserts element after the given index
insert public proc( A <?> A A List mut uint => ){
  index =::
  mList =::
  mList .data listData =::
  index 0 < ||{ index listData .length > } if{
    64 string mut new
    "index out of bounds " <<* index <<i " length:" <<* listData .length <<u '\n' << eputs
    1 exit
  }
  listData .length listData .capacity >= if{
    listData .offset listData .capacity + delta =::
    listData listData .offset listData .capacity + delta + realloc
  }
  index listData .length < if{
    listData index listData index 1 + listData .length index - copy
    #+val+# listData index []=
  else
    #+val+# listData swap []^=
  }
}
insert public proc( A <?> A A ListSlice mut uint => ){
  index =::
  slice =::
  index 0 < ||{ index slice .length > } if{
    64 string mut new
    "index out of bounds " <<* index <<i " length:" <<* slice .length <<u '\n' << eputs
    1 exit
  }
  #+val+# slice .parent slice .offset index + insert
  slice .length 1 + slice .length =
}
insertAll public proc( A <?> A List mut? A List mut uint => ){
  index =::
  mList =::
  #+toInsert+# .data mList index insertAll
}
insertAll public proc( A <?> A array mut? A List mut uint => ){
  index =::
  mList =::
  mList .data listData =::
  toInsert =::
  index 0 < ||{ index listData .length > } if{
    64 string mut new
    "index out of bounds " <<* index <<i " length:" <<* listData .length <<u '\n' << eputs
    1 exit
  }
  listData .length toInsert .length + listData .capacity > if{
    toInsert .length delta =::
    listData listData .offset listData .capacity + delta + realloc
  }
  toInsert 0 listData index toInsert .length copy_no-replace
}
insertAll public proc( A <?> A List mut? A ListSlice mut uint => ){
  index =::
  slice =::
  #+toInsert+# .data slice index insertAll
}
insertAll public proc( A <?> A array mut? A ListSlice mut uint => ){
  index =::
  slice =::
  toInsert =::
  index 0 < ||{ index slice .length > } if{
    64 string mut new
    "index out of bounds " <<* index <<i " length:" <<* slice .length <<u '\n' << eputs
    1 exit
  }
  slice .length toInsert .length + slice .length =
  toInsert slice .parent slice .offset index + insertAll
}

<< public proc( A <?> A List mut A => A List mut ){
  val =::
  mList =::
  mList .data listData =::
  listData .length listData .capacity >= if{
    listData .offset listData .capacity + delta =::
    listData listData .offset listData .capacity + delta + realloc
  }
  listData val []^=
  mList return
}
<< public proc( A <?> A ListSlice mut A => A ListSlice mut ){
  val =::
  slice =::
  val slice .parent slice .offset insert
  slice .length 1 + slice .length =
  slice return
}
>> public proc( A <?> A A List mut => A List mut ){
  mList =::
  mList .data listData =::
  val =::
  listData .offset 0 == if{
    listData .offset listData .capacity + delta =::
    listData listData .offset listData .capacity + delta + realloc
    listData delta setOffset
  }
  val listData ^[]=
  mList return
}
>> public proc( A <?> A A ListSlice mut => A ListSlice mut ){
  slice =::
  val =::
  val slice .parent slice .offset slice .length + insert
  slice .length 1 + slice .length =
  slice return
}
<<* public proc( A <?> A List mut A List mut? => A List mut ){
  toAppend =::
  mList =::
  mList toAppend .data <<*
}
<<* public proc( A <?> A List mut A array mut? => A List mut ){
  toAppend =::
  mList =::
  mList .data listData =::
  listData .length toAppend .length + listData .capacity > if{
    toAppend .length delta =::
    listData listData .offset listData .capacity + delta + realloc
  }
  toAppend 0 listData listData .length toAppend .length copy
  mList return
}
<<* public proc( A <?> A ListSlice mut A List mut? => A ListSlice mut ){
  toAppend =::
  slice =::
  toAppend .data slice .parent slice .offset insertAll
  slice .length toAppend .data .length + slice .length =
  slice return
}
<<* public proc( A <?> A ListSlice mut A array mut? => A ListSlice mut ){
  toAppend =::
  slice =::
  toAppend slice .parent slice .offset insertAll
  slice .length toAppend .length + slice .length =
  slice return
}
*>> public proc( A <?> A List mut? A List mut => A List mut ){
  mList =::
  toAppend =::
  toAppend .data mList *>>
}
*>> public proc( A <?> A array mut? A List mut => A List mut ){
  mList =::
  mList .data listData =::
  toAppend =::
  listData .offset toAppend .length < if{
    toAppend .length delta =::
    listData listData .offset listData .capacity + delta + realloc
    listData listData .offset delta + setOffset
  }
  toAppend 0 listData toAppend .length int cast -_ toAppend .length copy
  mList return
}
*>> public proc( A <?> A List mut? A ListSlice mut => A ListSlice mut ){
  slice =::
  toAppend =::
  toAppend .data slice .parent slice .offset slice .length + insertAll
  slice .length toAppend .data .length + slice .length =
  slice return
}
*>> public proc( A <?> A array mut? A ListSlice mut => A ListSlice mut ){
  slice =::
  toAppend =::
  toAppend slice .parent slice .offset slice .length + insertAll
  slice .length toAppend .length + slice .length =
  slice return
}

[:] public proc( A <?> A List mut uint uint => A ListSlice mut ){
  to =::
  off =::
  mList =::
  off 0 < ||{ to off < ||{ to mList .data .length > } } if{
    64 string mut new
    "invalid slice " <<* off <<i ":" <<* to <<u " length:" <<* mList .length <<u '\n' << eputs
    1 exit
  }
  mList off to off - A ListSlice mut new return
}
[:] public proc( A <?> A ListSlice mut uint uint => A ListSlice mut ){
  to =::
  off =::
  slice =::
  off 0 < ||{ to off < ||{ to slice .length > } } if{
    64 string mut new
    "invalid slice " <<* off <<i ":" <<* to <<u " length:" <<* slice .length <<u '\n' << eputs
    1 exit
  }
  slice .parent slice .offset off + slice .offset to + [:] return
}
## addLater [:] for non-mutable List/ListSlice

## addLater [:]=

#end ## core