stack #include
chars #include
numbers/limits #include
proc ## value:int base:int big:bool -> byte (char)
    bool big =:
    int base =:
    int value =:
    if || value 0 < : value base >= end :
        "Digit out of range: " print value print " base: " print base println
        1 exit
    end
    if value 10 < :
        value '0' +char return
    elif value 36 < :
        value 10 - if || big : base 36 > end : 'A'  else 'a' end +char return
    else
        value 36 - 'a' +char return
    end
end *->* __NUMBER_getDigit =$

proc ## value:int unsigned:bool base:int big:bool
  bool big =:
  int base =:
  bool unsigned =:
  int value =:
  if || base 2 < : base 62 > end :
    "Base out of range: " print base print ", base has to be between 2 and 62" println
    1 exit
  end
  if value 0 == :
    "0" return
  end
  false bool neg =:
  "" ## result
  if value 0 < :
    if unsigned :
      value base u% base big __NUMBER_getDigit () :<<
      value base u/ value =
    else
      true neg =
      value -_ value =
      if value 0 < : ## int_MIN
        value base u% base big __NUMBER_getDigit () :<<
        value base u/ value =
      end
    end
  end
  while value 0 > :
      value base % base big __NUMBER_getDigit () swap >>:
      value base / value =
  end
  if neg :
    "-" swap +:
  end
end *->* intToString =$

proc ## value:float precision:int base:int big:bool sci:bool
  bool  sci =:
  bool  big =:
  int   base =:
  int   precision =:
  float value =:
  if || base 2 < : base 62 > end :
    "Base out of range: " print base print ", base has to be between 2 and 62" println
    1 exit
  end
  if value float_isFinite () ! :
    if value float_isNaN () :
      "[NaN]"
    elif value 0 > :
      "[Infinity]"
    else
      "-[Infinity]"
    end return
  elif || value 0.0 == : value -0.0 == end :
    "0" return
  end
  "" ## result
  if value 0 < :
    '-' :<<
    value -_ value =
  end
  0b1e-110100 #_2^-52_# value * float eps =: ##? better implementation of eps
  value log base log / floor int e =:
  e int e_max =:
  base e float cast ** float p =:
  64 int list new int list buff =:
  0 int n =:
  while p eps > :
    value p / floor int cast int d =:
    buff d :<< buff =
    n 1 + n =
    value d p * - value =
    p base / p =
    e 1 + e =
  end
  if || precision 0 == : precision n >= end :
    n 1 -
  else
    precision
  end n =
  if buff n [] base 2 / >= :
    n 1 - int j =:
    true bool inc =:
    while && inc : j 0 >= end :
      buff   buff j [] 1 +   j [] =
      if buff j [] base >= :
          buff   buff j [] base -  j [] =
      else
          false inc =
      end
      j 1 - j =
    end
    if inc :
      1 buff >>: buff =
      e_max 1 + e_max =
      n 1 + n =
    end
  end
  while && n 1 - e_max > : buff n 1 - [] 0 == end :
    n 1 - n =
  end
  if || sci : || e_max n >= : e_max -5 < end end :
    while && n 1 - 0 > : buff n 1 - [] 0 == end :
      n 1 - n =
    end
    buff 0 [] base big __NUMBER_getDigit () :<<
    if n 1 > :
      '.' :<<
      1 while dup n < :
         swap over buff swap [] base big __NUMBER_getDigit () :<<
         swap 1 +
      end drop
    end
    if base 10 <= : 'E' elif base 30 <= : 'X' else '#' end :<<
    if e_max 0 >= : '+' :<< end
    e_max false base big intToString () :+
  elif e_max 0 >= :
    0 while dup n < :
      swap over buff swap [] base big __NUMBER_getDigit () :<<
      if && over e_max == : over n 1 - < end :
        '.' :<<
      end
      swap 1 +
    end drop
  else
    "0." :+
    e_max -_ 1 - while dup 0 > :
      swap '0' :<<
      swap 1 -
    end drop
    0 while dup n < :
      swap over buff swap [] base big __NUMBER_getDigit () :<<
      swap 1 +
    end drop
  end
end *->* floatToString =$

proc ## digit:byte (char) base:int -> value:int
  int  base =:
  byte digit =:
  if && digit '0' >= : digit '9' <= end :
    digit '0' charDiff
  elif && digit 'A' >= : digit 'Z' <= end :
    digit 'A' charDiff 10 +
  elif && digit 'a' >= : digit 'Z' <= end :
    digit 'a' charDiff if base 37 < : 10 else 36 end +
  else
    "invalid digit for base " print base print " number: '" print digit print "'" println
    1 exit
  end
  if dup base >= :
    "invalid digit for base " print base print " number '" print digit print "'" println
  end
end *->* __NUMBER_valueOfDigit =$

proc ## source:string base:int -> int
  int base =:
  string source =:
  if || base 2 < : base 62 > end :
    "Base out of range: " print base print ", base has to be between 2 and 62" println
    1 exit
  end
  0 ## res
  false bool sgn =:
  if source 0 [] '-' == :
    true sgn =
    1 ## i = 1
  elif source 0 [] '+' == :
    1 ## i = 1
  else
    0 ## i = 0
  end
  int_MAX base / int max =:
  while dup source length < :
    swap
    if dup max > :
      "invalid string-format for int \"" print source print "\" (overflow)" println
      1 exit
    end
    base * over source swap [] base __NUMBER_valueOfDigit () +
    swap 1 +
  end drop
  if sgn : -_ end
end *->* stringToInt =$

proc 10 stringToInt () end *->* parseInt =$

proc ## c:byte (char) base:int -> bool
  int base =:
  byte c =:
  if || c 'e' == : c 'E' == end :
    base 'E' 'A' - 10 + 1 + <
  elif || c 'p' == : c 'P' == end :
    base 'P' 'A' - 10 + 1 + <
  elif || c 'x' == : c 'X' == end :
    base 'X' 'A' - 10 + 1 + <
  elif c '#' == :
    true
  else
    false
  end
end *->* isExpChar =$

proc ## str:string base:int -> float
  int base =:
  string str =:
  if || base 2 < : base 62 > end :
    "Base out of range: " print base print ", base has to be between 2 and 62" println
    1 exit
  end
  0 ## val
  false bool sgn =:
  if str 0 [] '-' == :
    true sgn =
    1 ## i = 1
  elif str 0 [] '+' == :
    1 ## i = 1
  else
    0 ## i = 0
  end
  0  int c =:
  0  int d =:
  -1 int e =:
  2 53 ** int max =: ## maximum precision of ieee float64
  while dup str length < :
    if dup str swap [] '.' == : ## str[i] == '.'
      if d 0 != :
        "invalid string-format for float \"" print str print "\"" println
        1 exit
      end
      1 d =
    elif dup str swap [] base isExpChar () :
      dup 1 + e =
      str length + ## break Loop by setting index to value >= str.length
    else
      swap
      if dup max < :
        base * over str swap [] base __NUMBER_valueOfDigit () +
        c d + c =
      else
        over str swap [] base __NUMBER_valueOfDigit () drop ## check digit without storing value
        c 1 d - + c =
      end
      swap
    end
    1 +
  end drop
  if e 0 > :
    c str e str length [:] base stringToInt () - c =
  end
  if sgn : -_ end base c -_ float cast ** *
end *->* stringToFloat =$

proc 10 stringToFloat () end *->* parseFloat =$