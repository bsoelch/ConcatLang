core #module

stack #include
chars #include
stringIO #include

int_MAX #define  0x7fffffffffffffff #end
int_MIN #define -0x8000000000000000 #end

#_ addLater float_MIN, float_MAX _#
 0 0.0 / float float_NaN =$
 1 0.0 / float float_Positive_Infinity =$
-1 0.0 / float float_Negative_Infinity =$

float_isNaN proc float => bool :
  float val =:
  val val =!= return
end
float_isFinite proc float => bool :
  float val =:
  val float_Positive_Infinity < && val float_Negative_Infinity > end return
end

__NUMBERS_getDigit proc #_value_# int #_base_# int #_big_# bool => #_ char _# byte :
    bool big =:
    int base =:
    int value =:
    value 0 < || value base >= end if
        ## even though intToString calls this function
        ## this error check should not be activated when intToString is called normally
        "Digit out of range: " value  10 false false intToString :+ " base: "
        :+ base  10 false false intToString '\n' :<< eputs
        1 exit
    end
    value 10 < if
        value '0' +char return
    else value 36 < _if
        value 10 -
        big || base 36 > end if 'A'  else 'a' end +char return
    else
        value 36 - 'a' +char return
    end
end

intToString proc #_value_# int #_base_# int #_unsigned_# bool #_big_# bool => string :
  bool big =:
  bool unsigned =:
  int base =:
  int value =:
  base 2 < || base 62 > end if
    ## even though printing recursively calls this function
    ## this error check should not be activated when intToString is called normally
    "Base out of range: " base 10 false false intToString :+ ", base has to be between 2 and 62\n" :+ eputs
    1 exit
  end
  value 0 == if
    "0" return
  end
  false bool neg =:
  "" ## result
  value 0 < if
    unsigned if
      value base u% base big __NUMBERS_getDigit :<<
      value base u/ value =
    else
      true neg =
      value -_ value =
      value 0 < if  ## int_MIN
        value base u% base big __NUMBERS_getDigit :<<
        value base u/ value =
      end
    end
  end
  while value 0 > :
      value base % base big __NUMBERS_getDigit swap >>:
      value base / value =
  end
  neg if
    "-" swap +:
  end
end

floatToString proc #_value_# float #_precision_# int #_base_# int #_big_# bool #_sci_# bool => string :
  bool  sci =:
  bool  big =:
  int   base =:
  int   precision =:
  float value =:
  base 2 < || base 62 > end if
    "Base out of range: " base 10 false false intToString :+ ", base has to be between 2 and 62\n" :+ eputs
    1 exit
  end
  value float_isFinite ! if
    value float_isNaN if
      "[NaN]"
    else value 0 > _if
      "[Infinity]"
    else
      "-[Infinity]"
    end return
  else value 0.0 == || value -0.0 == end _if
    "0" return
  end
  "" ## result
  value 0 < if
    '-' :<<
    value -_ value =
  end
  0b1e-110100 #_2^-52_# value * float eps =: ##? better implementation of eps
  value log base log / floor int e =:
  e int e_max =:
  base e float cast ** float p =:
  64 int list new int list buff =:
  0 int n =:
  while p eps > :
    value p / floor int cast int d =:
    buff d :<< buff =
    n 1 + n =
    value d p * - value =
    p base / p =
    e 1 + e =
  end
  precision 0 == || precision n >= end if
    n 1 -
  else
    precision
  end n =
  buff n [] base 2 / >= if
    n 1 - int j =:
    true bool inc =:
    while inc && j 0 >= end :
      buff   buff j [] 1 +   j [] =
      buff j [] base >= if
          buff   buff j [] base -  j [] =
      else
          false inc =
      end
      j 1 - j =
    end
    inc if
      1 buff >>: buff =
      e_max 1 + e_max =
      n 1 + n =
    end
  end
  while n 1 - e_max > && buff n 1 - [] 0 == end :
    n 1 - n =
  end
  sci || e_max n >= || e_max -5 < end end if
    while n 1 - 0 > && buff n 1 - [] 0 == end :
      n 1 - n =
    end
    buff 0 [] base big __NUMBERS_getDigit :<<
    n 1 > if
      '.' :<<
      1 while dup n < :
         swap over buff swap [] base big __NUMBERS_getDigit :<<
         swap 1 +
      end drop
    end
    base 10 <= if 'E' else base 30 <= _if 'X' else '#' end :<<
    e_max 0 >= if '+' :<< end
    e_max  base false big intToString :+
  else e_max 0 >= _if
    0 while dup n < :
      swap over buff swap [] base big __NUMBERS_getDigit :<<
      over e_max == && over n 1 - < end if
        '.' :<<
      end
      swap 1 +
    end drop
  else
    "0." :+
    e_max -_ 1 - while dup 0 > :
      swap '0' :<<
      swap 1 -
    end drop
    0 while dup n < :
      swap over buff swap [] base big __NUMBERS_getDigit :<<
      swap 1 +
    end drop
  end
end

__NUMBERS_valueOfDigit proc #_digit _# byte #_base_# int => #_value_# int :
  int  base =:
  byte digit =:
  digit '0' >= && digit '9' <= end if
    digit '0' charDiff
  else digit 'A' >= && digit 'Z' <= end _if
    digit 'A' charDiff 10 +
  else digit 'a' >= && digit 'Z' <= end _if
    digit 'a' charDiff
    base 37 < if 10 else 36 end +
  else
    "invalid digit for base " base  10 false false intToString :+ " number: '" :<< digit "'\n" :+ eputs
    1 exit ## addLater? return error-code instead of exit
  end
  dup base >= if
    "invalid digit for base " base  10 false false intToString :+ " number: '" :<< digit "'\n" :+ eputs
    1 exit
  end
end

stringToInt proc #_source_# string #_base_# int => int :
  int base =:
  string source =:
  base 2 < || base 62 > end if
    "Base out of range: " base  10 false false intToString :+ ", base has to be between 2 and 62\n" :+ eputs
    1 exit
  end
  0 ## res
  false bool sgn =:
  source 0 [] '-' == if
    true sgn =
    1 ## i = 1
  else source 0 [] '+' == _if
    1 ## i = 1
  else
    0 ## i = 0
  end
  int_MAX base / int max =:
  while dup source length < :
    swap
    dup max > if
      "invalid string-format for int \"" source :+ "\" (overflow)\n" :+ eputs
      1 exit
    end
    base * over source swap [] base __NUMBERS_valueOfDigit +
    swap 1 +
  end drop
  sgn if -_ end
end

parseInt #define 10 core stringToInt . #end

_isExpChar proc #_char_# byte #_base_# int => bool :
  int base =:
  byte c =:
  c 'e' == || c 'E' == end if
    base 'E' 'A' - 10 + 1 + <
  else c 'p' == || c 'P' == end _if
    base 'P' 'A' - 10 + 1 + <
  else c 'x' == || c 'X' == end _if
    base 'X' 'A' - 10 + 1 + <
  else c '#' == _if
    true
  else
    false
  end
end

stringToFloat proc #_str_# string #_base_# int => float :
  int base =:
  string str =:
  base 2 < || base 62 > end if
    "Base out of range: " base  10 false false intToString :+ ", base has to be between 2 and 62\n" :+ eputs
    1 exit
  end
  0 ## val
  false bool sgn =:
  str 0 [] '-' == if
    true sgn =
    1 ## i = 1
  else str 0 [] '+' == _if
    1 ## i = 1
  else
    0 ## i = 0
  end
  0  int c =:
  0  int d =:
  -1 int e =:
  2 53 ** int max =: ## maximum precision of ieee float64
  while dup str length < :
    dup str swap [] '.' == if ## str[i] == '.'
      d 0 != if
        "invalid string-format for float \"" str :+ "\"\n" eputs
        1 exit
      end
      1 d =
    else dup str swap [] base _isExpChar _if
      dup 1 + e =
      str length + ## break Loop by setting index to value >= str.length
    else
      swap
      dup max < if
        base * over str swap [] base __NUMBERS_valueOfDigit +
        c d + c =
      else
        over str swap [] base __NUMBERS_valueOfDigit drop ## check digit without storing value
        c 1 d - + c =
      end
      swap
    end
    1 +
  end drop
  e 0 > if
    c str e str length [:] base stringToInt - c =
  end
  sgn if -_ end base c -_ float cast ** *
end

parseFloat #define 10 core stringToFloat . #end

#end ## core