core #module

stack #include
chars #include
stringIO #include

uint_MAX #define  0xffffffffffffffffu #end
uint_MIN #define                   0u #end
 int_MAX #define  0x7fffffffffffffff  #end
 int_MIN #define -0x8000000000000000  #end

#_ addLater float_MIN, float_MAX _#
float_NaN #define 0 0.0 / #end ##? make constants when 1. float is a system-independent type, 2. pre-evaluation supports /
float_Positive_Infinity #define 1 0.0 / #end
float_Negative_Infinity #define -1 0.0 / #end

float_isNaN proc float => bool :
  float val =:
  val val =!= return
end
float_isFinite proc float => bool :
  float val =:
  val float_Positive_Infinity < && val float_Negative_Infinity > end return
end

__NUMBERS_getDigit proc #_value_# int #_base_# int #_big_# bool => #_ char _# byte :
    bool big =:
    int base =:
    int value =:
    value 0 < || value base >= end if
        ## even though intToString calls this function
        ## this error check should not be activated when intToString is called normally
        "Digit out of range: " value  10 false false intToString :+ " base: "
        :+ base  10 false false intToString '\n' :<< eputs
        1 exit
    end
    value 10 < if
        value '0' +char return
    else value 36 < _if
        value 10 -
        big || base 36 > end if 'A'  else 'a' end +char return
    else
        value 36 - 'a' +char return
    end
end

intToString proc #_value_# int #_base_# int #_unsigned_# bool #_big_# bool => string :
  bool big =:
  bool unsigned =:
  int base =:
  int value =:
  base 2 < || base 62 > end if
    ## even though printing recursively calls this function
    ## this error check should not be activated when intToString is called normally
    "Base out of range: " base 10 false false intToString :+ ", base has to be between 2 and 62\n" :+ eputs
    1 exit
  end
  value 0 == if
    "0" return
  end
  false bool neg =:
  "" ## result
  value 0 < if
    unsigned if
      value uint cast base uint cast % base big __NUMBERS_getDigit :<<
      value uint cast base uint cast / value =
    else
      true neg =
      value -_ value =
      value 0 < if  ## int_MIN
        value uint cast base uint cast % base big __NUMBERS_getDigit :<<
        value uint cast base uint cast / value =
      end
    end
  end
  while value 0 > do
      value base % base big __NUMBERS_getDigit swap >>:
      value base / value =
  end
  neg if
    "-" swap +:
  end
end

floatToString proc #_value_# float #_precision_# int #_base_# int #_big_# bool #_sci_# bool => string :
  bool  sci =:
  bool  big =:
  int   base =:
  int   precision =:
  float value =:
  base 2 < || base 62 > end if
    "Base out of range: " base 10 false false intToString :+ ", base has to be between 2 and 62\n" :+ eputs
    1 exit
  end
  value float_isFinite ! if
    value float_isNaN if
      "[NaN]"
    else value 0 > _if
      "[Infinity]"
    else
      "-[Infinity]"
    end return
  else value 0.0 == || value -0.0 == end _if
    "0" return
  end
  "" ## result
  value 0 < if
    '-' :<<
    value -_ value =
  end
  0b1e-110100 #_2^-52_# value * float eps =: ##? better implementation of eps
  value log base log / floor int e =:
  e int e_max =:
  base e float cast ** float p =:
  64 int list new int list buff =:
  0 int n =:
  while p eps > do
    value p / floor int cast int d =:
    buff d :<< buff =
    n 1 + n =
    value d p * - value =
    p base / p =
    e 1 + e =
  end
  precision 0 == || precision n >= end if
    n 1 -
  else
    precision
  end n =
  buff n [] base 2 / >= if
    n 1 - int j =:
    true bool inc =:
    while inc && j 0 >= end do
      buff   buff j [] 1 +   j [] =
      buff j [] base >= if
          buff   buff j [] base -  j [] =
      else
          false inc =
      end
      j 1 - j =
    end
    inc if
      1 buff >>: buff =
      e_max 1 + e_max =
      n 1 + n =
    end
  end
  while n 1 - e_max > && buff n 1 - [] 0 == end do
    n 1 - n =
  end
  sci || e_max n >= || e_max -5 < end end if
    while n 1 - 0 > && buff n 1 - [] 0 == end do
      n 1 - n =
    end
    buff 0 [] base big __NUMBERS_getDigit :<<
    n 1 > if
      '.' :<<
      1 while dup n < do
         swap over buff swap [] base big __NUMBERS_getDigit :<<
         swap 1 +
      end drop
    end
    base 10 <= if 'E' else base 30 <= _if 'X' else '#' end :<<
    e_max 0 >= if '+' :<< end
    e_max  base false big intToString :+
  else e_max 0 >= _if
    0 while dup n < do
      swap over buff swap [] base big __NUMBERS_getDigit :<<
      over e_max == && over n 1 - < end if
        '.' :<<
      end
      swap 1 +
    end drop
  else
    "0." :+
    e_max -_ 1 - while dup 0 > do
      swap '0' :<<
      swap 1 -
    end drop
    0 while dup n < do
      swap over buff swap [] base big __NUMBERS_getDigit :<<
      swap 1 +
    end drop
  end
end

valueOfDigit proc #_digit _# byte #_base_# int => #_value_# int :
  int  base =:
  byte digit =:
  digit '0' >= && digit '9' <= end if
    digit '0' charDiff
  else digit 'A' >= && digit 'Z' <= end _if
    digit 'A' charDiff 10 +
  else digit 'a' >= && digit 'z' <= end _if
    digit 'a' charDiff
    base 37 < if 10 else 36 end
    +
  else
    -1
  end
  dup base >= if
    drop -1 return
  end
  return
end

StringParseError enum
  ERR_NONE
  ERR_BASE
  ERR_EMPTY
  ERR_OVERFLOW
  ERR_ILLEGAL_CHAR
end

stringToInt proc #_source_# string #_base_# int #_unsigned_# bool => #_val_# int #_err-code_# StringParseError :
  bool unsigned =:
  int  base =:
  string source =:
  base 2 < || base 62 > end if
    0 StringParseError ERR_BASE . return
  end
  source length 0 == if
    0 StringParseError ERR_EMPTY . return
  end
  0 int res =:
  0 int i =:
  false bool sgn =:
  source 0 [] '-' == if
    true sgn =
    1 i =
  else source 0 [] '+' == _if
    1 i =
  end
  unsigned if uint_MAX else int_MAX end base uint cast / int max =:
  while i source length < do
    res max > if
      res  sgn if -_ end StringParseError ERR_OVERFLOW . return
    end
    source i [] base valueOfDigit int tmp =:
    tmp 0 < if
      res  sgn if -_ end StringParseError ERR_ILLEGAL_CHAR . return
    end
    res base * tmp + res =
    i 1 + i =
  end
  res  sgn if -_ end StringParseError ERR_NONE . return
end

checkErrCode proc #_err-code_# StringParseError #_type-name_# string #_source_# string => :
  string source =:
  string typeName =:
  #_err-code_# switch
  StringParseError ERR_NONE . case end-case
  StringParseError ERR_BASE . case
      "invalid string-format for " typeName :+ " \"" +: source :+ "\" (base outside of allowed rage)\n" :+ eputs
      1 exit
  end-case
  StringParseError ERR_EMPTY . case
      "invalid string-format for " typeName :+ " \"" +: source :+ "\" (empty-string)\n" :+ eputs
      1 exit
  end-case
  StringParseError ERR_ILLEGAL_CHAR . case
      "invalid string-format for " typeName :+ " \"" +: source :+ "\" (illegal-character)\n" :+ eputs
      1 exit
  end-case
  StringParseError ERR_OVERFLOW . case
      "invalid string-format for " typeName :+ " \"" +: source :+ "\" (overflow)\n" :+ eputs
      1 exit
  end-case
  end
end
parseInt proc string => int :
  string source =:
  source 10 false core stringToInt .
  "int" source checkErrCode
end
parseUInt proc string => int :
  string source =:
  source 10 true core stringToInt .
  "uint" source checkErrCode
end

_isExpChar proc #_char_# byte #_base_# int => bool :
  int base =:
  byte c =:
  c 'e' == || c 'E' == end if
    base 'E' 'A' - 10 + 1 + <
  else c 'p' == || c 'P' == end _if
    base 'P' 'A' - 10 + 1 + <
  else c 'x' == || c 'X' == end _if
    base 'X' 'A' - 10 + 1 + <
  else c '#' == _if
    true
  else
    false
  end
end

stringToFloat proc #_str_# string #_base_# int => #_val_# float #_err-code_# StringParseError :
  int base =:
  string str =:
  base 2 < || base 62 > end if
    float_NaN StringParseError ERR_BASE . return
  end
  str length 0 == if
    0 StringParseError ERR_EMPTY . return
  end
  0 int val =:
  0 int i =:
  false bool sgn =:
  str 0 [] '-' == if
    true sgn =
    1 i =
  else str 0 [] '+' == _if
    1 i =
  end
  0  int c =:
  0  int d =:
  -1 int e =:
  2 53 ** int max =: ## maximum precision of ieee float64
  while i str length < do
    str i [] '.' == if ## str[i] == '.'
      d 0 != if
        float_NaN StringParseError ERR_ILLEGAL_CHAR . return
      end
      1 d =
    else str i [] base _isExpChar _if
      i 1 + e =
      i str length + i =  ## break Loop by setting index to value >= str.length
    else
      str i [] base valueOfDigit int tmp =:
      tmp 0 < if
        0.0 StringParseError ERR_ILLEGAL_CHAR . return
      end
      val max < if
        val base * tmp + val =
        c d + c =
      else
        c 1 d - + c =
      end
    end
    i 1 + i =
  end
  e 0 > if
    str e str length [:] base false stringToInt
    StringParseError err_code =:
    int exponent =:
    err_code StringParseError ERR_NONE . != if
      float_NaN err_code return
    end
    c exponent - c =
  end
  val  sgn if -_ end base c -_ float cast ** * StringParseError ERR_NONE . return
end

parseFloat proc string => float :
  string source =:
  source 10 core stringToFloat .
  "float" source checkErrCode
end

#end ## core