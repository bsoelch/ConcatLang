lib/iterator :

core #namespace

Iterator public struct{ A <>
  A @doNothing :^> pseudo
}
BiIterator public struct{ A <> A Iterator extend
  A @doNothing :<^ pseudo
}
doNothing private proc( A <> A Iterator => A Iterator A optional ){
   #+itr+# A empty return
}
## addLater? allow iterators to modify the underlying list

ArrayIterator struct{ A <> A BiIterator extend
  A @ArrayIterator.^> :^> pseudo
  A @ArrayIterator.<^ :<^ pseudo

  A array mut? :array private
  int          :index private
}
^_ public proc( A <?> A array mut? => A ArrayIterator ){
  A array mut? elements =:
  elements 0 A ArrayIterator new
}

_^ public proc( A <?> A array mut? => A ArrayIterator ){
  A array mut? elements =:
  elements elements .length A ArrayIterator new
}

## pseudo-field
ArrayIterator.^> private proc( A <> A ArrayIterator => A ArrayIterator A optional ){
  A ArrayIterator mItr =:
  mItr .index mItr .array .length < if{
    mItr .array mItr .index 1 + A ArrayIterator new ## update iterator
    mItr .array mItr .index [] wrap ## push element
    return
  else
    mItr  A empty return
  }
}
## pseudo-field
ArrayIterator.<^ private proc( A <> A ArrayIterator => A ArrayIterator A optional ){
  A ArrayIterator mItr =:
  mItr .index 0 > if{
    mItr .array mItr .index 1 - A ArrayIterator new ## update iterator
    mItr .array mItr .index 1 - [] wrap ## push element
    return
  else
    mItr  A empty return
  }
}

#end ## core