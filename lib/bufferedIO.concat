lib/bufferedIO :

stack #include
core #import
io #include
io #namespace

BufferedInput public struct{
  FILE      :file
  byte list :buffer
  int       :cap
}

newBufferedInput public proc( FILE #+ cap +# int => BufferedInput ){
    int cap =:
    FILE file =:
    file cap byte list new cap BufferedInput new return
}

BufferedInput.readTo public proc( BufferedInput #+buffer+# byte list #+amount+# int => #+n-read+#int ){
  int count =:
  byte list buffer =:
  BufferedInput in =:
  in .buffer byte list inBuf =:
  0 int nRead =:
  inBuf .length 0 > if{ ##read from buffer
    count inBuf .length < if{ count else inBuf .length } nRead =
    buffer inBuf 0 nRead [:] <<* drop
    inBuf 0 nRead [:] clear
    count nRead - count =
  }
  count 0 > if{ ## get more data from file
    in .file inBuf 0 in .cap read int res =:
    res 0 < if{
      nRead 0 > if{ nRead else res } return
    }
  }
  inBuf .length 0 > if{ ##read from buffer
    count inBuf .length < if{ count else inBuf .length } int n =:
    buffer inBuf 0 n [:] <<* drop
    inBuf 0 n [:] clear
    count n - count =
    nRead n + nRead =
  }
  nRead return
}

BufferedInput.nextByte public proc( BufferedInput => byte optional ){
  BufferedInput in =:
  in .buffer byte list inBuf =:
  inBuf .length 0 == if{
    in .file inBuf 0 in .cap read int res =:
    res 0 <= if{
      byte empty return
    }
  }
  inBuf 0 [] byte res =:
  inBuf 0 1 [:] clear ##remove first element
  res wrap return
}

## addLater? BufferedOutput

#end