core #module

stack #include
stringIO #include
numbers  #include

string<<codepoint proc ## string codepoint -> string
  int cast int cp =:
  string      str =:
  if cp 0x80 < :  ## ascii - character
    str cp byte cast :<< return
  elif cp 0x800 < :  ## 2-byte blocks
    str cp 6 >>          0xc0 | byte cast :<<
        cp        0x3f & 0x80 | byte cast :<< return
  elif cp 0x10000 < :  ## 3-byte blocks
    str cp 12 >>         0xe0 | byte cast :<<
        cp  6 >>  0x3f & 0x80 | byte cast :<<
        cp        0x3f & 0x80 | byte cast :<< return
  elif cp 0x10ffff < : ## 4-byte blocks
    str cp 18 >>         0xf0 | byte cast :<<
        cp 12 >>  0x3f & 0x80 | byte cast :<<
        cp  6 >>  0x3f & 0x80 | byte cast :<<
        cp        0x3f & 0x80 | byte cast :<< return
  else
    ## don't exit on invalid codepoints, only display waring message
    "Codepoint out of range: " cp int cast true 16 false intToString :+ '\n' :<< eputs
  end
end

codepoint>>string proc ##codepoint string -> string
  string    str =:
  codepoint cp =: ##addLater? more effective algorithm
  str 0 0 [:] cp string<<codepoint drop
  str return
end

string:+ustring proc ## string ustring -> string
  ustring append =:
  string  value  =:
  value value length append length + ensureCap drop
  0 int i =:
  while i append length < :
    value append i [] string<<codepoint value =
    i 1 + i =
  end
  value return
end

ustring+:string proc ## ustring string -> string
  string  value  =:
  ustring append =:
  value value length append length + ensureCap drop
  append length 1 - int i =:
  while i 0 >= :
    append i [] value codepoint>>string value =
    i 1 - i =
  end
  value return
end

ustring:+string proc ## ustring string -> ustring
  string  append  =:
  ustring value   =:
  value value length append length + ensureCap drop
  append 0
  while nextCodepoint :
    value swap :<< value =
  end 0 3 $drop ## drop remaining data
  value return
end
string+:ustring proc ## string ustring -> ustring
  ustring value   =:
  string  append  =: ##addLater? more effective algorithm
  value 0 0 [:] append ustring:+string drop
  value return
end

codepointToString proc ## codepoint -> string
  "" swap string<<codepoint return
end

codepointsToString proc ## codepoint list -> string
  ustring source =:
  "" source string:+ustring return
end

#_
gets the first full codepoint in the given string that starts at or after index,
returns true/false depending of if there was a next codepoint
the value of the read codepoint (of 0 if the end of the string was reached)
followed by the index after the next codepoint and the string
_#
nextCodepoint proc ## string index:int -> string end:int codepoint bool
  int    index =:
  string value =:
  while && index value length < : value index [] int cast 0xc0 & 0x80 == end :
    index 1 + index = ## skip parts of unfinished codepoint
  end
  while index value length < :
    value index [] int char =:
    if char 0x80 & 0 == : ## ascii - character
      value  index 1 +  char codepoint cast  true return
    else ## multi - char codepoint
      0 while char 0x80 & 0 != :
        char 1 << char =
        1 +
      end
      int count =:
      char 0xff & count >> int res =:
      if index count + value length > :
        value value length  0 codepoint cast  false return
      end
      count 1 - count =
      while
        index 1 + index =
        count 1 - count =
        value index [] char =
        if char 0xc0 & 0x80 == :
          res 6 <<  char 0x3f &  | res =
        else
          index count + index =
           0 count =
          -1 res =
        end
        count 0 >
      : end
      if && res 0 >= : res 0x10ffff <= end :
        value index  res codepoint cast  true return
      end
    end
  end
  value index  0 codepoint cast  false return
end

codepoints proc ## string -> ustring
  string source =:
  u"" source ustring:+string return
end

#end ##core