lib/lists :

core #namespace
stack #include
codeblocks #include

## TODO binary search

reverse public proc( A <?> A list  => ){
  A list toReverse =:
  0 int mut i =:
  toReverse .length 1 - int maxId =:
  while{ i toReverse .length 2 / < do
    toReverse i [] A tmp =:
    toReverse maxId i - []  toReverse i []=
    tmp  toReverse maxId i - []=
    i 1 + i =
  }
}

mergesort_helper proc( A <?> A list #+off+# int #+to+# int #+buffer+# A list => ){
  A list buffer =:
  int to =:
  int mut off =:
  A list input =:
  off to < if{
    off to + 2 / int mut c =:
    input off c buffer mergesort_helper
    c 1 + c =
    input c  to buffer mergesort_helper
    ## 0 ... c-1 and c...to-1 are sorted
    c int mut i =:
    while{ off c < &&{ c to <= } do
      while{ off c < &&{ input off [] input c [] <= } do
        off 1 + off =
      }
      off c < if{
        while{ i to <= &&{ input off [] input i [] <= ! } do
          i 1 + i =
        }
        i c - int delta =:
        delta c off - <= if{
          buffer clear
          buffer input c i [:] <<* drop ## store data in buffer
          input off c [:]  input off delta + c delta + [:]= ## move remaining part of left half to the right
          buffer  input off  off delta + [:]= ## get the elements from buffer
          buffer clear
        else
          buffer clear
          buffer input off c [:] <<* drop ## store data in buffer
          input c i [:]  input off  off delta + [:]= ## move remaining part of left half to the right
          buffer  input off delta + i [:]= ## get the elements from buffer
          buffer clear
        }
        i c =
        off 1 + off =
      }
    }
  }
}

#+ sorts the given list
  elements are compared using 'core .<='
  the sorted list overwrites the given list
 +#
mergesort public proc( A <?> A list => ){
  A list input =:
  #+list+# input #+off+#0 #+to+# input .length 1 - #+buffer+# input .length 2 / A list new mergesort_helper
}

mergesort2_helper proc( A <?> A list #+cmp+# ( A A => int ) #+off+# int #+to+# int #+buffer+# A list => ){
  A list buffer =:
  int to =:
  int mut off =:
  ( A A => int ) cmp =:
  A list input =:
  off to < if{
    off to + 2 / int mut c =:
    input cmp off c buffer mergesort2_helper
    c 1 + c =
    input cmp c  to buffer mergesort2_helper
    ## 0 ... c-1 and c...to-1 are sorted
    c int mut i =:
    while{ off c < &&{ c to <= } do
      while{ off c < &&{ input off [] input c [] cmp () 0 <= } do
        off 1 + off =
      }
      off c < if{
        while{ i to <= &&{ input off [] input i [] cmp () 0 > } do
          i 1 + i =
        }
        i c - int delta =:
        delta c off - <= if{
          buffer clear
          buffer input c i [:] <<* drop ## store data in buffer
          input off c [:]  input off delta + c delta + [:]= ## move remaining part of left half to the right
          buffer  input off  off delta + [:]= ## get the elements from buffer
          buffer clear
        else
          buffer clear
          buffer input off c [:] <<* drop ## store data in buffer
          input c i [:]  input off  off delta + [:]= ## move remaining part of left half to the right
          buffer  input off delta + i [:]= ## get the elements from buffer
          buffer clear
        }
        i c =
        off 1 + off =
      }
    }
  }
}

#+ sorts the given list
  elements are compared using the given comparison function
  the sorted list overwrites the given list
 +#
mergesort2 public proc( A <?> A list ( A A => int ) => ){
  ( A A => int ) cmp =:
  A list input =:
  #+list+# input #+cmp+# cmp #+off+# 0 #+to+# input .length 1 - #+buffer+# input .length 2 / A list new
  mergesort2_helper
}

map public proc( A <?> B <?> A list ( A => B ) => B list ){
  f =::
  l =::
  l .length B list new res =::
  0 i =::
  res while{ i l .length < do
    l i [] f () <<
    i 1 + i =
  }
  #+res+# return
}
filter public proc( A <?> A list ( A => bool ) => A list ){
  f =::
  l =::
  l .length A list new res =::
  0 i =::
  res while{ i l .length < do
    l i [] f () if{
      l i [] <<
    }
    i 1 + i =
  }
  #+res+# return
}

#end ## core